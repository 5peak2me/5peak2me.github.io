<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java字节码 · J!nl!n's Blog</title><meta name="description" content="Java字节码 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java字节码</h1><div class="post-info">Nov 17, 2019</div><div class="post-content"><p>   <strong> 概述：</strong>张龙深入理解JVM视频Java字节码部分学习笔记<br><a id="more"></a></p>
<h1 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Java虚拟机不和包括java在内的任何语言绑定，它只与“Class”特定的二进制文件格式关联，Class文件中包含Java虚拟机指令集和符号表以及若干其他辅助信息。本文将以字节码的角度来研究Java虚拟机。</li>
</ul>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ul>
<li>Java跨平台的原因是JVM不跨平台</li>
<li>首先编写一个简单的java代码，一次为例进行讲解</li>
</ul>
<h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1:"></a>测试1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * 源码：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<strong>javap</strong>命令后的字节码文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;ByteCodeTest1.java&quot;</span><br><span class="line">public class com.poplar.bytecode.ByteCodeTest1 &#123;</span><br><span class="line">  public com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">  public int getA();</span><br><span class="line">  public void setA(int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<strong>javap -c</strong>命令后的字节码文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"ByteCodeTest1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">poplar</span>.<span class="title">bytecode</span>.<span class="title">ByteCodeTest1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_1</span><br><span class="line">       6: putfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">4</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       2: putfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<strong>javap -verbose</strong>命令后的字节码文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/idea-workspace/jvm-study/build/classes/java/main/com/poplar/bytecode/ByteCodeTest1<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2019-11-9</span>; size <span class="number">503</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">785</span>bb46a966a166c3101fb5c64415667</span><br><span class="line">  Compiled from <span class="string">"ByteCodeTest1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">poplar</span>.<span class="title">bytecode</span>.<span class="title">ByteCodeTest1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/poplar/bytecode/ByteCodeTest1.a:I</span><br><span class="line">   #3 = Class              #22            // com/poplar/bytecode/ByteCodeTest1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               ByteCodeTest1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/poplar/bytecode/ByteCodeTest1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"ByteCodeTest1.java"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用winHex打开后的文件：</li>
</ul>
<p><img src="/res/class/byte.png" alt="ByteCodeTest1"></p>
<ol>
<li><p>使用javap -verbose ByteCodeTest1命令分析一个字节码文件时，将会分析该字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量的信息。</p>
</li>
<li><p>魔数：所有的.class文件的前四个字节都是魔数，魔数值为固定值：0xCAFEBABE（咖啡宝贝）</p>
</li>
<li><p>版本号：魔数后面4个字节是版本信息，前两个字节表示minor version（次版本号），后两个字节表示major version（主版本号），十六进制34=十进制52。所以该文件的版本号为1.8.0。低版本的编译器编译的字节码可以在高版本的JVM下运行，反过来则不行。</p>
</li>
<li><p>常量池（constant pool）：版本号之后的就是常量池入口，一个java类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是class文件的资源仓库，包括java类定义的方法和变量信息，常量池中主要存储两类常量：字面量和符号引用。字面量如文本字符串、java中生命的final常量值等，符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p>
</li>
<li><p>常量池的整体结构：Java类对应的常量池主要由常量池数量和常量池数组两部分共同构成，常量池数量紧跟在主版本号后面，占据两个字节，而常量池数组在常量池数量之后。常量池数组与一般数组不同的是，常量池数组中元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个u1类型标志位，占据一个字节，JVM在解析常量池时，就会根据这个u1类型的来获取对应的元素的具体类型。 值得注意的是，常量池数组中元素的个数=常量池数-1,（其中0暂时不使用）。目的是满足某些常量池索引值的数据在特定的情况下需要表达不引用任何常量池的含义。根本原因在于索引为0也是一个常量，它是JVM的保留常量，它不位于常量表中。这个常量就对应null，所以常量池的索引从1而非0开始。</p>
</li>
</ol>
<p><img src="/res/class/pool.png" alt></p>
<ol>
<li>在JVM规范中，每个变量/字段都有描述信息，主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型和顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，而对象类型使用字符L+对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示。如下所示:B - byte，C - char，D - double，F - float，I - int，J -l ong，S -short，Z - boolean，V - void，L-对象类型，如Ljava/lang/String;<br>对于数组类型来说，每一个维度使用一个前置的[ 来表示，如int[]表示为[I ，String [][]被记录为[[Ljava/lang/String;</li>
<li>用描述符描述方法的时候，用先参数列表后返回值的方式来描述。参数列表按照参数的严格顺序放在一组（）之内，如方法String getNameByID(int id ,String name)<br>(I,Ljava/lang/String;)Ljava/lang/String;<br>Java字节码整体结构</li>
</ol>
<p><img src="/res/class/gg.png" alt></p>
<h3 id="Class字节码中有两种数据类型："><a href="#Class字节码中有两种数据类型：" class="headerlink" title="Class字节码中有两种数据类型："></a>Class字节码中有两种数据类型：</h3><p>（1）字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。<br>（2）表/数组：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体：组成表的成分所在的位置和顺序都是已经严格定义好的。</p>
<p>Access Falgs：<br>访问标志信息包括了该class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被定义成final。</p>
<p><img src="/res/class/re.png" alt></p>
<p><img src="/res/class/hff.png" alt></p>
<ul>
<li><p>0x0021是0x0020和0x0001的并集，表示ACC_PUBLIC和ACC_SUPER<br>0x0002:private</p>
</li>
<li><p>字段表（Fields）：<br>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量和实例变量，但是不包括方法内部声明的局部变量。</p>
</li>
</ul>
<p><img src="/res/class/fieled.png" alt></p>
<ul>
<li><p>方法表<br>方法的属性结构：<br>方法中的每个属性都是一个attribute_info结构:<br>（1）JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件里，供运行时使用；<br>（2）不同的attribute通过attribute_name_index来区分。</p>
</li>
<li><p>attribute_info格式:<br>attribute_info{<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u1 info[attribute_length]<br>}</p>
</li>
<li><p>attribute_name_index值为code，则为Code结构<br>Code的作用是保存该方法的结构，所对应的的字节码<br><img src="/res/class/dss.png" alt></p>
</li>
</ul>
<p>attribute_length：表示attribute所包含的字节数，不包含attribute_name_index和attribute_length<br>max_stacks：表示这个方法运行的任何时刻所能达到的操作数栈的最大深度<br>max_locals：表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量<br>code_length：表示该方法所包含的字节码的字节数以及具体的指令码。具体的字节码是指该方法被调用时，虚拟机所执行的字节码<br>exception_table：存放处理异常的信息，每个exception_table表，是由start_pc、end_pc、hangder_pc、catch_type组成<br>start_pc、end_pc：表示在code数组中从start_pc到end_pc（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理<br>hangder_pc：表示处理异常的代码的开始处。<br>catch_type：表示会被处理的异常类型，它指向常量池中的一个异常类。当catch_type=0时，表示处理所有的异常。</p>
<ul>
<li><p>附加其他属性：</p>
</li>
<li><p>LineNumbeTable_attribute:<br> <img src="/res/class/rew.png" alt></p>
</li>
</ul>
<p>这个属性表示code数组中，字节码与java代码行数之间的关系，可以在调试的时候定位代码执行的行数。</p>
<ul>
<li><p>LocalVariableTable ：结构类似于 LineNumbeTable_attribute<br>对于Java中的任何一个非静态方法，至少会有一个局部变量，就是this。</p>
</li>
<li><p>字节码查看工具：jclasslib<br><a href="http://github.com/ingokegel/jclasslib">http://github.com/ingokegel/jclasslib</a></p>
</li>
<li><p>测试2 ——- 反编译分析MyTest2.class<br>static变量会导致出现static代码块</p>
</li>
</ul>
<h3 id="测试3："><a href="#测试3：" class="headerlink" title="测试3："></a>测试3：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * 从字节码分析得出的结论：</span></span><br><span class="line"><span class="comment"> * 成员变量的初始化是在构造方法中完成的，有多少个构造方法，初始化指令就会调用几次</span></span><br><span class="line"><span class="comment"> * 静态成员变量同样是在clinit方法完成的，不管有多少个静态变量都是在该方法完成初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">"Welcome"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer in = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">(String str, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteCodeTest2 byteCodeTest2 = <span class="keyword">new</span> ByteCodeTest2();</span><br><span class="line">        byteCodeTest2.setX(<span class="number">8</span>);</span><br><span class="line">        in = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//给当前对象上锁</span></span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给类字节码码上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 对于Java类中的每一个实例方法(非static方法) ,其在编译后所生成的字节码当中,方法参数的数量总是会比源代码中方法数的数量多一个(this) ,</span></span><br><span class="line"><span class="comment"> * 它位于方法的第一个参数位置处;这样,我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。</span></span><br><span class="line"><span class="comment"> * 这个操作是在编译期间完成的,即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问;</span></span><br><span class="line"><span class="comment"> * 接下来在运行期间由JVM在调用实例方法时,自动向实例方法传入this参数.所以,在实例方法的局部变量表中,至少会有一个指向当前对象的局部变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java字节码对于异常的处理方式：</span></span><br><span class="line"><span class="comment"> * 1.统一采用异常表的方式来对异常进行处理；</span></span><br><span class="line"><span class="comment"> * 2.在jdk1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；</span></span><br><span class="line"><span class="comment"> * 3.当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句内的字节码拼接到每个catch语句块后面。</span></span><br><span class="line"><span class="comment"> * 也就是说，程序中存在多少个catch，就存在多少个finally块的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>对于Java类中的每一个实例方法(非static方法) ,其在编译后所生成的字节码当中,方法参数的数量总是会比源代码中方法数的数量多一个(this) ,<br>它位于方法的第一个参数位置处;这样,我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。<br>这个操作是在编译期间完成的,即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问;<br>接下来在运行期间由JVM在调用实例方法时,自动向实例方法传入this参数.所以,在实例方法的局部变量表中,至少会有一个指向当前对象的局部变量</li>
<li><p>Java字节码对于异常的处理方式：<br>1.统一采用异常表的方式来对异常进行处理；<br>2.在jdk1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；<br>3.当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句内的字节码拼接到每个catch语句块后面。<br>也就是说，程序中存在多少个catch，就存在多少个finally块的内容。</p>
</li>
<li><p>栈帧（stack frame）：<br>用于帮助虚拟机执行方法调用和方法执行的数据结构<br>栈帧本身是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。<br>符号引用：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。（在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。）<br>直接引用：（1）直接指向目标的指针（指向对象，类变量和类方法的指针）（2）相对偏移量。（指向实例的变量，方法的指针）（3）一个间接定位到对象的句柄。<br>有些符号引用在加载阶段或者或是第一次使用时，转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在运行期转换为直接引用，这种转换叫做动态链接。</p>
</li>
<li><p>助记符：<br>1.invokeinterface：调用接口的方法，在运行期决定调用该接口的哪个对象的特定方法。<br>2.invokestatic：调用静态方法<br>3.invokespecial：调用私有方法， 构造方法（），父类的方法<br>4.invokevirtual：调用虚方法，运行期动态查找的过程<br>5.invokedynamic：动态调用方法</p>
</li>
<li><p>静态解析的四种场：静态方法、父类方法、构造方法、私有方法。</p>
</li>
<li>以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。</li>
</ul>
<h3 id="测试5："><a href="#测试5：" class="headerlink" title="测试5："></a>测试5：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 静态解析的四种场：静态方法、父类方法、构造方法、私有方法。</span></span><br><span class="line"><span class="comment"> * 以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法的静态分派。</span></span><br><span class="line"><span class="comment"> * Grandpa g1 = new Father();</span></span><br><span class="line"><span class="comment"> * 以上代码, g1的静态类型是Grandpa,而g1的实际类型(真正指向的类型)是Father.</span></span><br><span class="line"><span class="comment"> * 我们可以得出这样一个结论:变量的静态类型是不会发生变化的,而变量的实际类型则是可以发生变化的(多态的一种体现)</span></span><br><span class="line"><span class="comment"> * 实际变量是在运行期方可确定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Grandpa grandpa)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grandpa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteCodeTest4 byteCodeTest4 = <span class="keyword">new</span> ByteCodeTest4();</span><br><span class="line">        <span class="comment">//方法重载,是一种静态的行为,编译期就可以完全确定</span></span><br><span class="line">        Grandpa g1 = <span class="keyword">new</span> Father();</span><br><span class="line">        Grandpa g2 = <span class="keyword">new</span> Son();</span><br><span class="line">        byteCodeTest4.test(g1);<span class="comment">//Grandpa</span></span><br><span class="line">        byteCodeTest4.test(g2);<span class="comment">//Grandpa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试6："><a href="#测试6：" class="headerlink" title="测试6："></a>测试6：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 方法的动态分派</span></span><br><span class="line"><span class="comment"> * 方法的动态分派涉及到一个重要概念:方法接收者。</span></span><br><span class="line"><span class="comment"> * invokevirtua1字节码指令的多态查找流程</span></span><br><span class="line"><span class="comment"> * 比较方法重载(overload)与方法重写(overwrite) ,我们可以得到这样一个结论:</span></span><br><span class="line"><span class="comment"> * 方法重载是静态的,是编译期行为;</span></span><br><span class="line"><span class="comment"> * 方法重写是动态的,是运行期行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.test();<span class="comment">//&lt;com/poplar/bytecode/Fruit.test&gt;将符号引用转换为直接引用</span></span><br><span class="line"></span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Orange();</span><br><span class="line">        orange.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fruit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试7："><a href="#测试7：" class="headerlink" title="测试7："></a>测试7：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 基于栈的解释器的执行过程概念模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicStackExecutionProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   public int calc();</span></span><br><span class="line"><span class="comment">    descriptor: ()I</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">      stack=2, locals=4, args_size=1</span></span><br><span class="line"><span class="comment">         0: bipush        100  执行地址偏移量为0 将100推送至栈顶</span></span><br><span class="line"><span class="comment">         2: istore_1          执行地址偏移量为2  将栈顶的100出栈并存放到第一个局部变量Slot中</span></span><br><span class="line"><span class="comment">         3: sipush        200</span></span><br><span class="line"><span class="comment">         6: istore_2</span></span><br><span class="line"><span class="comment">         7: sipush        300</span></span><br><span class="line"><span class="comment">        10: istore_3</span></span><br><span class="line"><span class="comment">        11: iload_1          执行地址偏移量为11 将局部变量中第一个Slot中的整型值复制到栈顶</span></span><br><span class="line"><span class="comment">        12: iload_2</span></span><br><span class="line"><span class="comment">        13: iadd            将栈顶的两个元素出栈并作整形加法，然后把结果重新入栈</span></span><br><span class="line"><span class="comment">        14: iload_3</span></span><br><span class="line"><span class="comment">        15: imul            将栈顶的两个元素出栈并作整形乘法，然后把结果重新入栈</span></span><br><span class="line"><span class="comment">        16: ireturn         结束方法并将栈顶的值返回给方法调用者</span></span><br><span class="line"><span class="comment">      LineNumberTable:</span></span><br><span class="line"><span class="comment">        line 10: 0</span></span><br><span class="line"><span class="comment">        line 11: 3</span></span><br><span class="line"><span class="comment">        line 12: 7</span></span><br><span class="line"><span class="comment">        line 13: 11</span></span><br><span class="line"><span class="comment">      LocalVariableTable:</span></span><br><span class="line"><span class="comment">        Start  Length  Slot  Name   Signature</span></span><br><span class="line"><span class="comment">            0      17     0  this   Lcom/poplar/bytecode/BasicStackExecutionProcess;</span></span><br><span class="line"><span class="comment">            3      14     1     a   I</span></span><br><span class="line"><span class="comment">            7      10     2     b   I</span></span><br><span class="line"><span class="comment">           11       6     3     c   I</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicStackExecutionProcess process = <span class="keyword">new</span> BasicStackExecutionProcess();</span><br><span class="line">        <span class="keyword">int</span> res = process.calc();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态分派："><a href="#动态分派：" class="headerlink" title="动态分派："></a>动态分派：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 动态分派的演示与证明：</span></span><br><span class="line"><span class="comment"> * 在动态分派中虚拟机是如何知道要调用那个方法的？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woMan = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.hello();</span><br><span class="line">        woMan.hello();</span><br><span class="line"></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment">    descriptor: ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">      stack=2, locals=3, args_size=1</span></span><br><span class="line"><span class="comment">         0: new           #2                  // class main/java/com/poplar/bytecode/DynamicDispatch$Man</span></span><br><span class="line"><span class="comment">         3: dup</span></span><br><span class="line"><span class="comment">         4: invokespecial #3                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Man."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">         7: astore_1</span></span><br><span class="line"><span class="comment">         8: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman</span></span><br><span class="line"><span class="comment">        11: dup</span></span><br><span class="line"><span class="comment">        12: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">        15: astore_2</span></span><br><span class="line"><span class="comment">        16: aload_1 从局部变量加载一个引用 aload1是加载索引为1的引用（man），局部变量有三个（0：args; 1 :man ; 2 :woMan）</span></span><br><span class="line"><span class="comment">        17: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        20: aload_2 加载引用woMan</span></span><br><span class="line"><span class="comment">        21: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        24: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman</span></span><br><span class="line"><span class="comment">        27: dup</span></span><br><span class="line"><span class="comment">        28: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">        31: astore_1</span></span><br><span class="line"><span class="comment">        32: aload_1</span></span><br><span class="line"><span class="comment">        33: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        36: return</span></span><br><span class="line"><span class="comment">      LineNumberTable:</span></span><br><span class="line"><span class="comment">        line 28: 0</span></span><br><span class="line"><span class="comment">        line 29: 8</span></span><br><span class="line"><span class="comment">        line 30: 16</span></span><br><span class="line"><span class="comment">        line 31: 20</span></span><br><span class="line"><span class="comment">        line 33: 24</span></span><br><span class="line"><span class="comment">        line 34: 32</span></span><br><span class="line"><span class="comment">        line 36: 36</span></span><br><span class="line"><span class="comment">      LocalVariableTable:</span></span><br><span class="line"><span class="comment">        Start  Length  Slot  Name   Signature</span></span><br><span class="line"><span class="comment">            0      37     0  args   [Ljava/lang/String;</span></span><br><span class="line"><span class="comment">            8      29     1   man   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;</span></span><br><span class="line"><span class="comment">           16      21     2 woMan   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    invokevirtual 运行期执行的时候首先：</span></span><br><span class="line"><span class="comment">    找到操作数栈顶的第一个元素它所指向对象的实际类型，在这个类型里边，然后查找和常量里边Human的方法描述符和方法名称都一致的</span></span><br><span class="line"><span class="comment">    方法，如果在这个类型下，常量池里边找到了就会返回实际对象方法的直接引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果找不到，就会按照继承体系由下往上(Man–&gt;Human–&gt;Object)查找，查找匹配的方式就是</span></span><br><span class="line"><span class="comment">    上面描述的方式，一直找到位为止。如果一直找不到就会抛出异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比较方法重载（overload）和方法重写（overwrite），我们可以得出这样的结论：</span></span><br><span class="line"><span class="comment">    方法重载是静态的，是编译器行为；方法重写是动态的，是运行期行为。</span></span><br><span class="line"><span class="comment">    ————————————————</span></span><br><span class="line"><span class="comment">    版权声明：本文为CSDN博主「魔鬼_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="comment">    原文链接：https://blog.csdn.net/wzq6578702/article/details/82712042</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态分派："><a href="#静态分派：" class="headerlink" title="静态分派："></a>静态分派：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 静态分派的演示与证明：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Human param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Man param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Woman param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticDispatch dispatch = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        <span class="comment">/*Human man = new Man();</span></span><br><span class="line"><span class="comment">        Human woMan = new Woman();</span></span><br><span class="line"><span class="comment">        dispatch.hello(man);</span></span><br><span class="line"><span class="comment">        dispatch.hello(woMan);*/</span></span><br><span class="line"></span><br><span class="line">        Human human = <span class="keyword">new</span> Woman();</span><br><span class="line">        human = <span class="keyword">new</span> Man();</span><br><span class="line">        dispatch.hello((Woman) human);</span><br><span class="line">        dispatch.hello((Man) human);</span><br><span class="line">        <span class="comment">//java.lang.ClassCastException: main.java.com.poplar.bytecode.WoMan cannot be cast to main.java.com.poplar.bytecode.Man</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>现代JVM在执行Java代码的时候,通常都会将解释执行与编译执行二者结合起来进行.</p>
<ul>
<li>所谓解释执行，就是通过解释器来读取字节码,遇到相应的指令就去执行该指令</li>
<li>所谓编译执行,就是通过即时编译器(Just in Time, JIT)将字节码转换为本地机器码来执行;现代JoM会根据代码热点来生成目应的本地机器码<br>在布尔德E马文项目</li>
</ul>
</li>
<li><p>JVM执行指令时所采取的方式是基于栈的指令集。</p>
<p>基于栈的指令集主要有入栈和出栈两种；</p>
<p>基于栈的指令集的缺点在主完成相同的操作,指令集通常要比基于寄存器的指令集要多，指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的,是在高速缓冲区中进行的,速度要快很多.虽然虚拟机可以采用一些优化手段,但总体来说,基于栈的指令集的执行速度要慢一些；</p>
<p>基手栈的指令集的优势在于它可以在不同平台之间移植,而基于寄存器的指令集是与硬件架构累密关联的,无法做到可移植。</p>
<h3 id="运行时栈结构"><a href="#运行时栈结构" class="headerlink" title="运行时栈结构"></a>运行时栈结构</h3><p><img src="/res/class/stack.png" alt="运行时栈结构"></p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/24/JVM类加载器学习/" class="prev">上一篇</a><a href="/2017/12/09/java内存模型/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>