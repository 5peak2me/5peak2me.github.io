<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JVM类加载器学习 · J!nl!n's Blog</title><meta name="description" content="JVM类加载器学习 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JVM类加载器学习</h1><div class="post-info">Nov 24, 2019</div><div class="post-content"><p>   <strong> 概述：</strong>张龙深入理解JVM视频JVM类加载器部分学习笔记<br><a id="more"></a></p>
<h1 id="JVM类加载器学习"><a href="#JVM类加载器学习" class="headerlink" title="JVM类加载器学习"></a>JVM类加载器学习</h1><h3 id="在以下几种情况下："><a href="#在以下几种情况下：" class="headerlink" title="在以下几种情况下："></a>在以下几种情况下：</h3><ul>
<li>执行了System。exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或者错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h3 id="类的加载执行与初始化"><a href="#类的加载执行与初始化" class="headerlink" title="类的加载执行与初始化"></a>类的加载执行与初始化</h3><ul>
<li>加载：查找并加载类的二进制数据</li>
<li><p>链接</p>
<ul>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的静态变量分配内存，并将其初始化为默认值</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li><p>初始化：为类的静态变量赋予正确的初始值</p>
</li>
<li><p>值得注意的是：准备阶段即使我们为静态变量赋值为任意的数值，但是该静态变量还是会被初始化为他的默认值，最后的初始化时才会把我们赋予的值设为该静态变量的值。</p>
</li>
</ul>
<h3 id="Java程序对类的使用可以分为两种"><a href="#Java程序对类的使用可以分为两种" class="headerlink" title="Java程序对类的使用可以分为两种"></a>Java程序对类的使用可以分为两种</h3><ol>
<li>主动使用<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用该类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标为启动类的类（Java Test）</li>
</ul>
</li>
<li>被动使用</li>
<li>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们</li>
</ol>
<hr>
<ul>
<li><p>类的加载:指的是将类的。class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个<code>Java.lang.Class</code>对象（规范并没有说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构</p>
</li>
<li><p>加载类的方式</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将java源文件动态编译为.class文件（将JAVA源文件动态编译这种情况会在动态代理和web开发中jsp转换成Servlet）</li>
</ul>
</li>
</ul>
<h3 id="完整加载过程"><a href="#完整加载过程" class="headerlink" title="完整加载过程"></a>完整加载过程</h3><p>加载<br>连接（验证、准备、解析）<br>初始化<br>类的是例化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值</p>
<p>java编译器在它编译的每一个类都至少生成一个实例化的方法，在java的class文件中，这个实例化方法被称为<init>。针对源代码中每一个类的构造方法，java编译器都会产生一个“<init>”方法。</init></init></p>
<p><img src="/res/classloader/classload.png" alt="完整加载过程"></p>
<p><strong>时序图</strong></p>
<p><img src="/res/classloader/classload2.png" alt="时序图"></p>
<h3 id="有两种类型的类加载器"><a href="#有两种类型的类加载器" class="headerlink" title="有两种类型的类加载器"></a>有两种类型的类加载器</h3><ol>
<li><strong>Java虚拟机自带的加载器</strong></li>
</ol>
<ul>
<li><strong>根类加载器</strong>（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。</li>
<li><strong>扩展类加载器</strong>（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。</li>
<li><strong>系统应用类加载器</strong>（AppClassLoader/System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。</li>
</ul>
<ol>
<li><strong>用户自定义的类加载器</strong></li>
</ol>
<ul>
<li>java.lang.ClassLoader的子类</li>
<li>用户可以定制类的加载方式</li>
</ul>
<p>根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器<br>类加载器并不需要等到某个类被“首次主动使用”时再加载它</p>
<p><img src="/res/classloader/Snipaste_2019-11-07_14-51-04.png" alt="类加载顺序"></p>
<p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在<strong>程序首次主动</strong>使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p>类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p>
<p>类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p>
<ul>
<li>类的连接-验证<br>1）类文件的结构检查<br>2）语义检查<br>3）字节码验证<br>4）二进制兼容性的验证</li>
<li>类的连接-准备<br>在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>初始化</strong><br>在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。<br><strong>类的初始化步骤</strong>：<br>（1）假如这个类还没有被加载和连接，那就先进行加载和连接<br>（2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类<br>（3）假如类中存在初始化语句，那就依次执行这些初始化语句<br>当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，<strong>但是这条规则不适用于接口</strong>。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> * Created By poplar on 2019/11/7</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 当一个接口在初始化时，并不要求其父接口都完成了初始化</span><br><span class="line"> * 只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line">public class ClassLoadTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild.b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Student5 &#123;</span><br><span class="line"></span><br><span class="line">    int a = 9; //前面省了public static final</span><br><span class="line"></span><br><span class="line">    Thread thread = new Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;thread 初始化了&quot;);//如果父接口初始化了这句应该输出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyChild extends Student5 &#123;     //接口属性默认是 public static final</span><br><span class="line">    String b = LocalDateTime.now().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取类加载起的方法</li>
</ul>
<p><img src="/res/classloader/vb.png" alt></p>
<p>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h3 id="类加载器的-双亲委派机制-父亲委托机制"><a href="#类加载器的-双亲委派机制-父亲委托机制" class="headerlink" title="类加载器的(双亲委派机制)父亲委托机制"></a>类加载器的(双亲委派机制)父亲委托机制</h3><p>在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器</p>
<ul>
<li>若有一个类能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</li>
</ul>
<p><img src="/res/classloader/loadmethod.png" alt="类加载器的(双亲委派机制)父亲委托机制"></p>
<h3 id="类加载器测试7"><a href="#类加载器测试7" class="headerlink" title="类加载器测试7"></a>类加载器测试7</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;<span class="comment">//null 由于String是由根加载器加载，在rt.jar包下</span></span><br><span class="line">        System.out.println(C<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;<span class="comment">//sun.misc.Launcher$AppClassLoader@73d16e93</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试9："><a href="#测试9：" class="headerlink" title="测试9："></a>测试9：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest9"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child1.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输出顺序</span></span><br><span class="line"><span class="comment">//ClassLoadTest9</span></span><br><span class="line"><span class="comment">// Parent1</span></span><br><span class="line"><span class="comment">//9</span></span><br></pre></td></tr></table></figure>
<h3 id="测试10"><a href="#测试10" class="headerlink" title="测试10:"></a>测试10:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest10"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent2 parent2;</span><br><span class="line">        parent2 = <span class="keyword">new</span> Parent2();</span><br><span class="line">        System.out.println(Parent2.a);</span><br><span class="line">        System.out.println(Child2.b);</span><br><span class="line">        <span class="comment">/*执行结果：由于父类已经初始化过了所以Parent2只输出一次</span></span><br><span class="line"><span class="comment">         * ClassLoadTest10</span></span><br><span class="line"><span class="comment">         * Parent2</span></span><br><span class="line"><span class="comment">         * 2</span></span><br><span class="line"><span class="comment">         * Child2</span></span><br><span class="line"><span class="comment">         * 3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试12："><a href="#测试12：" class="headerlink" title="测试12："></a>测试12：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 调用类的loadClass并不是主使实用类，不会导致类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; loadClass = classLoader.loadClass(<span class="string">"com.poplar.classload.G"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.poplar.classload.G"</span>);<span class="comment">//反射会导致一个类的初始化</span></span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">        <span class="comment">//输出结果：</span></span><br><span class="line">        <span class="comment">//G</span></span><br><span class="line">        <span class="comment">//class com.poplar.classload.G</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123; <span class="number">1</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"G"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试16"><a href="#测试16" class="headerlink" title="测试16:"></a>测试16:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePost = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//显示指定该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将系统类加载器当作该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"findClass,输出这句话说明我们自己的类加载器加载了指定的类"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = name.replace(<span class="string">"."</span>, File.separator);<span class="comment">//File.separator根据操作系统而变化</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name + filePost));</span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read())) &#123;</span><br><span class="line">                byteArrayOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = byteArrayOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.poplar.classload.ClassLoadTest"</span>);</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"load1"</span>);</span><br><span class="line">        test(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个列子中最后的类加载器是系统类加载器，而非我们自己的类加载器，是因为我们要加载的类刚好在系统类加载器的加载范围</span></span><br></pre></td></tr></table></figure>
<h3 id="测试16改进："><a href="#测试16改进：" class="headerlink" title="测试16改进："></a>测试16改进：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePost = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader2</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//显示指定该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader2</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将系统类加载器当作该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"findClass,输出这句话说明我们自己的类加载器加载了指定的类"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = name.replace(<span class="string">"."</span>, File.separator);<span class="comment">//File.separator根据操作系统而变化</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path + name + filePost));</span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read())) &#123;</span><br><span class="line">                byteArrayOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = byteArrayOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        CustomClassLoader2 Loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">  		test1(loader2) </span><br><span class="line">        CustomClassLoader2 Loader3 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load3"</span>);</span><br><span class="line">  		test1(loader3)    </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行结果： </span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        com.poplar.classload.CustomClassLoader2@15db9742</span></span><br><span class="line"><span class="comment">        2018699554</span></span><br><span class="line"><span class="comment">        -------------------------------------</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        com.poplar.classload.CustomClassLoader2@4e25154f</span></span><br><span class="line"><span class="comment">        1550089733*/</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(CustomClassLoader2 loader2)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader2.loadClass(<span class="string">"com.poplar.classload.ClassLoadTest"</span>);</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance.getClass().getClassLoader());</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//运行结果：（此处测试建议把源码文件先删掉，不然idea会重新生成classes,还是会导致系统类加载器加载）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间-上面的列子中加载同一个文件"><a href="#命名空间-上面的列子中加载同一个文件" class="headerlink" title="命名空间(上面的列子中加载同一个文件)"></a>命名空间(上面的列子中加载同一个文件)</h3><ul>
<li>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类构成</strong>；</li>
<li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</li>
<li>同一命名空间内的类是互相可见的，<strong>非同一命名空间内的类是不可见的</strong>；</li>
<li>子加载器可以见到父加载器加载的类，<strong>父加载器也不能见到子加载器加载的类</strong>。</li>
</ul>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul>
<li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。</li>
<li>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</li>
<li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。</li>
<li>由用户自定义的类加载器所加载的类是可以被卸载的。（<strong>jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      CustomClassLoader2 Loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">      test1(Loader2);</span><br><span class="line">      Loader2 = <span class="keyword">null</span>;</span><br><span class="line">      System.gc();</span><br><span class="line">      Thread.sleep(<span class="number">10000</span>); <span class="comment">//jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追踪类卸载的信息</span></span><br><span class="line">      CustomClassLoader2 Loader3 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">      test1(Loader3);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      执行结果：</span></span><br><span class="line"><span class="comment">      findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">      com.poplar.classload.CustomClassLoader2@15db9742</span></span><br><span class="line"><span class="comment">      2018699554</span></span><br><span class="line"><span class="comment">      -------------------------------------</span></span><br><span class="line"><span class="comment">      [Unloading class com.poplar.classload.ClassLoadTest 0x0000000100060828]</span></span><br><span class="line"><span class="comment">      findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">      com.poplar.classload.CustomClassLoader2@4e25154f</span></span><br><span class="line"><span class="comment">      1550089733*/</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试17："><a href="#测试17：" class="headerlink" title="测试17："></a>测试17：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat by load "</span> + MyCat<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Simple by Load "</span> + Simple<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试17-1</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        loader.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">        <span class="comment">//MyCat是由加载MySample的加载器去加载的：</span></span><br><span class="line">        <span class="comment">//如果只删除classpath下的MyCat，则会报错，NoClassDefFoundError；</span></span><br><span class="line">        <span class="comment">//如果只删除classpath下的MySample，则由自定义加载器加载桌面上的MySample，由系统应用加载器加载MyCat。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试17-2"><a href="#测试17-2" class="headerlink" title="测试17_2"></a>测试17_2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        loader.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple2"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">        <span class="comment">//修改MyCat2后，仍然删除classpath下的Simple2，留下MyCat2，程序报错</span></span><br><span class="line">        <span class="comment">//因为命名空间，父加载器找不到子加载器所加载的类，因此MyCat2找不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCat2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat by load "</span> + MyCat<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(Simple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Simple by Load "</span> + Simple<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(MyCat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>子加载器所加载的类能够访问父加载器所加载的类；</strong></li>
<li><strong>而父加载器所加载的类无法访问子加载器所加载的类</strong>。</li>
</ol>
<h3 id="测试18"><a href="#测试18" class="headerlink" title="测试18:"></a>测试18:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));<span class="comment">//根加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));<span class="comment">//扩展类加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//应用类加载器路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试19"><a href="#测试19" class="headerlink" title="测试19:"></a>测试19:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 各加载器的路径是可以修改的，修改后会导致运行失败，ClassNotFoundExeception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该类默认有扩展类加载器加载的,但是如果我们把该类默认的加载路劲修改后，就会报错</span></span><br><span class="line">        AESKeyGenerator aesKeyGenerator = <span class="keyword">new</span> AESKeyGenerator();</span><br><span class="line">        System.out.println(aesKeyGenerator.getClass().getClassLoader()); <span class="comment">//ExtClassLoader@232204a1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试20"><a href="#测试20" class="headerlink" title="测试20"></a>测试20</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader1 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load1"</span>);</span><br><span class="line">        CustomClassLoader2 loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.poplar.classload.Person"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.poplar.classload.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clazz1和clazz均由应用类加载器加载的，第二次不会重新加载，结果为true</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setPerson"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试21："><a href="#测试21：" class="headerlink" title="测试21："></a>测试21：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 1.每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类构成；</span></span><br><span class="line"><span class="comment"> * 2.在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</span></span><br><span class="line"><span class="comment"> * 3.在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</span></span><br><span class="line"><span class="comment"> * 4.同一命名空间内的类是互相可见的，非同一命名空间内的类是不可见的；</span></span><br><span class="line"><span class="comment"> * 5.子加载器可以见到父加载器加载的类，父加载器也不能见到子加载器加载的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest21</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader1 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        CustomClassLoader2 loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.poplar.classload.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.poplar.classload.MyPerson"</span>);</span><br><span class="line">        <span class="comment">//由于clazz1和clazz2分别有不同的类加载器所加载，所以他们处于不同的名称空间里</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//此处报错，loader1和loader2所处不用的命名空间</span></span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">       	 </span></span><br><span class="line"><span class="comment">       	findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        false</span></span><br><span class="line"><span class="comment">        Exception in thread "main" java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">        at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="comment">        at com.poplar.classload.ClassLoadTest21.main(ClassLoadTest21.java:25)</span></span><br><span class="line"><span class="comment">        Caused by: java.lang.ClassCastException: com.poplar.classload.MyPerson cannot be cast to com.poplar.classload.MyPerson*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyPerson person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类加载器双亲委托模型的好处：<br>（1）可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；<br>（2）确保Java核心类库中的类不会被自定义的类所替代；<br>（3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。</li>
<li>父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。</li>
</ul>
<h3 id="测试22"><a href="#测试22" class="headerlink" title="测试22:"></a>测试22:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest22</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest22 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展类加载器只加载jar包，需要把class文件打成jar</span></span><br><span class="line">    <span class="comment">//此列子中将扩展类加载的位置改成了当前的classes目录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoadTest22<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(ClassLoadTest2<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试23："><a href="#测试23：" class="headerlink" title="测试23："></a>测试23：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Launcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。</span></span><br><span class="line"><span class="comment"> * 如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。</span></span><br><span class="line"><span class="comment"> * 在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：</span></span><br><span class="line"><span class="comment"> * Error occurred during initialization of VM</span></span><br><span class="line"><span class="comment"> * java/lang/NoClassDeFoundError: java/lang/Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));<span class="comment">//根加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));<span class="comment">//扩展类加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//应用类加载器路径</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="comment">//此处由于系统和扩展类加载器都是Launcher其内部静态类，但又都是非public的，</span></span><br><span class="line">        <span class="comment">//所以不能直接获取他们的类加载器，方法就是通过获取他们的外部类加载器是谁？从而确当他们的类加载器。</span></span><br><span class="line">        System.out.println(Launcher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的系统属性指定系统类加载器，默认是AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）<br>类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。</li>
<li>内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。</li>
<li>启动类加载器并不是java类，其他的加载器都是java类。</li>
<li>启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。</li>
</ul>
<h3 id="测试24："><a href="#测试24：" class="headerlink" title="测试24："></a>测试24：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest24</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前类加载器(Current ClassLoader)</span></span><br><span class="line"><span class="comment">     * 每个类都会尝试使用自己的类加载器去加载依赖的类。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 线程上下文类加载器(Context ClassLoader)</span></span><br><span class="line"><span class="comment">     * 线程上下文加载器 @ jdk1.2</span></span><br><span class="line"><span class="comment">     * 线程类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader c)</span></span><br><span class="line"><span class="comment">     * 如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，</span></span><br><span class="line"><span class="comment">     * java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 线程上下文类加载器的作用：</span></span><br><span class="line"><span class="comment">     * SPI：Service Provide Interface</span></span><br><span class="line"><span class="comment">     * 父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，</span></span><br><span class="line"><span class="comment">     * 这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，</span></span><br><span class="line"><span class="comment">     * 有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），</span></span><br><span class="line"><span class="comment">     * Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，</span></span><br><span class="line"><span class="comment">     * 就可以由设置的上下文类加载器来实现对于接口实现类的加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><ul>
<li><strong>当前类加载器(Current ClassLoader)</strong><br>每个类都会尝试使用自己的类加载器去加载依赖的类。</li>
</ul>
<ul>
<li><p><strong>线程上下文类加载器(Context ClassLoader)</strong><br>线程上下文加载器 @ jdk1.2<br>线程类中的<code>getContextClassLoader()</code>与 <code>setContextClassLoader(ClassLoader c)</code><br>如果没有通过<code>setContextClassLoader()</code>方法设置，线程将继承父线程的上下文类加载器，<br>java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</p>
</li>
<li><p><strong>线程上下文类加载器的作用：</strong><br><strong>SPI</strong>：<code>Service Provide Interface</code><br>父<code>ClassLoader</code>可以使用当前线程<code>Thread.currentThread().getContextClassLoader()</code>所制定的<code>ClassLoader</code>加载的类，<br>这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的<code>ClassLoader</code>加载的类的情况，即改变了双亲委托模型。</p>
</li>
<li><p><strong>在双亲委托模型下</strong>，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，<br>有些接口是Java核心库所提供的的（如JDBC），Java核心库（如Connection接口）是由启动类加载器去加载的，而这些接口的实现却来自不同的jar包（<strong>默认会被添加到classes下，这样就会导致父加载器无法访问子类加载器所加载的类</strong>）（厂商提供），<br>Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，<br>就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>
</li>
</ul>
<h3 id="测试25"><a href="#测试25" class="headerlink" title="测试25:"></a>测试25:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest25</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoadTest25</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = thread.getContextClassLoader();</span><br><span class="line">        thread.setContextClassLoader(classLoader);</span><br><span class="line">        System.out.println(<span class="string">"Class: "</span> + classLoader.getClass()); <span class="comment">//Class: class sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        System.out.println(<span class="string">"Parent "</span> + classLoader.getParent()); <span class="comment">// Parent sun.misc.Launcher$ExtClassLoader@5b74b597</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ClassLoadTest25();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line">   <span class="comment">/* public Launcher() &#123;</span></span><br><span class="line"><span class="comment">        Launcher.ExtClassLoader var1;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException var10) &#123;</span></span><br><span class="line"><span class="comment">            throw new InternalError("Could not create extension class loader", var10);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            //获取到系统类加载器</span></span><br><span class="line"><span class="comment">            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException var9) &#123;</span></span><br><span class="line"><span class="comment">            throw new InternalError("Could not create application class loader", var9);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //把系统类加载器设置到当前线程的上下文类加载器中</span></span><br><span class="line"><span class="comment">        Thread.currentThread().setContextClassLoader(this.loader);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br></pre></td></tr></table></figure>
<h3 id="测试26"><a href="#测试26" class="headerlink" title="测试26"></a>测试26</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Driver;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 线程上下文类加载器的一般使用模式：（获取-使用-还原）</span></span><br><span class="line"><span class="comment"> * 伪代码：</span></span><br><span class="line"><span class="comment"> * ClassLoader classLoader=Thread.currentThread().getContextLoader();</span></span><br><span class="line"><span class="comment"> * try&#123;</span></span><br><span class="line"><span class="comment"> * Thread.currentThread().setContextLoader(targetTccl);</span></span><br><span class="line"><span class="comment"> * myMethod();</span></span><br><span class="line"><span class="comment"> * &#125;finally&#123;</span></span><br><span class="line"><span class="comment"> * Thread.currentThread().setContextLoader(classLoader);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 在myMethod中调用Thread.currentThread().getContextLoader()做某些事情</span></span><br><span class="line"><span class="comment"> * ContextClassLoader的目的就是为了破坏类加载委托机制</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在SPI接口的代码中，使用线程上下文类加载器就可以成功的加载到SPI的实现类。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，</span></span><br><span class="line"><span class="comment"> * 就必须通过上下文类加载器来帮助高层的ClassLoader找到并加载该类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。</span></span><br><span class="line">        <span class="comment">//Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServiceLoader服务提供者，加载实现的服务</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Driver driver = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver:"</span> + driver.getClass() + <span class="string">",loader"</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前上下文加载器"</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader的加载器"</span> + ServiceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试27"><a href="#测试27" class="headerlink" title="测试27"></a>测试27</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest27</span> </span>&#123;</span><br><span class="line">    <span class="comment">//源码：DriverManager.getConnection()&#123;&#125;方法中的：</span></span><br><span class="line">    <span class="comment">/* private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span></span><br><span class="line"><span class="comment">            boolean result = false;</span></span><br><span class="line"><span class="comment">            if(driver != null) &#123;</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt; aClass = null;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    //到这儿时其实已经加载过了，再次加载主要是名称空间的问题，确保是在同一名称空间下</span></span><br><span class="line"><span class="comment">                    aClass =  Class.forName(driver.getClass().getName(), true, classLoader);</span></span><br><span class="line"><span class="comment">                &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="comment">                    result = false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                result = ( aClass == driver.getClass() ) ? true : false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/user"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jar-hell问题以及解决办法"><a href="#jar-hell问题以及解决办法" class="headerlink" title="jar hell问题以及解决办法"></a>jar hell问题以及解决办法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> 当一个类或者一个资源文件存在多个jar中，就会存在jar hell问题。</span><br><span class="line"> 可通过以下代码解决问题：*/</span><br><span class="line"> ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"> String resource = &quot;java/lang/String.class&quot;;</span><br><span class="line"> Enumeration&lt;URL&gt; urls = classLoader.getResources(resource);</span><br><span class="line"> while (urls.hasMoreElements()) &#123;</span><br><span class="line">     URL element = urls.nextElement();</span><br><span class="line">     System.out.println(element);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2019/12/09/java内存模型/" class="prev">PREV</a><a href="/2019/11/17/java字节码/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>