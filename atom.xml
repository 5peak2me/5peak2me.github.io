<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J!nl!n&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daijinlin.com/"/>
  <updated>2020-01-14T06:18:36.649Z</updated>
  <id>http://daijinlin.com/</id>
  
  <author>
    <name>J!nl!n</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java内存结构</title>
    <link href="http://daijinlin.com/2019/12/10/java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://daijinlin.com/2019/12/10/java内存结构/</id>
    <published>2019-12-10T08:53:46.000Z</published>
    <updated>2020-01-14T06:18:36.649Z</updated>
    
    <content type="html"><![CDATA[<p>   <strong> 概述：</strong>张龙深入理解JVM视频Java内存结构部分学习笔记<br><a id="more"></a></p><h1 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h1><h3 id="java-JVM内部结构"><a href="#java-JVM内部结构" class="headerlink" title="java JVM内部结构"></a>java JVM内部结构</h3><p><img src="/res/jvm/jvm.png" alt="JVM Components"></p><p><img src="/res/jvm/memory.png" alt=""></p><h3 id="java对象创建过程"><a href="#java对象创建过程" class="headerlink" title="java对象创建过程"></a>java对象创建过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/11/25</span></span><br><span class="line"><span class="comment"> * 关于Java对象创建的过程:</span></span><br><span class="line"><span class="comment"> * new关键字创建对象的3个步骤:</span></span><br><span class="line"><span class="comment"> * 1.在堆内存中创建出对象的实例。</span></span><br><span class="line"><span class="comment"> * 2.为对象的实例成员变量赋初值。</span></span><br><span class="line"><span class="comment"> * 3.将对象的引用返回</span></span><br><span class="line"><span class="comment"> * 指针碰撞(前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间)</span></span><br><span class="line"><span class="comment"> * 空闲列表(前提是堆内存空间中已被使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，</span></span><br><span class="line"><span class="comment"> * 哪些空间是已被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录)</span></span><br><span class="line"><span class="comment"> * 对象在内存中的布局:</span></span><br><span class="line"><span class="comment"> * 1.对象头.</span></span><br><span class="line"><span class="comment"> * 2.实例数据(即我们在一个类中所声明的各项信息)</span></span><br><span class="line"><span class="comment"> * 3.对齐填充(可选) !</span></span><br><span class="line"><span class="comment"> * 引用访问对象的方式:</span></span><br><span class="line"><span class="comment"> * 1.使用句柄的方式。</span></span><br><span class="line"><span class="comment"> * 2.使用直接指针的方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError 设置jvm对空间最小和最大以及遇到错误时把堆存储文件打印出来</span></span><br><span class="line">        <span class="comment">//打开jvisualvm装在磁盘上的转存文件</span></span><br><span class="line">        List&lt;MemoryTest1&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> MemoryTest1());</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟机栈溢出测试"><a href="#虚拟机栈溢出测试" class="headerlink" title="虚拟机栈溢出测试"></a>虚拟机栈溢出测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/11/25</span></span><br><span class="line"><span class="comment"> * 虚拟机栈溢出测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试调整虚拟机栈内存大小为：  -Xss160k，此处除了可以使用JVisuale监控程序运行状况外还可以使用jconsole</span></span><br><span class="line">        MemoryTest2 memoryTest2 = <span class="keyword">new</span> MemoryTest2();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            memoryTest2.test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(memoryTest2.getLength());<span class="comment">//打印最终的最大栈深度为：2587</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元空间溢出测试"><a href="#元空间溢出测试" class="headerlink" title="元空间溢出测试"></a>元空间溢出测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/11/26</span></span><br><span class="line"><span class="comment"> * 元空间内存溢出测试</span></span><br><span class="line"><span class="comment"> * 设置元空间大小：-XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> * 关于元空间参考：https://www.infoq.cn/article/java-permgen-Removed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用动态代理动态生成类</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(MemoryTest3<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (obj, method, ags, proxy) -&gt; proxy.invokeSuper(obj, ags));</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">            enhancer.create();<span class="comment">// java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="JVM命令使用"><a href="#JVM命令使用" class="headerlink" title="JVM命令使用"></a>JVM命令使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/11/26</span></span><br><span class="line"><span class="comment"> * jmam命令的使用 -clstats&lt;pid&gt;进程id  to print class loader statistics</span></span><br><span class="line"><span class="comment"> * jmap -clstats 3740</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jstat -gc 3740</span></span><br><span class="line"><span class="comment"> *  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span></span><br><span class="line"><span class="comment"> * 512.0  512.0   0.0    0.0   24064.0   9626.0   86016.0     1004.1   4864.0 3758.2 512.0  409.1     144    0.064   0      0.000    0.064</span></span><br><span class="line"><span class="comment"> * MC元空间总大小，MU元空间已使用的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看java进程id jps -l</span></span><br><span class="line">    <span class="comment">// 使用jcmd查看当前进程的可用参数：jcmd 10368 help</span></span><br><span class="line">    <span class="comment">//查看jvm的启动参数 jcmd 10368 VM.flags</span></span><br><span class="line">   <span class="comment">// 10368:-XX:CICompilerCount=3 -XX:InitialHeapSize=132120576 -XX:MaxHeapSize=2111832064 -XX:MaxNewSize=703594496</span></span><br><span class="line">    <span class="comment">// -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44040192 -XX:OldSize=88080384 -XX:+UseCompressedClassPointers</span></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JVM常用命令"><a href="#JVM常用命令" class="headerlink" title="JVM常用命令"></a>JVM常用命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jcmd (从JDK <span class="number">1</span>. <span class="number">7</span>开始增加的命令)</span><br><span class="line"><span class="number">1</span>. jcmd pid VM.flags: 查看JVM的启动参数</span><br><span class="line"><span class="number">2</span>. jcmd pid help: 列出当前运行的Java进程可以执行的操作</span><br><span class="line"><span class="number">3</span>. jcmd pid helpJFR.dump:查看具体命令的选项</span><br><span class="line"><span class="number">4</span>. jcmd pid PerfCounter.print:看JVm性能相关的参数</span><br><span class="line"><span class="number">5</span>. jcmd pid VM.uptime:查有JVM的启动时长</span><br><span class="line"><span class="number">6</span>. jcmd pid GC.class_ histogram: 查看系统中类的统计信息</span><br><span class="line"><span class="number">7</span>. jcmd pid Thread.print: 查看线程堆栈信息</span><br><span class="line"><span class="number">8</span>. jcmd pid GC.heap dump filename 导出Heap dump文件， 导出的文件可以通过jvisualvm查看</span><br><span class="line"><span class="number">9</span>. jcmd pid VM.system_ properties:查看JVM的属性信息</span><br></pre></td></tr></table></figure><h3 id="JVM内存举例说明"><a href="#JVM内存举例说明" class="headerlink" title="JVM内存举例说明"></a>JVM内存举例说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*生成了2部分的内存区域，1)object这个引用变量，因为</span></span><br><span class="line"><span class="comment">     是方法内的变量，放到JVM Stack里面,2)真正Object</span></span><br><span class="line"><span class="comment">     class的实例对象，放到Heap里面</span></span><br><span class="line"><span class="comment">     上述 的new语句一共消耗12个bytes, JVM规定引用占4</span></span><br><span class="line"><span class="comment">     个bytes (在JVM Stack)， 而空对象是8个bytes(在Heap)</span></span><br><span class="line"><span class="comment">     方法结束后，对应Stack中的变量马上回收，但是Heap</span></span><br><span class="line"><span class="comment">     中的对象要等到GC来回收、*/</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="JVM垃圾识别（根搜索算法-GC-RootsTracing-）"><a href="#JVM垃圾识别（根搜索算法-GC-RootsTracing-）" class="headerlink" title="JVM垃圾识别（根搜索算法( GC RootsTracing )）"></a>JVM垃圾识别（根搜索算法( GC RootsTracing )）</h3><ul><li><p>在实际的生产语言中(Java、 C#等)，都是使用根搜索算法判定对象是否存活。</p></li><li><p>算法基本思路就是通过一系列的称为“GCRoots”的点作为起始进行向下搜索，当一个对象到GCRoots没有任何引用链( Reference Chain)相连，则证明此对象<br>是不可用的</p></li><li><p>在Java语言中，GC Roots包括<br>●在VM栈(帧中的本地变量)中的引用<br>●方法区中的静态引用<br>●JNI (即一般说的Native方法) 中的引用</p></li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>Java虛拟机规范表示可以不要求虚拟机在这区实现GC,这区GC的“性价比”一般比较低<br>在堆中，尤其是在新生代，常规应用进行I次GC一般可以回收70%~95%的空间，而方法区的GC效率远小于此</li><li><p>当前的商业JVM都有实现方法区的GC,主要回收两部分内容:废弃常量与无用类</p></li><li><p>主要回收两部分内容:废弃常量与无用类</p></li><li><p>类回收需要满足如下3个条件：</p><ul><li>该类所有的实例都已经被GC,也就是JVM中不存在该Class的任何实例</li><li>加载该类的ClassL oader已经被GC</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li></ul></li><li><p>在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义Classloader的场景都需要JVM具备类卸载的支持以保证方法区不会溢出</p></li></ul><h3 id="垃圾判断与GC算法"><a href="#垃圾判断与GC算法" class="headerlink" title="垃圾判断与GC算法"></a>垃圾判断与GC算法</h3><ul><li><p>垃圾判断的算法</p><ul><li>引用计数算法(Reference Counting)</li><li>根搜索算法( GC RootsTracing )</li><li>在实际的生产语言中(Java、 C#等)都是使用根搜索算法判定对象是否存活</li><li>算法基本思路就是通过一一系列的称为GCRoots”的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链(Reference Chain)相连，则证明此对象是不可用的</li></ul></li><li><p>在Java语言中，可作为GC Roots的对象包括下面几种： </p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。 </li><li>方法区中类静态属性引用的对象。 </li><li>方法区中常量引用的对象。 </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><p><img src="/res/jvm/gcroot.png" alt="根搜索算法(Root Tracing)"></p><ul><li>标记-清除算法(Mark Sweep)</li><li>标记-整理算法(Mark-Compact)</li><li>复制算法(Copying)</li><li>分代算法(Generational)</li></ul><h3 id="标记一清除算法-Mark-Sweep"><a href="#标记一清除算法-Mark-Sweep" class="headerlink" title="标记一清除算法(Mark-Sweep)"></a>标记一清除算法(Mark-Sweep)</h3><ul><li><p>算法分为“标记”和“清除”两个阶段，<br>首先标记出所有需要回收的对象，然后回<br>收所有需要回收的对象</p></li><li><p>缺点<br>效率问题，标记和清理两个过程效率都不高<br>空间问题，<br>标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作</p></li><li><p>效率不高，需要扫描所有对象。堆越大，GC越慢<br>存在内存碎片问题。GC次数越多，碎片越为严重</p></li></ul><p>  <img src="/res/jvm/1574823017674.gif" alt="标记一清除算法(Mark-Sweep)"></p><h3 id="复制-Copying-搜集算法"><a href="#复制-Copying-搜集算法" class="headerlink" title="复制(Copying) 搜集算法"></a>复制(Copying) 搜集算法</h3><ul><li>将可用内存划分为两块，每次只使用其中的一块，当一半区内存用完了，仅将还存活<br>的对象复制到另外一块上面，然后就把原来整块内存空间一次性清理掉，</li><li><p>这样使得每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。<font color=red>只是这种算法的代价是将内存缩小为原来的一半，代价高昂</font></p></li><li><p>现在的商业虚拟机中都是用了这一种收集算法来回收新生代</p></li><li>将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块<br>survivor, 当回收时将eden和survivor还存活的对象一次性拷 贝到另外一块survivor空间上，然后清理掉eden和用过的survivor</li><li><p>Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的</p></li><li><p>复制收集算法在对象存活率高的时候，效率有所下降</p></li><li>如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</li></ul><p><img src="/res/jvm/1574824343266.gif" alt="复制(Copying) 搜集算法"></p><ul><li>只需要扫描存活的对象，效率更高</li><li>不会产生碎片</li><li>需要浪费额外的内存作为复制区</li><li>复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小</li><li>根据IBM的专i研究，98%的Java对象只会存活1个GC周期，对这些对象很适合用复制算法。而且<br>不用1: 1的划分工作区和复制区的空间</li></ul><h3 id="标记一整理-Mark-Compact-算法"><a href="#标记一整理-Mark-Compact-算法" class="headerlink" title="标记一整理( Mark-Compact )算法"></a>标记一整理( Mark-Compact )算法</h3><ul><li><p>标记过程仍然样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。</p></li><li><p>没有内存碎片</p></li><li>比Mark-Sweep耗费更多的时间进行compact</li></ul><h3 id="分代收集。-GenerationalCollecting-算法"><a href="#分代收集。-GenerationalCollecting-算法" class="headerlink" title="分代收集。( GenerationalCollecting)算法"></a>分代收集。( GenerationalCollecting)算法</h3><ul><li>当前商业虚拟机的垃圾收集都是采用“分代收集”( Generational Collecting)算法，根据对象不同的存活周期将内存划分为几块。</li><li>一般是把Java堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，譬如新生代每次GC都有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本，就可以完成收集。</li></ul><h3 id="Hotspot-JVM-6中共划分为三个代"><a href="#Hotspot-JVM-6中共划分为三个代" class="headerlink" title="Hotspot JVM 6中共划分为三个代:"></a>Hotspot JVM 6中共划分为三个代:</h3><ul><li>年轻代(Young Generation)</li><li>老年代(Old Generation)和</li><li>永久代( Permanent Generation)</li></ul><p><img src="/res/jvm/drrrr.png" alt="Hotspot JVM 6中共划分为三个代"></p><ul><li>年轻代(Young Generation)<br>新生成的对象都放在新生代。年轻代用复制算法进行GC (理论上年轻代对象的生命周期非常短，所以适合复制算法)</li><li>年轻代分三个区。一个Eden区，两个Survivor区(可以通过参数设置Survivor个数)。对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到一个Survivor区，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。2个Survivor是完全对称，轮流替换。</li><li><p>Eden和2个Survivor的缺省比例是8:1:1，也就是10%的空间会被<br>浪费。可以根据GClog的信息调整大小的比例</p></li><li><p>老年代(Old Generation)</p><ul><li>存放了经过一次或多次GC还存活的对象</li><li>一般采用Mark-Sweep或者Mark-Compact算法进行GC </li><li>有多种垃圾收集器可以选择。每种垃圾收集器可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器(追求吞吐量?追求最短的响应时间?)</li></ul></li><li><p><del>永久代</del></p><ul><li>并不属于堆(Heap).但是GC也会涉及到这个区域</li><li>存放了每个Class的结构信息， 包括常量池、字段描述、方法描述。与垃圾收集要收集的Java对象关系不大</li></ul></li></ul><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><ul><li>堆上分配<br>大多数情况在eden上分配，偶尔会直接在old上分配细节取决于GC的实现</li><li><p>栈上分配<br>原子类型的局部变量</p></li><li><p>GC要做的是将那些dead的对象所占用的内存回收掉</p><ul><li>Hotspot认为没有引用的对象是dead的</li><li>Hotspot将引用分为四种: Strong、 Soft、Weak、Phantom<br>Strong 即默认通过Object o=new Object()这种方式赋值的引用<br>Soft、Weak、 Phantom这 三种则都是继承Reference</li></ul></li><li><p>在Full GC时会对Reference类型的引用进行特殊处理</p><ul><li>Soft:内存不够时一定会被GC、长期不用也会被GC</li><li>Weak: - 定会被GC， 当被mark为dead, 会在ReferenceQueue中通知</li><li>Phantom: 本来就没引用，当从jvm heap中释放时会通知</li></ul></li></ul><p>垃圾回收器</p><p><img src="/res/jvm/qqq.png" alt="垃圾回收器"></p><h3 id="GC回收的时机"><a href="#GC回收的时机" class="headerlink" title="GC回收的时机"></a>GC回收的时机</h3><ul><li>在分代模型的基础上，GC从时机上分为两种: Scavenge GC和Full GC <ul><li>Scavenge GC (Minor GC)<br>触发时机:新对象生成时，Eden空间满了理论上Eden区大多数对象会在ScavengeGC回收，复制算法的执<br>行效率会很高，ScavengeGC时间比较短。</li><li>Full GC<br>对整个JVM进行整理，包括Young、Old 和Perm主要的触发时机: 1) Old满了2) Perm满了3) system.gc()效率很低，尽量减少Full GC。</li></ul></li></ul><h3 id="垃圾回收器-Garbage-Collector"><a href="#垃圾回收器-Garbage-Collector" class="headerlink" title="垃圾回收器(Garbage Collector)"></a>垃圾回收器(Garbage Collector)</h3><ul><li>分代模型: GC的宏观愿景;</li><li>垃圾回收器: GC的具体实现</li><li>Hotspot JVM提供多种垃圾回收器，我们需要根据具体应用的需要采用不同的回收器</li><li>没有万能的垃圾回收器，每种垃圾回收器都有自己的适用场景</li></ul><h3 id="垃圾收集器的‘并行”和并发"><a href="#垃圾收集器的‘并行”和并发" class="headerlink" title="垃圾收集器的‘并行”和并发"></a>垃圾收集器的‘并行”和并发</h3><ul><li>并行(Parallel):指多个收集器的线程同时工作，但是用户线程处于等待状态</li><li>并发(Concurrent):指收集器在工作的同时，可以允许用户线程工作。并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候。但在清除垃圾的时候，用户线程可以和GC线程并发执行。</li></ul><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul><li>最早的收集器，单线程进行GC， New和Old Generation都可以使用，在新生代，采用复制算法;</li><li>在老年代，采用Mark-Compact算法因为是单线程GC，没有多线程切换的额外开销，简单实用<br>Hotspot Client模式默认的收集器</li></ul><p><img src="/res/jvm/serial.png" alt="Serial收集器"></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul><li>ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Seria收集器一模一样。</li><li><p>对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果</p></li><li><p>Serial收集器在新生代的多线程版本</p></li><li>使用复制算法(因为针对新生代)只有在多CPU的环境下，效率才会比Serial收集器高</li><li>可以通过-XX:ParallelGC Threads来控制GC线程数的多少。需要结合具体CPU的个数Server模式下新生代的缺省收集器</li></ul><p><img src="/res/jvm/parnew.png" alt="ParNew收集器"></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul><li>Parallel Scavenge收集器也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器有所不同，它是以吞吐量最大化(即GC时间占总运行时间最小)为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化</li></ul><h3 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS ( Concurrent Mark Sweep )收集器"></a>CMS ( Concurrent Mark Sweep )收集器</h3><ul><li>CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高(总体GC时间最小)，但它能尽可能降低GC时服务的停顿时间，CMS收集器使用的是标记一清除算法</li><li><p>特点：</p><ul><li>追求最短停顿时间，非常适合Web应用</li><li>只针对老年区，一般结合ParNew使用</li><li>Concurrent, GC线程和用户线程并发工作(尽量并发 )</li><li>Mark-Sweep</li><li>只有在多CPU环境下才有意义</li><li>使用-XX:+UseConcMarkSweepGC打开</li></ul></li><li><p>CMS收集器的缺点</p><ul><li>CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大</li><li>CMS在并发清理的过程中，用户线程还在跑。这时候需要预留一部分空间给用户线程</li><li>CMS用Mark-Sweep,会带来碎片问题。碎片过多的时候会容易频繁触发FullGC</li></ul></li></ul><p><img src="/res/jvm/cms.png" alt="CMS收集器"></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><img src="/res/jvm/G1.png" alt="G1"></p><ul><li><p>heap被划分为一个个相等的不连续的内存区域(regions) ，每个region都有一个分代的角色: eden、 survivor、 old</p></li><li><p>对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化</p></li><li><p>G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域(region)</p></li><li><p>G1使用了gc停顿可预测的模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，次清除多少个region</p></li><li><p>G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存(copying收集算法)</p></li><li><p>对比使用mark-sweep的CMS, G1使用的copying算法不会造成内存碎片;</p></li><li><p>对比Parallel Scavenge(基于copying )、Parallel Old收集器(基于mark-compact-sweep)，Parallel会对整个区域做整理导致gc停顿会比较长，而G1只是特定地整理几个region。</p></li><li><p>G1并非一个实时的收集器，与parallelScavenge-样，对gc停顿时间的设置并不绝对生效，只是G1有较高的几率保证不超过设定的gc停顿时间。与之前的gc收集器对比，G1会根据用户设定的gc停顿时间，智能评估哪几个region需要被回收可以满足用户的设定</p></li></ul><h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区(Region):"></a>分区(Region):</h3><ul><li><p>G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题一G1将 整个堆分成相同大小的分区(Region)</p></li><li><p>每个分区都可能是年轻代也可能是老年代，但是在同，时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑。</p></li><li><p>在物理，上不需要连续，则带来了额外的好处有的分区内垃圾对象特别多，有的分区内垃圾对象很少，<font color=red>G1会优先回收垃圾对象特别多的分区，</font>这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先收集垃圾最多的分区。</p></li><li><p>依然是在新生代满了的时候，对整个新生代进行回收整个新生代中的对象，要么被回收、要么晋升，至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整代的大小</p></li><li>G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。</li></ul><h3 id="收集集合-CSet"><a href="#收集集合-CSet" class="headerlink" title="收集集合(CSet)"></a>收集集合(CSet)</h3><ul><li>一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间、 或者老年代</li></ul><h3 id="已记忆集合-RSet"><a href="#已记忆集合-RSet" class="headerlink" title="已记忆集合(RSet) :"></a>已记忆集合(RSet) :</h3><ul><li><p>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构( 谁引用了我的对象)RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</p></li><li><p>Region1和Region3中的对象都引用了Region2中的对象，因此在Region2的RSet中记录了这两个引用。</p></li></ul><p><img src="/res/jvm/region.png" alt=""></p><ul><li>G1 GC是在points-out的card table之上再加了一层结构来构成points-into RSet:每个region会记录下到底哪些别的<br>region有指向自己的指针，而这些指针分别在哪些card的范围内。</li><li><p>这个RSet其实是一个hash table,key是别的region的起始地址，value是一个集合，里面的元素是card table的index.<br>举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card,它的意思就是region B的<br>一个card里 有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系;而card table仍然记录了points-out的关系。</p></li><li><p>Snapshot-AtThe-Beginning(SATB):SATB是G1 GC在并发标记阶段使用的增量式的标记算法，</p></li><li>并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区</li></ul><h3 id="参考链接：https-www-oracle-com-technetwork-tutorials-tutorials-1876574-html"><a href="#参考链接：https-www-oracle-com-technetwork-tutorials-tutorials-1876574-html" class="headerlink" title="参考链接：https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html"></a>参考链接：<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></h3><h3 id="G1相对于CMS的优势"><a href="#G1相对于CMS的优势" class="headerlink" title="G1相对于CMS的优势"></a>G1相对于CMS的优势</h3><ul><li>G1在压缩空间方面有优势</li><li>G1通过将内存空间分成区域(Region) 的方式避免内存碎片问题Eden、Survivor、 Old区不再固定，在内存使用效率上来说更灵活</li><li>G1可以通过设置预期停顿时间( Pause Time) 来控制垃圾收集时间，避免应用雪崩现象</li><li>G1在回收内存后会马上同时做合并空闲内存的工作，而CMS默认是在STW ( stop the world) 的时候做</li><li>G1会在Young GC中使用，而CMS只能在Old区使用</li></ul><h3 id="G1的适合场景"><a href="#G1的适合场景" class="headerlink" title="G1的适合场景"></a>G1的适合场景</h3><ul><li>服务端多核CPU、JVM内存占用较大的应用</li><li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li><li>想要更可控、可预期的GC停顿周期:防止高并发下应用的雪崩现象</li></ul><h3 id="G1-GC模式"><a href="#G1-GC模式" class="headerlink" title="G1 GC模式"></a>G1 GC模式</h3><ul><li>G1提供了两种GC模式，Young GC和Mixed GC, 两种都是完全Stop The World的</li><li>Young GC:选定所有年轻代里的Region。通过控制年轻代的Region个数，即年轻代内存大小，来控制Young GC的时间开销。</li><li><p>Mixed GC:选定所有年轻代里的Region,外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region</p></li><li><p>Mixed GC不是Full GC,它只能回收部分老年代的Region,如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行MixedGC，就会使用serialold GC (Full GC)来收集整个GC heap。<font color=red> 所以本质上，G1是不提供Full GC的</font></p></li></ul><h3 id="global-concurrent-marking"><a href="#global-concurrent-marking" class="headerlink" title="global concurrent marking"></a>global concurrent marking</h3><ul><li><strong>初始标记( initial mark, STW)</strong> :它标记了从GCRoot开始直接可达的对象。</li><li><strong>并发标记( Concurrent Marking)</strong> :这个阶段从GC Root开始对heap中的对象进行标记，标记线<br>程与应用程序线程并发执行，并且收集各个Region的存活对象信息。</li><li><strong>重新标记( Remark, STW)</strong> :标记那些在并发标记阶段发生变化的对象，将被回收。</li><li><p><strong>清理(Cleanup)</strong> :清除空Region (没有存活对象的)，加入到free list。</p></li><li><p>第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用rootscan操作，所以可以说global concurrent marking是伴随Young GC而发生的</p></li><li>第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</li></ul><h3 id="G1在运行过程中的主要模式"><a href="#G1在运行过程中的主要模式" class="headerlink" title="G1在运行过程中的主要模式"></a>G1在运行过程中的主要模式</h3><ul><li>YGC(不同于CMS)<ul><li>G1 YGC在Eden充满时触发，在回收之后所有之前属于Eden的区块全部变成空白，即不属于任何一个分区( Eden、Survivor、Old )</li><li><font color=red>YGC执行步骤：</font><ul><li>阶段1:根扫描<br>静态和本地对象被描</li><li>阶段2:更新RS<br>处理dirty card队列更新RS</li><li>阶段3:处理RS<br>检测从年轻代指向老年代的对象</li><li>阶段4:对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5:处理引用队列<br>软引用，弱引用，虚引用处理</li></ul></li></ul></li><li>并发阶段（global concurrent marking）</li><li>混合模式</li><li>Full GC (一 般是G1出现问题时发生，本质上不属于G1，G1进行的回退策略（回退为：Serial Old GC）)</li></ul><h3 id="什么时候发生MixedGC"><a href="#什么时候发生MixedGC" class="headerlink" title="什么时候发生MixedGC?"></a>什么时候发生MixedGC?</h3><ul><li>由一些参数控制，另外也控制着哪些老年代Region会被选入CSet (收集集合)<ul><li><strong>G1HeapWastePercent</strong>:在globalconcurrent marking结束之后，我们可以知道oldgenregions中有多少空间要被回收，在每次YGC之后和再次发生MixedGC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才 会发生Mixed GC</li><li><strong>G1MixedGCLiveThresholdPercent</strong>: oldgeneration region中的存活对象的占比，只有在此参数之下，才会被选入CSet</li><li><strong>G1MixedGCCountTarget</strong>:一 次globalconcurrent marking之后，最多执行Mixed GC的次数</li><li><strong>G1OldCSetRegionThresholdPercent</strong>:次Mixed GC中能被选入CSet的最多old generation region数量</li></ul></li></ul><h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性</p><ul><li>我们将对象分成三种类型:<ul><li><strong>黑色</strong>:根对象，或者该对象与它的子对象都被扫描过(对象被标记了，且它的所有field也被标记完了)</li><li><strong>灰色</strong>:对象本身被扫描,但还没扫描完该对象中的子对象( 它的field还没有被标记或标记完)</li><li><strong>白色</strong>:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象(对象没有被标记到)</li></ul></li></ul><h4 id="提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性"><a href="#提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性" class="headerlink" title="提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性"></a>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性</h4><p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理,如图：</p><p><img src="/res/jvm/sanmark.gif" alt="三色标记算法"></p><ul><li>但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题:对象丢失问题</li></ul><p><img src="/res/jvm/sans3.png" alt=""></p><p>  这时候应用程序执行了以下操作:<br>  A.c=C<br>  B.c=null<br>  这样，对象的状态图变成如下情形:</p><p>  <img src="/res/jvm/sans2.png" alt=""></p><p>这时候垃圾收集器再标记扫描的时候就会变成下图这样</p><p><img src="/res/jvm/sans1.png" alt=""></p><ul><li><strong>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的</strong></li></ul><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><ul><li>在G1中，使用的是SATB ( Snapshot-At-The- Beginning)的方式，删除的时候记录所有的对象</li><li>它有3个步骤<ul><li>在开始标记的时候生成一个快照图，标记存活对象</li><li>在并发标记的时候所有被改变的对象入队(在writebarrier里把所有旧的引用所指向的对象都变成非白的)</li><li>可能存在浮动垃圾，将在下次被收集</li></ul></li></ul><h3 id="G1混合式回收"><a href="#G1混合式回收" class="headerlink" title="G1混合式回收"></a>G1混合式回收</h3><ul><li>G1到现在可以知道哪些老的分区可回收垃圾最多。当全局并发标记完成后，在某个时刻，就开始了Mixed GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区混合式GC也是采用的复制清理策略，当GC完成后，会重新释放空间</li></ul><h3 id="SATB详解"><a href="#SATB详解" class="headerlink" title="SATB详解"></a>SATB详解</h3><ul><li>SATB是维持并发GC的一种手段。G1并发的基础就是SATB。SATB可以理解成在GC开始之前对堆内存里的对象做次快照，此时活的对象就认为是活的，从而形成了一个对象图。</li><li>在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象都认为是垃圾对象</li></ul><h3 id="如何找到在GC过程中分配的对象呢"><a href="#如何找到在GC过程中分配的对象呢" class="headerlink" title="如何找到在GC过程中分配的对象呢?"></a>如何找到在GC过程中分配的对象呢?</h3><ul><li>每个region记录着两个top-at-mark-start ( TAMS 指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。</li><li><p>通过这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象。</p></li><li><p>解决了对象在GC过程中分配的问题，那么在GC过程中引用发生变化的问题怎么解决呢?</p></li><li>G1给出的解决办法是通过WriteBarrier.Write Barrier就是对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到哪些引用对象发生了什么样的变化</li></ul><h3 id="mark的过程就是遍历heap标记live-object的过程，"><a href="#mark的过程就是遍历heap标记live-object的过程，" class="headerlink" title="mark的过程就是遍历heap标记live object的过程，"></a>mark的过程就是遍历heap标记live object的过程，</h3><ul><li>采用的是三色标记算法，这三种颜色为white(表示还未访问到)、gray(访问到但是它用到的引用还没有完全扫描、black( 访问到而且其用到的引用已经完全扫描完)</li><li><p>整个三色标记算法就是从GCroots出发遍历heap,针对可达对象先标记white为gray,然后再标记gray为black;遍历完成之后所有可达对象都是black的，所有white都是可以回收的</p></li><li><p>SATB仅仅对于在marking开始阶段进行”snapshot”(marked all reachable at markstart)，但是concurrent的时候并发修改可能造成对象漏标记</p></li><li>对black新引用了一个white对象，然后又从gray对象中删除了对该white对象的引用，这样会造成了该white对象漏标记</li><li>对black新引用了一个white对象，然后从gray对象删了一个引用该white对象的white对象，这样也会造成了该white对象漏标记，</li><li><p>对black新引用了一个刚new出来的white对象，没有其他gray对象引用该white对象，这样也会造成了该white对象漏标记</p></li><li><p>对于三色算法在concurrent的时候可能产生的漏标记问题，SATB在marking阶段中，对于从gray对象移除的目标引用对象标记为gray,对于black引用的新产生的对象标记为black;由于是在开始的时候进行snapshot,因而可能存在Floating Garbage</p></li></ul><h3 id="漏标与误标"><a href="#漏标与误标" class="headerlink" title="漏标与误标"></a>漏标与误标</h3><ul><li><p>误标没什么关系，顶多造成浮动垃圾，在下次gc还是可以回收的，但是漏标的后果是致命的，把本应该存活的对象给回收了，从而影响的程序的正确性</p></li><li><p>漏标的情况只会发生在白色对象中，且满足以下任意一个条件</p><ul><li><p>并发标记时，应用线程给一个黑色对象的引用类型字段赋值 了该白色对象</p></li><li><p>并发标记时，应用线程删除所有灰色对象到该白色对象的引用</p></li></ul></li><li><p>对于第一种情况，利用post-write barrier,记录所有新增的引用关系，然后根据这些引用关系为根重新扫描一-遍</p></li><li>对于第二种情况，利用pre-write barrier,将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根重新扫描一遍</li></ul><h3 id="停顿预测模型"><a href="#停顿预测模型" class="headerlink" title="停顿预测模型"></a>停顿预测模型</h3><ul><li>G1收集器突出表现出来的一点是通过一个停顿预测模型根据用户配置的停顿时间来选择CSet的大小，从而达到用户期待的应用程序暂停时间。</li><li><p>通过-XX:MaxGCPauseMillis参数来设置。这一点有点类似于ParallelScavenge收集器。 关于停顿时间的设置并不是越短越好。</p></li><li><p>设置的时间越短意味着每次收集的CSet越小，导致垃圾逐步积累变多，最终不得不退化成SerialGC;停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间</p></li></ul><h3 id="G1的收集模式"><a href="#G1的收集模式" class="headerlink" title="G1的收集模式"></a>G1的收集模式</h3><ul><li>G1的运行过程是这样的:会在Young GC和Mixed GC之间不断地切换运行，同时定期地做全局并发标记，在实在赶不上对象创建速度的情况下 使用Full GC(Serial GC)。</li><li>初始标记是在Young GC.上执行的，在进行全局并发标记的时候不会做MixedGC,在做MixedGC的时候也不会启动初始标记阶段。</li><li>当MixedGC赶不上对象产生的速度的时候就退化成FullGC，这一点是需要重点调优的地方</li></ul><h3 id="G1最佳实践"><a href="#G1最佳实践" class="headerlink" title="G1最佳实践"></a>G1最佳实践</h3><ul><li>不要设置新生代和老年代的大小，G1收集器在运行的时候会调整新生代和老年代<br>的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。</li><li><p>设置了新生代大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自已去分配各个代的大小即可。</p></li><li><p>不断调优暂停时间指标</p><ul><li>通过-XX:MaxGCPauseMillis=x可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选择CSet来满足响应时间的设置。一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出 现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</li></ul></li><li><p>关注Evacuation Failure</p><ul><li>Evacuation（表示copy） Failure类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集</li></ul></li></ul><h3 id="G1日志解析"><a href="#G1日志解析" class="headerlink" title="G1日志解析:"></a>G1日志解析:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/11/30</span></span><br><span class="line"><span class="comment"> * G1日志分析</span></span><br><span class="line"><span class="comment"> * 虚拟机相关参数：</span></span><br><span class="line"><span class="comment"> * -verbose:gc</span></span><br><span class="line"><span class="comment"> * -Xms10m</span></span><br><span class="line"><span class="comment"> * -Xmx10m</span></span><br><span class="line"><span class="comment"> * -XX:+UseG1GC 表示垃圾收集器使用G1</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDateStamps</span></span><br><span class="line"><span class="comment"> * -XX:MaxGCPauseMillis=200m 设置垃圾收集最大停顿时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G1LogAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">byte</span>[] bytes4 = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC日志：</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.663+0800: [GC pause (G1 Humongous Allocation【说明分配的对象超过了region大小的50%】) (young) (initial-mark), 0.0014516 secs]</span></span><br><span class="line"><span class="comment"> * [Parallel Time: 1.1 ms, GC Workers: 4【GC工作线程数】]</span></span><br><span class="line"><span class="comment"> * [GC Worker Start (ms): Min: 167.0, Avg: 167.1, Max: 167.1, Diff: 0.1]【几个垃圾收集工作的相关信息统计】</span></span><br><span class="line"><span class="comment"> * [Ext Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.1, Sum: 1.6]</span></span><br><span class="line"><span class="comment"> * [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment"> * [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span></span><br><span class="line"><span class="comment"> * [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment"> * [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment"> * [Object Copy (ms): Min: 0.6, Avg: 0.6, Max: 0.6, Diff: 0.0, Sum: 2.4]</span></span><br><span class="line"><span class="comment"> * [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment"> * [Termination Attempts: Min: 1, Avg: 1.3, Max: 2, Diff: 1, Sum: 5]</span></span><br><span class="line"><span class="comment"> * 【上面的几个步骤为YOUNG GC的固定执行步骤】</span></span><br><span class="line"><span class="comment"> * 阶段1:根扫描</span></span><br><span class="line"><span class="comment"> * 静态和本地对象被描</span></span><br><span class="line"><span class="comment"> * 阶段2:更新RS</span></span><br><span class="line"><span class="comment"> * 处理dirty card队列更新RS</span></span><br><span class="line"><span class="comment"> * 阶段3:处理RS</span></span><br><span class="line"><span class="comment"> * 检测从年轻代指向老年代的对象</span></span><br><span class="line"><span class="comment"> * 阶段4:对象拷贝</span></span><br><span class="line"><span class="comment"> * 拷贝存活的对象到survivor/old区域</span></span><br><span class="line"><span class="comment"> * 阶段5:处理引用队列</span></span><br><span class="line"><span class="comment"> * 软引用，弱引用，虚引用处理</span></span><br><span class="line"><span class="comment"> * [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]</span></span><br><span class="line"><span class="comment"> * [GC Worker Total (ms): Min: 1.0, Avg: 1.1, Max: 1.1, Diff: 0.1, Sum: 4.2]</span></span><br><span class="line"><span class="comment"> * [GC Worker End (ms): Min: 168.1, Avg: 168.1, Max: 168.1, Diff: 0.0]</span></span><br><span class="line"><span class="comment"> * [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Clear CT: 0.1 ms]【清楚cardTable所花费时间】</span></span><br><span class="line"><span class="comment"> * [Other: 0.3 ms]</span></span><br><span class="line"><span class="comment"> * [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Ref Proc: 0.1 ms]</span></span><br><span class="line"><span class="comment"> * [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Redirty Cards: 0.1 ms]</span></span><br><span class="line"><span class="comment"> * [Humongous Register: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Humongous Reclaim: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Free CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment"> * [Eden: 2048.0K(4096.0K)-&gt;0.0B【新生代清理后】(2048.0K) Survivors: 0.0B-&gt;1024.0K Heap: 3800.2K(10.0M)-&gt;2752.1K(10.0M)]</span></span><br><span class="line"><span class="comment"> * [Times: user=0.00 sys=0.00, real=0.01 secs]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.671+0800: [GC concurrent-root-region-scan-start]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.671+0800: [GC concurrent-root-region-scan-end, 0.0008592 secs]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.671+0800: [GC concurrent-mark-start]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.672+0800: [GC concurrent-mark-end, 0.0000795 secs]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.672+0800: [GC remark 2019-11-30T16:13:41.672+0800: [Finalize Marking, 0.0001170 secs] 2019-11-30T16:13:41.672+0800: [GC ref-proc, 0.0002159 secs] 2019-11-30T16:13:41.672+0800: [Unloading, 0.0005800 secs], 0.0011024 secs]</span></span><br><span class="line"><span class="comment"> * [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment"> * 2019-11-30T16:13:41.673+0800: [GC cleanup 4800K-&gt;4800K(10M), 0.0003239 secs]</span></span><br><span class="line"><span class="comment"> * [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment"> * hello world</span></span><br><span class="line"><span class="comment"> * Heap</span></span><br><span class="line"><span class="comment"> * garbage-first heap   total 10240K, used 4800K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000)</span></span><br><span class="line"><span class="comment"> * region size 1024K【说明region默认大小】, 2 young (2048K), 1 survivors (1024K)</span></span><br><span class="line"><span class="comment"> * Metaspace       used 3224K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment"> * class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;strong&gt; 概述：&lt;/strong&gt;张龙深入理解JVM视频Java内存结构部分学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://daijinlin.com/categories/Markdown/"/>
    
    
      <category term="Markdown UML" scheme="http://daijinlin.com/tags/Markdown-UML/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://daijinlin.com/2019/12/09/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://daijinlin.com/2019/12/09/java内存模型/</id>
    <published>2019-12-09T08:53:46.000Z</published>
    <updated>2020-01-14T10:39:39.747Z</updated>
    
    <content type="html"><![CDATA[<p>   <strong> 概述：</strong>张龙深入理解JVM视频Java内存模型部分学习笔记<br><a id="more"></a></p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h3 id="计算机物理内存模型"><a href="#计算机物理内存模型" class="headerlink" title="计算机物理内存模型"></a>计算机物理内存模型</h3><p><img src="/res/jmm/compute_jmm.png" alt="计算机物理内存模型"></p><h3 id="java-JMM"><a href="#java-JMM" class="headerlink" title="java JMM"></a>java JMM</h3><p><img src="/res/jmm/java_jmm.png" alt="java JMM"></p><ul><li>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与 介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部 分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类 比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。</li><li>线程对变量的 所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主 内存来完成</li></ul><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><ul><li>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内 存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来 完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的<ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 </li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放 后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内 存中，以便随后的load动作使用。 </li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工 作内存的变量副本中。 </li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引 擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内 存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存 中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入 主内存的变量中</li></ul></li></ul><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><ul><li><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，</p><ul><li><p>是保证此变量对所有线程的可 见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以 立即得知的</p><ul><li><p>是Java里面的运算并非 原子操作，导致volatile变量的运算在并发下一样是不安全的</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/7</span></span><br><span class="line"><span class="comment"> * volatile在并发环境下并非原子操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    race++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待所有累加线程都结束,如果还有线程在运行，主线程就让出cpu资源</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;<span class="comment">//由于idea原因此处不能为一</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(race);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public static void increase();</span></span><br><span class="line"><span class="comment">descriptor: ()V</span></span><br><span class="line"><span class="comment">flags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line"><span class="comment">Code:</span></span><br><span class="line"><span class="comment">  stack=2, locals=0, args_size=0</span></span><br><span class="line"><span class="comment">     0: getstatic     #2                  // Field race:I</span></span><br><span class="line"><span class="comment">     3: iconst_1</span></span><br><span class="line"><span class="comment">     4: iadd</span></span><br><span class="line"><span class="comment">     5: putstatic     #2                  // Field race:I</span></span><br><span class="line"><span class="comment">     8: return</span></span><br><span class="line"><span class="comment">     当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此 时是正确的，但是在执行iconst_1、iadd这些指令的时候，</span></span><br><span class="line"><span class="comment">     其他线程可能已经把race的值加大 了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值 同步回主内存之中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>禁止指令重排序优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/8</span></span><br><span class="line"><span class="comment"> * volatile静止指令重排序演示代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instance = new Singleton();</span></span><br><span class="line"><span class="comment">这段代码可以分为如下的三个步骤：</span></span><br><span class="line"><span class="comment">memory = allocate();  // 1：分配对象的内存空间</span></span><br><span class="line"><span class="comment">ctorInstance(memory); // 2：初始化对象</span></span><br><span class="line"><span class="comment">instance = memory;    // 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">我们知道，编辑器和处理器会进行代码优化，而其中重要的一点是会将指令进行重排序。</span></span><br><span class="line"><span class="comment">上边的代码经过重排序后可能会变为：</span></span><br><span class="line"><span class="comment">memory = allocate();  // 1：分配对象的内存空间</span></span><br><span class="line"><span class="comment">instance = memory;    // 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">  // 注意：此时对象尚未初始化</span></span><br><span class="line"><span class="comment">ctorInstance(memory); // 2：初始化对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码对应的汇编的执行过程</span></span><br><span class="line"><span class="comment">* 0x01a3de0f：mov$0x3375cdb0，%esi;……beb0cd75 33</span></span><br><span class="line"><span class="comment">;&#123;oop（'Singleton'）&#125;</span></span><br><span class="line"><span class="comment">0x01a3de14：mov%eax，0x150（%esi）;……89865001 0000</span></span><br><span class="line"><span class="comment">0x01a3de1a：shr$0x9，%esi;……c1ee09</span></span><br><span class="line"><span class="comment">0x01a3de1d：movb$0x0，0x1104800（%esi）;……c6860048 100100</span></span><br><span class="line"><span class="comment">0x01a3de24：lockaddl$0x0，（%esp）;……f0830424 00</span></span><br><span class="line"><span class="comment">;*put static instance</span></span><br><span class="line"><span class="comment">;-</span></span><br><span class="line"><span class="comment">Singleton：getInstance@24</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">生成汇编码是lock addl $0x0, (%rsp), 在写操作（put static instance）之前使用了lock前缀，锁住了总线和对应的地址，这样其他的CPU写和读都要等待锁的释放。</span></span><br><span class="line"><span class="comment">当写完成后，释放锁，把缓存刷新到主内存。</span></span><br><span class="line"><span class="comment">加了 volatile之后，volatile在最后加了lock前缀，把前面的步骤锁住了，这样如果你前面的步骤没做完是无法执行最后一步刷新到内存的，</span></span><br><span class="line"><span class="comment">换句话说只要执行到最后一步lock，必定前面的操作都完成了。那么即使我们完成前面两步或者三步了，还没执行最后一步lock，或者前面一步执行了就切换线程2了，</span></span><br><span class="line"><span class="comment">线程B在判断的时候也会判断实例为空，进而继续进来由线程B完成后面的所有操作。当写完成后，释放锁，把缓存刷新到主内存。</span></span><br><span class="line"><span class="comment">————————————————</span></span><br><span class="line"><span class="comment">版权声明：本文为CSDN博主「夏洛克卷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="comment">原文链接：https://blog.csdn.net/zx48822821/article/details/86589753</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Java与Thread"><a href="#Java与Thread" class="headerlink" title="Java与Thread"></a>Java与Thread</h3><ul><li><p>线程的实现 </p><ul><li><p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻 量级进程混合实现。</p></li><li><p><strong>内核线程</strong>（Kernel-Level Thread,KLT）</p></li></ul><p><img src="/res/jmm/kernel_thread.png" alt="内核线程"></p><ul><li><strong>用户线程</strong>（User Thread,UT）使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有 的线程操作都需要用户程序自己处理</li></ul><p><img src="/res/jmm/user_thread.png" alt="用户线程"></p><ul><li><strong>使用用户线程加轻量级进程混合实现</strong> </li></ul><p><img src="/res/jmm/mix_thread.png" alt="用户线程"></p></li><li><p><strong>Java线程的实现</strong> </p><ul><li>在目前的JDK版 本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射 的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪 种线程模型来实现。</li></ul></li><li><p><strong>Java线程调度</strong></p></li><li>线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种，分别是协同 式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive ThreadsScheduling）。 </li><li>协同 式线程调度，线程的执行时间由线程本身来控制，线程把自己的 工作执行完了之后，要主动通知系统切换到另外一个线程上。</li><li><p>使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切 换不由线程本身来决定</p></li><li><p>Java使用的线程调度方式就是抢 占式调度</p></li><li><p><strong>线程状态转换</strong></p></li></ul><p><img src="/res/jmm/thread_status.png" alt="用户线程"></p><h3 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h3><ul><li><p>为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元 排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们[1]可以将Java语言中各种 操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对 立</p></li><li><p><strong>不可变 （Immutable）</strong>的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需 要再采取任何的线程安全保障措施</p></li><li><p>在Java API中标注自己是线程安全的类，大多数 都不是<strong>绝对的线程安全</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/8</span></span><br><span class="line"><span class="comment"> * 对vector线程安全的测试,通过对源码debug测试发现会出现 ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> * 尽管这里使用到的Vector的get（）、remove（）和size（）方法都是同步的， 但是在多线程的环境中，</span></span><br><span class="line"><span class="comment"> * 如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是 不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，</span></span><br><span class="line"><span class="comment"> * 导致序号i已经不再 可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    System.out.println(vector.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">90</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码改进</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/8</span></span><br><span class="line"><span class="comment"> * 改进后debug源码未发现异常情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTestImprove</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println(vector.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">90</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>相对线程安全</strong> </li><li><p>相对的线程安全就是我们通常意义上所讲的线程安全，在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、 Collections的synchronizedCollection（）方法包装的集合等</p></li><li><p><strong>线程兼容</strong></p></li><li><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段 来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时 候指的是这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和 HashTable相对应的集合类ArrayList和HashMap等。 </p></li><li><p><strong>线程对立</strong> </p></li><li>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代 码。</li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li><strong>互斥同步</strong>（Mutual Exclusion＆Synchronization）是常见的一种并发正确性保障手段。同步 是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些， 使用信号量的时候）线程使用。</li><li><p>从处理问题的方式上说，互斥同步属于一种悲观的 并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论 共享数据是否真的会出现竞争，它都要进行加锁</p></li><li><p>在Java中，最基本的互斥同步手段就是synchronized关键字，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁 （ReentrantLock）来实现同步</p></li><li><p><strong>非阻塞同步</strong> </p></li><li><p>随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的 乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成 功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施 就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起， 因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 </p></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p><strong>自旋锁与自适应自旋</strong> </p></li><li><p>互斥同步对性能最大的影响是阻塞的实现，挂起 线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的 压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短 的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理 器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一 下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等 待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁，</p></li><li><p>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的， 因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间 很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性 能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然 没有成功获得锁，就应当使用传统的方式去挂起线程了</p></li><li><p>自适应意味着自旋的时间不再固定了，而是由前 一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</p></li></ul><h3 id="关于锁推荐相关参考链接：https-www-cnblogs-com-jyroy-p-11365935-html"><a href="#关于锁推荐相关参考链接：https-www-cnblogs-com-jyroy-p-11365935-html" class="headerlink" title="关于锁推荐相关参考链接：https://www.cnblogs.com/jyroy/p/11365935.html"></a>关于锁推荐相关参考链接：<a href="https://www.cnblogs.com/jyroy/p/11365935.html">https://www.cnblogs.com/jyroy/p/11365935.html</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;strong&gt; 概述：&lt;/strong&gt;张龙深入理解JVM视频Java内存模型部分学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://daijinlin.com/categories/Markdown/"/>
    
    
      <category term="Markdown UML" scheme="http://daijinlin.com/tags/Markdown-UML/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载器学习</title>
    <link href="http://daijinlin.com/2019/11/24/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://daijinlin.com/2019/11/24/JVM类加载器学习/</id>
    <published>2019-11-24T08:53:46.000Z</published>
    <updated>2020-01-14T06:17:50.542Z</updated>
    
    <content type="html"><![CDATA[<p>   <strong> 概述：</strong>张龙深入理解JVM视频JVM类加载器部分学习笔记<br><a id="more"></a></p><h1 id="JVM类加载器学习"><a href="#JVM类加载器学习" class="headerlink" title="JVM类加载器学习"></a>JVM类加载器学习</h1><h3 id="在以下几种情况下："><a href="#在以下几种情况下：" class="headerlink" title="在以下几种情况下："></a>在以下几种情况下：</h3><ul><li>执行了System。exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或者错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h3 id="类的加载执行与初始化"><a href="#类的加载执行与初始化" class="headerlink" title="类的加载执行与初始化"></a>类的加载执行与初始化</h3><ul><li>加载：查找并加载类的二进制数据</li><li><p>链接</p><ul><li>验证：确保被加载的类的正确性</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转换为直接引用</li></ul></li><li><p>初始化：为类的静态变量赋予正确的初始值</p></li><li><p>值得注意的是：准备阶段即使我们为静态变量赋值为任意的数值，但是该静态变量还是会被初始化为他的默认值，最后的初始化时才会把我们赋予的值设为该静态变量的值。</p></li></ul><h3 id="Java程序对类的使用可以分为两种"><a href="#Java程序对类的使用可以分为两种" class="headerlink" title="Java程序对类的使用可以分为两种"></a>Java程序对类的使用可以分为两种</h3><ol><li>主动使用<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用该类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标为启动类的类（Java Test）</li></ul></li><li>被动使用</li><li>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们</li></ol><hr><ul><li><p>类的加载:指的是将类的。class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个<code>Java.lang.Class</code>对象（规范并没有说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构</p></li><li><p>加载类的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将java源文件动态编译为.class文件（将JAVA源文件动态编译这种情况会在动态代理和web开发中jsp转换成Servlet）</li></ul></li></ul><h3 id="完整加载过程"><a href="#完整加载过程" class="headerlink" title="完整加载过程"></a>完整加载过程</h3><p>加载<br>连接（验证、准备、解析）<br>初始化<br>类的是例化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值</p><p>java编译器在它编译的每一个类都至少生成一个实例化的方法，在java的class文件中，这个实例化方法被称为<init>。针对源代码中每一个类的构造方法，java编译器都会产生一个“<init>”方法。</p><p><img src="/res/classloader/classload.png" alt="完整加载过程"></p><p><strong>时序图</strong></p><p><img src="/res/classloader/classload2.png" alt="时序图"></p><h3 id="有两种类型的类加载器"><a href="#有两种类型的类加载器" class="headerlink" title="有两种类型的类加载器"></a>有两种类型的类加载器</h3><ol><li><strong>Java虚拟机自带的加载器</strong></li></ol><ul><li><strong>根类加载器</strong>（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。</li><li><strong>扩展类加载器</strong>（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。</li><li><strong>系统应用类加载器</strong>（AppClassLoader/System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。</li></ul><ol><li><strong>用户自定义的类加载器</strong></li></ol><ul><li>java.lang.ClassLoader的子类</li><li>用户可以定制类的加载方式</li></ul><p>根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器<br>类加载器并不需要等到某个类被“首次主动使用”时再加载它</p><p><img src="/res/classloader/Snipaste_2019-11-07_14-51-04.png" alt="类加载顺序"></p><p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在<strong>程序首次主动</strong>使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。</p><p>类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p><p>类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p><ul><li>类的连接-验证<br>1）类文件的结构检查<br>2）语义检查<br>3）字节码验证<br>4）二进制兼容性的验证</li><li>类的连接-准备<br>在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong><br>在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。<br><strong>类的初始化步骤</strong>：<br>（1）假如这个类还没有被加载和连接，那就先进行加载和连接<br>（2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类<br>（3）假如类中存在初始化语句，那就依次执行这些初始化语句<br>当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，<strong>但是这条规则不适用于接口</strong>。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> * Created By poplar on 2019/11/7</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 当一个接口在初始化时，并不要求其父接口都完成了初始化</span><br><span class="line"> * 只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line">public class ClassLoadTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild.b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Student5 &#123;</span><br><span class="line"></span><br><span class="line">    int a = 9; //前面省了public static final</span><br><span class="line"></span><br><span class="line">    Thread thread = new Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;thread 初始化了&quot;);//如果父接口初始化了这句应该输出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyChild extends Student5 &#123;     //接口属性默认是 public static final</span><br><span class="line">    String b = LocalDateTime.now().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取类加载起的方法</li></ul><p><img src="/res/classloader/vb.png" alt=""></p><p>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><h3 id="类加载器的-双亲委派机制-父亲委托机制"><a href="#类加载器的-双亲委派机制-父亲委托机制" class="headerlink" title="类加载器的(双亲委派机制)父亲委托机制"></a>类加载器的(双亲委派机制)父亲委托机制</h3><p>在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器</p><ul><li>若有一个类能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</li></ul><p><img src="/res/classloader/loadmethod.png" alt="类加载器的(双亲委派机制)父亲委托机制"></p><h3 id="类加载器测试7"><a href="#类加载器测试7" class="headerlink" title="类加载器测试7"></a>类加载器测试7</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;<span class="comment">//null 由于String是由根加载器加载，在rt.jar包下</span></span><br><span class="line">        System.out.println(C<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;<span class="comment">//sun.misc.Launcher$AppClassLoader@73d16e93</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试9："><a href="#测试9：" class="headerlink" title="测试9："></a>测试9：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest9"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child1.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输出顺序</span></span><br><span class="line"><span class="comment">//ClassLoadTest9</span></span><br><span class="line"><span class="comment">// Parent1</span></span><br><span class="line"><span class="comment">//9</span></span><br></pre></td></tr></table></figure><h3 id="测试10"><a href="#测试10" class="headerlink" title="测试10:"></a>测试10:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest10"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent2 parent2;</span><br><span class="line">        parent2 = <span class="keyword">new</span> Parent2();</span><br><span class="line">        System.out.println(Parent2.a);</span><br><span class="line">        System.out.println(Child2.b);</span><br><span class="line">        <span class="comment">/*执行结果：由于父类已经初始化过了所以Parent2只输出一次</span></span><br><span class="line"><span class="comment">         * ClassLoadTest10</span></span><br><span class="line"><span class="comment">         * Parent2</span></span><br><span class="line"><span class="comment">         * 2</span></span><br><span class="line"><span class="comment">         * Child2</span></span><br><span class="line"><span class="comment">         * 3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试12："><a href="#测试12：" class="headerlink" title="测试12："></a>测试12：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 调用类的loadClass并不是主使实用类，不会导致类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; loadClass = classLoader.loadClass(<span class="string">"com.poplar.classload.G"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.poplar.classload.G"</span>);<span class="comment">//反射会导致一个类的初始化</span></span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">        <span class="comment">//输出结果：</span></span><br><span class="line">        <span class="comment">//G</span></span><br><span class="line">        <span class="comment">//class com.poplar.classload.G</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123; <span class="number">1</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"G"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试16"><a href="#测试16" class="headerlink" title="测试16:"></a>测试16:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePost = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//显示指定该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将系统类加载器当作该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"findClass,输出这句话说明我们自己的类加载器加载了指定的类"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = name.replace(<span class="string">"."</span>, File.separator);<span class="comment">//File.separator根据操作系统而变化</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name + filePost));</span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read())) &#123;</span><br><span class="line">                byteArrayOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = byteArrayOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.poplar.classload.ClassLoadTest"</span>);</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"load1"</span>);</span><br><span class="line">        test(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个列子中最后的类加载器是系统类加载器，而非我们自己的类加载器，是因为我们要加载的类刚好在系统类加载器的加载范围</span></span><br></pre></td></tr></table></figure><h3 id="测试16改进："><a href="#测试16改进：" class="headerlink" title="测试16改进："></a>测试16改进：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/7</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePost = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader2</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//显示指定该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader2</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将系统类加载器当作该类的父类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"findClass,输出这句话说明我们自己的类加载器加载了指定的类"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = name.replace(<span class="string">"."</span>, File.separator);<span class="comment">//File.separator根据操作系统而变化</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path + name + filePost));</span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read())) &#123;</span><br><span class="line">                byteArrayOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = byteArrayOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        CustomClassLoader2 Loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">  test1(loader2) </span><br><span class="line">        CustomClassLoader2 Loader3 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load3"</span>);</span><br><span class="line">  test1(loader3)    </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行结果： </span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        com.poplar.classload.CustomClassLoader2@15db9742</span></span><br><span class="line"><span class="comment">        2018699554</span></span><br><span class="line"><span class="comment">        -------------------------------------</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        com.poplar.classload.CustomClassLoader2@4e25154f</span></span><br><span class="line"><span class="comment">        1550089733*/</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(CustomClassLoader2 loader2)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader2.loadClass(<span class="string">"com.poplar.classload.ClassLoadTest"</span>);</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance.getClass().getClassLoader());</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//运行结果：（此处测试建议把源码文件先删掉，不然idea会重新生成classes,还是会导致系统类加载器加载）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间-上面的列子中加载同一个文件"><a href="#命名空间-上面的列子中加载同一个文件" class="headerlink" title="命名空间(上面的列子中加载同一个文件)"></a>命名空间(上面的列子中加载同一个文件)</h3><ul><li>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类构成</strong>；</li><li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</li><li>同一命名空间内的类是互相可见的，<strong>非同一命名空间内的类是不可见的</strong>；</li><li>子加载器可以见到父加载器加载的类，<strong>父加载器也不能见到子加载器加载的类</strong>。</li></ul><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。</li><li>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</li><li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。</li><li>由用户自定义的类加载器所加载的类是可以被卸载的。（<strong>jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追</strong>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      CustomClassLoader2 Loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">      test1(Loader2);</span><br><span class="line">      Loader2 = <span class="keyword">null</span>;</span><br><span class="line">      System.gc();</span><br><span class="line">      Thread.sleep(<span class="number">10000</span>); <span class="comment">//jvisualvm 查看当前java进程 -XX:+TraceClassUnloading这个用于追踪类卸载的信息</span></span><br><span class="line">      CustomClassLoader2 Loader3 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">      test1(Loader3);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      执行结果：</span></span><br><span class="line"><span class="comment">      findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">      com.poplar.classload.CustomClassLoader2@15db9742</span></span><br><span class="line"><span class="comment">      2018699554</span></span><br><span class="line"><span class="comment">      -------------------------------------</span></span><br><span class="line"><span class="comment">      [Unloading class com.poplar.classload.ClassLoadTest 0x0000000100060828]</span></span><br><span class="line"><span class="comment">      findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">      com.poplar.classload.CustomClassLoader2@4e25154f</span></span><br><span class="line"><span class="comment">      1550089733*/</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="测试17："><a href="#测试17：" class="headerlink" title="测试17："></a>测试17：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat by load "</span> + MyCat<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Simple by Load "</span> + Simple<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试17-1</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        loader.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">        <span class="comment">//MyCat是由加载MySample的加载器去加载的：</span></span><br><span class="line">        <span class="comment">//如果只删除classpath下的MyCat，则会报错，NoClassDefFoundError；</span></span><br><span class="line">        <span class="comment">//如果只删除classpath下的MySample，则由自定义加载器加载桌面上的MySample，由系统应用加载器加载MyCat。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试17-2"><a href="#测试17-2" class="headerlink" title="测试17_2"></a>测试17_2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest17_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"loader"</span>);</span><br><span class="line">        loader.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"com.poplar.classload.Simple2"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        <span class="comment">//如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）</span></span><br><span class="line">        Object instance = clazz.newInstance();<span class="comment">//实列化Simple和MyCat</span></span><br><span class="line">        <span class="comment">//修改MyCat2后，仍然删除classpath下的Simple2，留下MyCat2，程序报错</span></span><br><span class="line">        <span class="comment">//因为命名空间，父加载器找不到子加载器所加载的类，因此MyCat2找不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCat2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat by load "</span> + MyCat<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(Simple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Simple by Load "</span> + Simple<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(MyCat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>子加载器所加载的类能够访问父加载器所加载的类；</strong></li><li><strong>而父加载器所加载的类无法访问子加载器所加载的类</strong>。</li></ol><h3 id="测试18"><a href="#测试18" class="headerlink" title="测试18:"></a>测试18:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));<span class="comment">//根加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));<span class="comment">//扩展类加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//应用类加载器路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试19"><a href="#测试19" class="headerlink" title="测试19:"></a>测试19:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 各加载器的路径是可以修改的，修改后会导致运行失败，ClassNotFoundExeception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该类默认有扩展类加载器加载的,但是如果我们把该类默认的加载路劲修改后，就会报错</span></span><br><span class="line">        AESKeyGenerator aesKeyGenerator = <span class="keyword">new</span> AESKeyGenerator();</span><br><span class="line">        System.out.println(aesKeyGenerator.getClass().getClassLoader()); <span class="comment">//ExtClassLoader@232204a1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试20"><a href="#测试20" class="headerlink" title="测试20"></a>测试20</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader1 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load1"</span>);</span><br><span class="line">        CustomClassLoader2 loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.poplar.classload.Person"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.poplar.classload.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clazz1和clazz均由应用类加载器加载的，第二次不会重新加载，结果为true</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setPerson"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试21："><a href="#测试21：" class="headerlink" title="测试21："></a>测试21：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 1.每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类构成；</span></span><br><span class="line"><span class="comment"> * 2.在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</span></span><br><span class="line"><span class="comment"> * 3.在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</span></span><br><span class="line"><span class="comment"> * 4.同一命名空间内的类是互相可见的，非同一命名空间内的类是不可见的；</span></span><br><span class="line"><span class="comment"> * 5.子加载器可以见到父加载器加载的类，父加载器也不能见到子加载器加载的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest21</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader2 loader1 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        CustomClassLoader2 loader2 = <span class="keyword">new</span> CustomClassLoader2(<span class="string">"load2"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\poplar\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.poplar.classload.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.poplar.classload.MyPerson"</span>);</span><br><span class="line">        <span class="comment">//由于clazz1和clazz2分别有不同的类加载器所加载，所以他们处于不同的名称空间里</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//此处报错，loader1和loader2所处不用的命名空间</span></span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">       findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        findClass,输出这句话说明我们自己的类加载器加载了指定的类</span></span><br><span class="line"><span class="comment">        false</span></span><br><span class="line"><span class="comment">        Exception in thread "main" java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">        at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="comment">        at com.poplar.classload.ClassLoadTest21.main(ClassLoadTest21.java:25)</span></span><br><span class="line"><span class="comment">        Caused by: java.lang.ClassCastException: com.poplar.classload.MyPerson cannot be cast to com.poplar.classload.MyPerson*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyPerson person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类加载器双亲委托模型的好处：<br>（1）可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；<br>（2）确保Java核心类库中的类不会被自定义的类所替代；<br>（3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。</li><li>父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。</li></ul><h3 id="测试22"><a href="#测试22" class="headerlink" title="测试22:"></a>测试22:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest22</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoadTest22 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展类加载器只加载jar包，需要把class文件打成jar</span></span><br><span class="line">    <span class="comment">//此列子中将扩展类加载的位置改成了当前的classes目录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoadTest22<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(ClassLoadTest2<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试23："><a href="#测试23：" class="headerlink" title="测试23："></a>测试23：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Launcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/8</span></span><br><span class="line"><span class="comment"> * 在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。</span></span><br><span class="line"><span class="comment"> * 如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。</span></span><br><span class="line"><span class="comment"> * 在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：</span></span><br><span class="line"><span class="comment"> * Error occurred during initialization of VM</span></span><br><span class="line"><span class="comment"> * java/lang/NoClassDeFoundError: java/lang/Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));<span class="comment">//根加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));<span class="comment">//扩展类加载器路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//应用类加载器路径</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="comment">//此处由于系统和扩展类加载器都是Launcher其内部静态类，但又都是非public的，</span></span><br><span class="line">        <span class="comment">//所以不能直接获取他们的类加载器，方法就是通过获取他们的外部类加载器是谁？从而确当他们的类加载器。</span></span><br><span class="line">        System.out.println(Launcher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的系统属性指定系统类加载器，默认是AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）<br>类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。</li><li>内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。</li><li>启动类加载器并不是java类，其他的加载器都是java类。</li><li>启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。</li></ul><h3 id="测试24："><a href="#测试24：" class="headerlink" title="测试24："></a>测试24：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest24</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前类加载器(Current ClassLoader)</span></span><br><span class="line"><span class="comment">     * 每个类都会尝试使用自己的类加载器去加载依赖的类。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 线程上下文类加载器(Context ClassLoader)</span></span><br><span class="line"><span class="comment">     * 线程上下文加载器 @ jdk1.2</span></span><br><span class="line"><span class="comment">     * 线程类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader c)</span></span><br><span class="line"><span class="comment">     * 如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，</span></span><br><span class="line"><span class="comment">     * java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 线程上下文类加载器的作用：</span></span><br><span class="line"><span class="comment">     * SPI：Service Provide Interface</span></span><br><span class="line"><span class="comment">     * 父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，</span></span><br><span class="line"><span class="comment">     * 这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，</span></span><br><span class="line"><span class="comment">     * 有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），</span></span><br><span class="line"><span class="comment">     * Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，</span></span><br><span class="line"><span class="comment">     * 就可以由设置的上下文类加载器来实现对于接口实现类的加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><ul><li><strong>当前类加载器(Current ClassLoader)</strong><br>每个类都会尝试使用自己的类加载器去加载依赖的类。</li></ul><ul><li><p><strong>线程上下文类加载器(Context ClassLoader)</strong><br>线程上下文加载器 @ jdk1.2<br>线程类中的<code>getContextClassLoader()</code>与 <code>setContextClassLoader(ClassLoader c)</code><br>如果没有通过<code>setContextClassLoader()</code>方法设置，线程将继承父线程的上下文类加载器，<br>java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。</p></li><li><p><strong>线程上下文类加载器的作用：</strong><br><strong>SPI</strong>：<code>Service Provide Interface</code><br>父<code>ClassLoader</code>可以使用当前线程<code>Thread.currentThread().getContextClassLoader()</code>所制定的<code>ClassLoader</code>加载的类，<br>这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的<code>ClassLoader</code>加载的类的情况，即改变了双亲委托模型。</p></li><li><p><strong>在双亲委托模型下</strong>，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，<br>有些接口是Java核心库所提供的的（如JDBC），Java核心库（如Connection接口）是由启动类加载器去加载的，而这些接口的实现却来自不同的jar包（<strong>默认会被添加到classes下，这样就会导致父加载器无法访问子类加载器所加载的类</strong>）（厂商提供），<br>Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，<br>就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p></li></ul><h3 id="测试25"><a href="#测试25" class="headerlink" title="测试25:"></a>测试25:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest25</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoadTest25</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = thread.getContextClassLoader();</span><br><span class="line">        thread.setContextClassLoader(classLoader);</span><br><span class="line">        System.out.println(<span class="string">"Class: "</span> + classLoader.getClass()); <span class="comment">//Class: class sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        System.out.println(<span class="string">"Parent "</span> + classLoader.getParent()); <span class="comment">// Parent sun.misc.Launcher$ExtClassLoader@5b74b597</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ClassLoadTest25();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line">   <span class="comment">/* public Launcher() &#123;</span></span><br><span class="line"><span class="comment">        Launcher.ExtClassLoader var1;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException var10) &#123;</span></span><br><span class="line"><span class="comment">            throw new InternalError("Could not create extension class loader", var10);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            //获取到系统类加载器</span></span><br><span class="line"><span class="comment">            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException var9) &#123;</span></span><br><span class="line"><span class="comment">            throw new InternalError("Could not create application class loader", var9);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //把系统类加载器设置到当前线程的上下文类加载器中</span></span><br><span class="line"><span class="comment">        Thread.currentThread().setContextClassLoader(this.loader);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br></pre></td></tr></table></figure><h3 id="测试26"><a href="#测试26" class="headerlink" title="测试26"></a>测试26</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Driver;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 线程上下文类加载器的一般使用模式：（获取-使用-还原）</span></span><br><span class="line"><span class="comment"> * 伪代码：</span></span><br><span class="line"><span class="comment"> * ClassLoader classLoader=Thread.currentThread().getContextLoader();</span></span><br><span class="line"><span class="comment"> * try&#123;</span></span><br><span class="line"><span class="comment"> * Thread.currentThread().setContextLoader(targetTccl);</span></span><br><span class="line"><span class="comment"> * myMethod();</span></span><br><span class="line"><span class="comment"> * &#125;finally&#123;</span></span><br><span class="line"><span class="comment"> * Thread.currentThread().setContextLoader(classLoader);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 在myMethod中调用Thread.currentThread().getContextLoader()做某些事情</span></span><br><span class="line"><span class="comment"> * ContextClassLoader的目的就是为了破坏类加载委托机制</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在SPI接口的代码中，使用线程上下文类加载器就可以成功的加载到SPI的实现类。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，</span></span><br><span class="line"><span class="comment"> * 就必须通过上下文类加载器来帮助高层的ClassLoader找到并加载该类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。</span></span><br><span class="line">        <span class="comment">//Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServiceLoader服务提供者，加载实现的服务</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Driver driver = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver:"</span> + driver.getClass() + <span class="string">",loader"</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前上下文加载器"</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader的加载器"</span> + ServiceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试27"><a href="#测试27" class="headerlink" title="测试27"></a>测试27</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.classload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest27</span> </span>&#123;</span><br><span class="line">    <span class="comment">//源码：DriverManager.getConnection()&#123;&#125;方法中的：</span></span><br><span class="line">    <span class="comment">/* private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span></span><br><span class="line"><span class="comment">            boolean result = false;</span></span><br><span class="line"><span class="comment">            if(driver != null) &#123;</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt; aClass = null;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    //到这儿时其实已经加载过了，再次加载主要是名称空间的问题，确保是在同一名称空间下</span></span><br><span class="line"><span class="comment">                    aClass =  Class.forName(driver.getClass().getName(), true, classLoader);</span></span><br><span class="line"><span class="comment">                &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="comment">                    result = false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                result = ( aClass == driver.getClass() ) ? true : false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/user"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jar-hell问题以及解决办法"><a href="#jar-hell问题以及解决办法" class="headerlink" title="jar hell问题以及解决办法"></a>jar hell问题以及解决办法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> 当一个类或者一个资源文件存在多个jar中，就会存在jar hell问题。</span><br><span class="line"> 可通过以下代码解决问题：*/</span><br><span class="line"> ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"> String resource = &quot;java/lang/String.class&quot;;</span><br><span class="line"> Enumeration&lt;URL&gt; urls = classLoader.getResources(resource);</span><br><span class="line"> while (urls.hasMoreElements()) &#123;</span><br><span class="line">     URL element = urls.nextElement();</span><br><span class="line">     System.out.println(element);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;strong&gt; 概述：&lt;/strong&gt;张龙深入理解JVM视频JVM类加载器部分学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://daijinlin.com/categories/Markdown/"/>
    
    
      <category term="Markdown UML" scheme="http://daijinlin.com/tags/Markdown-UML/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码</title>
    <link href="http://daijinlin.com/2019/11/17/java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <id>http://daijinlin.com/2019/11/17/java字节码/</id>
    <published>2019-11-17T08:53:46.000Z</published>
    <updated>2020-01-14T06:18:46.993Z</updated>
    
    <content type="html"><![CDATA[<p>   <strong> 概述：</strong>张龙深入理解JVM视频Java字节码部分学习笔记<br><a id="more"></a></p><h1 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Java虚拟机不和包括java在内的任何语言绑定，它只与“Class”特定的二进制文件格式关联，Class文件中包含Java虚拟机指令集和符号表以及若干其他辅助信息。本文将以字节码的角度来研究Java虚拟机。</li></ul><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ul><li>Java跨平台的原因是JVM不跨平台</li><li>首先编写一个简单的java代码，一次为例进行讲解</li></ul><h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1:"></a>测试1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * 源码：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<strong>javap</strong>命令后的字节码文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;ByteCodeTest1.java&quot;</span><br><span class="line">public class com.poplar.bytecode.ByteCodeTest1 &#123;</span><br><span class="line">  public com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">  public int getA();</span><br><span class="line">  public void setA(int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<strong>javap -c</strong>命令后的字节码文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"ByteCodeTest1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">poplar</span>.<span class="title">bytecode</span>.<span class="title">ByteCodeTest1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_1</span><br><span class="line">       6: putfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">4</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       2: putfield      #2                  // Field a:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<strong>javap -verbose</strong>命令后的字节码文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/idea-workspace/jvm-study/build/classes/java/main/com/poplar/bytecode/ByteCodeTest1<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2019-11-9</span>; size <span class="number">503</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">785</span>bb46a966a166c3101fb5c64415667</span><br><span class="line">  Compiled from <span class="string">"ByteCodeTest1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">poplar</span>.<span class="title">bytecode</span>.<span class="title">ByteCodeTest1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/poplar/bytecode/ByteCodeTest1.a:I</span><br><span class="line">   #3 = Class              #22            // com/poplar/bytecode/ByteCodeTest1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               ByteCodeTest1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/poplar/bytecode/ByteCodeTest1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.poplar.bytecode.ByteCodeTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/poplar/bytecode/ByteCodeTest1;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"ByteCodeTest1.java"</span></span><br></pre></td></tr></table></figure><ul><li>使用winHex打开后的文件：</li></ul><p><img src="/res/class/byte.png" alt="ByteCodeTest1"></p><ol><li><p>使用javap -verbose ByteCodeTest1命令分析一个字节码文件时，将会分析该字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量的信息。</p></li><li><p>魔数：所有的.class文件的前四个字节都是魔数，魔数值为固定值：0xCAFEBABE（咖啡宝贝）</p></li><li><p>版本号：魔数后面4个字节是版本信息，前两个字节表示minor version（次版本号），后两个字节表示major version（主版本号），十六进制34=十进制52。所以该文件的版本号为1.8.0。低版本的编译器编译的字节码可以在高版本的JVM下运行，反过来则不行。</p></li><li><p>常量池（constant pool）：版本号之后的就是常量池入口，一个java类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是class文件的资源仓库，包括java类定义的方法和变量信息，常量池中主要存储两类常量：字面量和符号引用。字面量如文本字符串、java中生命的final常量值等，符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p></li><li><p>常量池的整体结构：Java类对应的常量池主要由常量池数量和常量池数组两部分共同构成，常量池数量紧跟在主版本号后面，占据两个字节，而常量池数组在常量池数量之后。常量池数组与一般数组不同的是，常量池数组中元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个u1类型标志位，占据一个字节，JVM在解析常量池时，就会根据这个u1类型的来获取对应的元素的具体类型。 值得注意的是，常量池数组中元素的个数=常量池数-1,（其中0暂时不使用）。目的是满足某些常量池索引值的数据在特定的情况下需要表达不引用任何常量池的含义。根本原因在于索引为0也是一个常量，它是JVM的保留常量，它不位于常量表中。这个常量就对应null，所以常量池的索引从1而非0开始。</p></li></ol><p><img src="/res/class/pool.png" alt=""></p><ol><li>在JVM规范中，每个变量/字段都有描述信息，主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型和顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，而对象类型使用字符L+对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示。如下所示:B - byte，C - char，D - double，F - float，I - int，J -l ong，S -short，Z - boolean，V - void，L-对象类型，如Ljava/lang/String;<br>对于数组类型来说，每一个维度使用一个前置的[ 来表示，如int[]表示为[I ，String [][]被记录为[[Ljava/lang/String;</li><li>用描述符描述方法的时候，用先参数列表后返回值的方式来描述。参数列表按照参数的严格顺序放在一组（）之内，如方法String getNameByID(int id ,String name)<br>(I,Ljava/lang/String;)Ljava/lang/String;<br>Java字节码整体结构</li></ol><p><img src="/res/class/gg.png" alt=""></p><h3 id="Class字节码中有两种数据类型："><a href="#Class字节码中有两种数据类型：" class="headerlink" title="Class字节码中有两种数据类型："></a>Class字节码中有两种数据类型：</h3><p>（1）字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。<br>（2）表/数组：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体：组成表的成分所在的位置和顺序都是已经严格定义好的。</p><p>Access Falgs：<br>访问标志信息包括了该class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被定义成final。</p><p><img src="/res/class/re.png" alt=""></p><p><img src="/res/class/hff.png" alt=""></p><ul><li><p>0x0021是0x0020和0x0001的并集，表示ACC_PUBLIC和ACC_SUPER<br>0x0002:private</p></li><li><p>字段表（Fields）：<br>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量和实例变量，但是不包括方法内部声明的局部变量。</p></li></ul><p><img src="/res/class/fieled.png" alt=""></p><ul><li><p>方法表<br>方法的属性结构：<br>方法中的每个属性都是一个attribute_info结构:<br>（1）JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件里，供运行时使用；<br>（2）不同的attribute通过attribute_name_index来区分。</p></li><li><p>attribute_info格式:<br>attribute_info{<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u1 info[attribute_length]<br>}</p></li><li><p>attribute_name_index值为code，则为Code结构<br>Code的作用是保存该方法的结构，所对应的的字节码<br><img src="/res/class/dss.png" alt=""></p></li></ul><p>attribute_length：表示attribute所包含的字节数，不包含attribute_name_index和attribute_length<br>max_stacks：表示这个方法运行的任何时刻所能达到的操作数栈的最大深度<br>max_locals：表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量<br>code_length：表示该方法所包含的字节码的字节数以及具体的指令码。具体的字节码是指该方法被调用时，虚拟机所执行的字节码<br>exception_table：存放处理异常的信息，每个exception_table表，是由start_pc、end_pc、hangder_pc、catch_type组成<br>start_pc、end_pc：表示在code数组中从start_pc到end_pc（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理<br>hangder_pc：表示处理异常的代码的开始处。<br>catch_type：表示会被处理的异常类型，它指向常量池中的一个异常类。当catch_type=0时，表示处理所有的异常。</p><ul><li><p>附加其他属性：</p></li><li><p>LineNumbeTable_attribute:<br> <img src="/res/class/rew.png" alt=""></p></li></ul><p>这个属性表示code数组中，字节码与java代码行数之间的关系，可以在调试的时候定位代码执行的行数。</p><ul><li><p>LocalVariableTable ：结构类似于 LineNumbeTable_attribute<br>对于Java中的任何一个非静态方法，至少会有一个局部变量，就是this。</p></li><li><p>字节码查看工具：jclasslib<br><a href="http://github.com/ingokegel/jclasslib">http://github.com/ingokegel/jclasslib</a></p></li><li><p>测试2 ——- 反编译分析MyTest2.class<br>static变量会导致出现static代码块</p></li></ul><h3 id="测试3："><a href="#测试3：" class="headerlink" title="测试3："></a>测试3：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/9</span></span><br><span class="line"><span class="comment"> * 从字节码分析得出的结论：</span></span><br><span class="line"><span class="comment"> * 成员变量的初始化是在构造方法中完成的，有多少个构造方法，初始化指令就会调用几次</span></span><br><span class="line"><span class="comment"> * 静态成员变量同样是在clinit方法完成的，不管有多少个静态变量都是在该方法完成初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">"Welcome"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer in = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">(String str, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteCodeTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteCodeTest2 byteCodeTest2 = <span class="keyword">new</span> ByteCodeTest2();</span><br><span class="line">        byteCodeTest2.setX(<span class="number">8</span>);</span><br><span class="line">        in = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//给当前对象上锁</span></span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给类字节码码上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 对于Java类中的每一个实例方法(非static方法) ,其在编译后所生成的字节码当中,方法参数的数量总是会比源代码中方法数的数量多一个(this) ,</span></span><br><span class="line"><span class="comment"> * 它位于方法的第一个参数位置处;这样,我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。</span></span><br><span class="line"><span class="comment"> * 这个操作是在编译期间完成的,即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问;</span></span><br><span class="line"><span class="comment"> * 接下来在运行期间由JVM在调用实例方法时,自动向实例方法传入this参数.所以,在实例方法的局部变量表中,至少会有一个指向当前对象的局部变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java字节码对于异常的处理方式：</span></span><br><span class="line"><span class="comment"> * 1.统一采用异常表的方式来对异常进行处理；</span></span><br><span class="line"><span class="comment"> * 2.在jdk1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；</span></span><br><span class="line"><span class="comment"> * 3.当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句内的字节码拼接到每个catch语句块后面。</span></span><br><span class="line"><span class="comment"> * 也就是说，程序中存在多少个catch，就存在多少个finally块的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>对于Java类中的每一个实例方法(非static方法) ,其在编译后所生成的字节码当中,方法参数的数量总是会比源代码中方法数的数量多一个(this) ,<br>它位于方法的第一个参数位置处;这样,我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。<br>这个操作是在编译期间完成的,即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问;<br>接下来在运行期间由JVM在调用实例方法时,自动向实例方法传入this参数.所以,在实例方法的局部变量表中,至少会有一个指向当前对象的局部变量</li><li><p>Java字节码对于异常的处理方式：<br>1.统一采用异常表的方式来对异常进行处理；<br>2.在jdk1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；<br>3.当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句内的字节码拼接到每个catch语句块后面。<br>也就是说，程序中存在多少个catch，就存在多少个finally块的内容。</p></li><li><p>栈帧（stack frame）：<br>用于帮助虚拟机执行方法调用和方法执行的数据结构<br>栈帧本身是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。<br>符号引用：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。（在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。）<br>直接引用：（1）直接指向目标的指针（指向对象，类变量和类方法的指针）（2）相对偏移量。（指向实例的变量，方法的指针）（3）一个间接定位到对象的句柄。<br>有些符号引用在加载阶段或者或是第一次使用时，转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在运行期转换为直接引用，这种转换叫做动态链接。</p></li><li><p>助记符：<br>1.invokeinterface：调用接口的方法，在运行期决定调用该接口的哪个对象的特定方法。<br>2.invokestatic：调用静态方法<br>3.invokespecial：调用私有方法， 构造方法（），父类的方法<br>4.invokevirtual：调用虚方法，运行期动态查找的过程<br>5.invokedynamic：动态调用方法</p></li><li><p>静态解析的四种场：静态方法、父类方法、构造方法、私有方法。</p></li><li>以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。</li></ul><h3 id="测试5："><a href="#测试5：" class="headerlink" title="测试5："></a>测试5：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 静态解析的四种场：静态方法、父类方法、构造方法、私有方法。</span></span><br><span class="line"><span class="comment"> * 以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法的静态分派。</span></span><br><span class="line"><span class="comment"> * Grandpa g1 = new Father();</span></span><br><span class="line"><span class="comment"> * 以上代码, g1的静态类型是Grandpa,而g1的实际类型(真正指向的类型)是Father.</span></span><br><span class="line"><span class="comment"> * 我们可以得出这样一个结论:变量的静态类型是不会发生变化的,而变量的实际类型则是可以发生变化的(多态的一种体现)</span></span><br><span class="line"><span class="comment"> * 实际变量是在运行期方可确定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Grandpa grandpa)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grandpa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteCodeTest4 byteCodeTest4 = <span class="keyword">new</span> ByteCodeTest4();</span><br><span class="line">        <span class="comment">//方法重载,是一种静态的行为,编译期就可以完全确定</span></span><br><span class="line">        Grandpa g1 = <span class="keyword">new</span> Father();</span><br><span class="line">        Grandpa g2 = <span class="keyword">new</span> Son();</span><br><span class="line">        byteCodeTest4.test(g1);<span class="comment">//Grandpa</span></span><br><span class="line">        byteCodeTest4.test(g2);<span class="comment">//Grandpa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试6："><a href="#测试6：" class="headerlink" title="测试6："></a>测试6：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By poplar on 2019/11/10</span></span><br><span class="line"><span class="comment"> * 方法的动态分派</span></span><br><span class="line"><span class="comment"> * 方法的动态分派涉及到一个重要概念:方法接收者。</span></span><br><span class="line"><span class="comment"> * invokevirtua1字节码指令的多态查找流程</span></span><br><span class="line"><span class="comment"> * 比较方法重载(overload)与方法重写(overwrite) ,我们可以得到这样一个结论:</span></span><br><span class="line"><span class="comment"> * 方法重载是静态的,是编译期行为;</span></span><br><span class="line"><span class="comment"> * 方法重写是动态的,是运行期行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.test();<span class="comment">//&lt;com/poplar/bytecode/Fruit.test&gt;将符号引用转换为直接引用</span></span><br><span class="line"></span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Orange();</span><br><span class="line">        orange.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fruit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试7："><a href="#测试7：" class="headerlink" title="测试7："></a>测试7：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 基于栈的解释器的执行过程概念模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicStackExecutionProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   public int calc();</span></span><br><span class="line"><span class="comment">    descriptor: ()I</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">      stack=2, locals=4, args_size=1</span></span><br><span class="line"><span class="comment">         0: bipush        100  执行地址偏移量为0 将100推送至栈顶</span></span><br><span class="line"><span class="comment">         2: istore_1          执行地址偏移量为2  将栈顶的100出栈并存放到第一个局部变量Slot中</span></span><br><span class="line"><span class="comment">         3: sipush        200</span></span><br><span class="line"><span class="comment">         6: istore_2</span></span><br><span class="line"><span class="comment">         7: sipush        300</span></span><br><span class="line"><span class="comment">        10: istore_3</span></span><br><span class="line"><span class="comment">        11: iload_1          执行地址偏移量为11 将局部变量中第一个Slot中的整型值复制到栈顶</span></span><br><span class="line"><span class="comment">        12: iload_2</span></span><br><span class="line"><span class="comment">        13: iadd            将栈顶的两个元素出栈并作整形加法，然后把结果重新入栈</span></span><br><span class="line"><span class="comment">        14: iload_3</span></span><br><span class="line"><span class="comment">        15: imul            将栈顶的两个元素出栈并作整形乘法，然后把结果重新入栈</span></span><br><span class="line"><span class="comment">        16: ireturn         结束方法并将栈顶的值返回给方法调用者</span></span><br><span class="line"><span class="comment">      LineNumberTable:</span></span><br><span class="line"><span class="comment">        line 10: 0</span></span><br><span class="line"><span class="comment">        line 11: 3</span></span><br><span class="line"><span class="comment">        line 12: 7</span></span><br><span class="line"><span class="comment">        line 13: 11</span></span><br><span class="line"><span class="comment">      LocalVariableTable:</span></span><br><span class="line"><span class="comment">        Start  Length  Slot  Name   Signature</span></span><br><span class="line"><span class="comment">            0      17     0  this   Lcom/poplar/bytecode/BasicStackExecutionProcess;</span></span><br><span class="line"><span class="comment">            3      14     1     a   I</span></span><br><span class="line"><span class="comment">            7      10     2     b   I</span></span><br><span class="line"><span class="comment">           11       6     3     c   I</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicStackExecutionProcess process = <span class="keyword">new</span> BasicStackExecutionProcess();</span><br><span class="line">        <span class="keyword">int</span> res = process.calc();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态分派："><a href="#动态分派：" class="headerlink" title="动态分派："></a>动态分派：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 动态分派的演示与证明：</span></span><br><span class="line"><span class="comment"> * 在动态分派中虚拟机是如何知道要调用那个方法的？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woMan = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.hello();</span><br><span class="line">        woMan.hello();</span><br><span class="line"></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment">    descriptor: ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">      stack=2, locals=3, args_size=1</span></span><br><span class="line"><span class="comment">         0: new           #2                  // class main/java/com/poplar/bytecode/DynamicDispatch$Man</span></span><br><span class="line"><span class="comment">         3: dup</span></span><br><span class="line"><span class="comment">         4: invokespecial #3                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Man."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">         7: astore_1</span></span><br><span class="line"><span class="comment">         8: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman</span></span><br><span class="line"><span class="comment">        11: dup</span></span><br><span class="line"><span class="comment">        12: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">        15: astore_2</span></span><br><span class="line"><span class="comment">        16: aload_1 从局部变量加载一个引用 aload1是加载索引为1的引用（man），局部变量有三个（0：args; 1 :man ; 2 :woMan）</span></span><br><span class="line"><span class="comment">        17: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        20: aload_2 加载引用woMan</span></span><br><span class="line"><span class="comment">        21: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        24: new           #4                  // class main/java/com/poplar/bytecode/DynamicDispatch$Woman</span></span><br><span class="line"><span class="comment">        27: dup</span></span><br><span class="line"><span class="comment">        28: invokespecial #5                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Woman."&lt;init&gt;":()V</span></span><br><span class="line"><span class="comment">        31: astore_1</span></span><br><span class="line"><span class="comment">        32: aload_1</span></span><br><span class="line"><span class="comment">        33: invokevirtual #6                  // Method main/java/com/poplar/bytecode/DynamicDispatch$Human.hello:()V</span></span><br><span class="line"><span class="comment">        36: return</span></span><br><span class="line"><span class="comment">      LineNumberTable:</span></span><br><span class="line"><span class="comment">        line 28: 0</span></span><br><span class="line"><span class="comment">        line 29: 8</span></span><br><span class="line"><span class="comment">        line 30: 16</span></span><br><span class="line"><span class="comment">        line 31: 20</span></span><br><span class="line"><span class="comment">        line 33: 24</span></span><br><span class="line"><span class="comment">        line 34: 32</span></span><br><span class="line"><span class="comment">        line 36: 36</span></span><br><span class="line"><span class="comment">      LocalVariableTable:</span></span><br><span class="line"><span class="comment">        Start  Length  Slot  Name   Signature</span></span><br><span class="line"><span class="comment">            0      37     0  args   [Ljava/lang/String;</span></span><br><span class="line"><span class="comment">            8      29     1   man   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;</span></span><br><span class="line"><span class="comment">           16      21     2 woMan   Lmain/java/com/poplar/bytecode/DynamicDispatch$Human;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    invokevirtual 运行期执行的时候首先：</span></span><br><span class="line"><span class="comment">    找到操作数栈顶的第一个元素它所指向对象的实际类型，在这个类型里边，然后查找和常量里边Human的方法描述符和方法名称都一致的</span></span><br><span class="line"><span class="comment">    方法，如果在这个类型下，常量池里边找到了就会返回实际对象方法的直接引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果找不到，就会按照继承体系由下往上(Man–&gt;Human–&gt;Object)查找，查找匹配的方式就是</span></span><br><span class="line"><span class="comment">    上面描述的方式，一直找到位为止。如果一直找不到就会抛出异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比较方法重载（overload）和方法重写（overwrite），我们可以得出这样的结论：</span></span><br><span class="line"><span class="comment">    方法重载是静态的，是编译器行为；方法重写是动态的，是运行期行为。</span></span><br><span class="line"><span class="comment">    ————————————————</span></span><br><span class="line"><span class="comment">    版权声明：本文为CSDN博主「魔鬼_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="comment">    原文链接：https://blog.csdn.net/wzq6578702/article/details/82712042</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态分派："><a href="#静态分派：" class="headerlink" title="静态分派："></a>静态分派：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poplar.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created BY poplar ON 2019/12/4</span></span><br><span class="line"><span class="comment"> * 静态分派的演示与证明：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Human param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Man param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Woman param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticDispatch dispatch = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        <span class="comment">/*Human man = new Man();</span></span><br><span class="line"><span class="comment">        Human woMan = new Woman();</span></span><br><span class="line"><span class="comment">        dispatch.hello(man);</span></span><br><span class="line"><span class="comment">        dispatch.hello(woMan);*/</span></span><br><span class="line"></span><br><span class="line">        Human human = <span class="keyword">new</span> Woman();</span><br><span class="line">        human = <span class="keyword">new</span> Man();</span><br><span class="line">        dispatch.hello((Woman) human);</span><br><span class="line">        dispatch.hello((Man) human);</span><br><span class="line">        <span class="comment">//java.lang.ClassCastException: main.java.com.poplar.bytecode.WoMan cannot be cast to main.java.com.poplar.bytecode.Man</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>现代JVM在执行Java代码的时候,通常都会将解释执行与编译执行二者结合起来进行.</p><ul><li>所谓解释执行，就是通过解释器来读取字节码,遇到相应的指令就去执行该指令</li><li>所谓编译执行,就是通过即时编译器(Just in Time, JIT)将字节码转换为本地机器码来执行;现代JoM会根据代码热点来生成目应的本地机器码<br>在布尔德E马文项目</li></ul></li><li><p>JVM执行指令时所采取的方式是基于栈的指令集。</p><p>基于栈的指令集主要有入栈和出栈两种；</p><p>基于栈的指令集的缺点在主完成相同的操作,指令集通常要比基于寄存器的指令集要多，指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的,是在高速缓冲区中进行的,速度要快很多.虽然虚拟机可以采用一些优化手段,但总体来说,基于栈的指令集的执行速度要慢一些；</p><p>基手栈的指令集的优势在于它可以在不同平台之间移植,而基于寄存器的指令集是与硬件架构累密关联的,无法做到可移植。</p><h3 id="运行时栈结构"><a href="#运行时栈结构" class="headerlink" title="运行时栈结构"></a>运行时栈结构</h3><p><img src="/res/class/stack.png" alt="运行时栈结构"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;strong&gt; 概述：&lt;/strong&gt;张龙深入理解JVM视频Java字节码部分学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://daijinlin.com/categories/Markdown/"/>
    
    
      <category term="Markdown UML" scheme="http://daijinlin.com/tags/Markdown-UML/"/>
    
  </entry>
  
  <entry>
    <title>Markdown高级用法</title>
    <link href="http://daijinlin.com/2017/03/19/Markdown%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://daijinlin.com/2017/03/19/Markdown高级用法/</id>
    <published>2017-03-19T08:53:46.000Z</published>
    <updated>2020-01-14T05:10:44.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UML流程图"><a href="#UML流程图" class="headerlink" title="UML流程图"></a>UML流程图</h2><p><a href="https://github.com/adrai/flowchart.js">语法参考</a></p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">## UML时序图</span><br><span class="line"></span><br><span class="line">[参考链接](https://bramp.github.io/js-sequence-diagrams/)</span><br><span class="line"></span><br><span class="line">~~~sequence</span><br><span class="line">Title: 我是标题</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">participant C</span><br><span class="line">participant D</span><br><span class="line">A-&gt;B: 方法，代表实心箭头，同步消息，比如 AJAX 的同步请求</span><br><span class="line">B-&gt;&gt;C: 请求，</span><br><span class="line">C--&gt;D: 代表虚线，表示返回消息，spring Controller return</span><br><span class="line">D--&gt;&gt;A: 代表非实心箭头 ，异步消息，比如AJAX请求</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title:连接建立的过程</span><br><span class="line">客户主机-&gt;服务器主机: 连接请求（SYN=1,seq=client_isn） </span><br><span class="line">服务器主机-&gt;客户主机: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1</span><br><span class="line">客户主机-&gt;服务器主机: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1</span><br></pre></td></tr></table></figure><div id="sequence-0"></div><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p><a href="http://knsv.github.io/mermaid">语法参考</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">client1--&gt;|read / write|SVN((SVN server))</span><br><span class="line">client2--&gt;|read only|SVN</span><br><span class="line">client3--&gt;|read / write|SVN</span><br><span class="line">client4--&gt;|read only|SVN</span><br><span class="line">client5(...)--&gt;SVN</span><br><span class="line">SVN---|store the data|sharedrive</span><br></pre></td></tr></table></figure><ul><li><strong>Flow</strong></li></ul><pre class="mermaid">graph TDA[Hard] -->|Text| B(Round)B --> C{Decision}C -->|One| D[Result 1]C -->|Two| E[Result 2]</pre><ul><li><p><strong>Sequence</strong></p><pre class="mermaid">  sequenceDiagramAlice->>John: Hello John, how are you?loop Healthcheck    John->>John: Fight against hypochondriaendNote right of John: Rational thoughts!John-->>Alice: Great!John->>Bob: How about you?Bob-->>John: Jolly good!</pre></li><li><p><strong>Gantt</strong></p><pre class="mermaid">  ganttsection SectionCompleted :done,    des1, 2014-01-06,2014-01-08Active        :active,  des2, 2014-01-07, 3dParallel 1   :         des3, after des1, 1dParallel 2   :         des4, after des1, 1dParallel 3   :         des5, after des3, 1dParallel 4   :         des6, after des4, 1d</pre></li><li><p><strong>Class</strong></p></li></ul><pre class="mermaid">classDiagramClass01 <|-- AveryLongClass : Cool<<interface>> Class01Class09 --> C2 : Where am i?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaclass Class10 {  <<service>>  int id  size()}</pre><ul><li><p><strong>State</strong></p><pre class="mermaid">  stateDiagram[*] --> StillStill --> [*]Still --> MovingMoving --> StillMoving --> CrashCrash --> [*]</pre></li><li><p><strong>Pie</strong></p><p><code>mermaidpie&quot;Dogs&quot; : 386&quot;Cats&quot; : 85&quot;Rats&quot; : 15</code><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]e=>end: End:>http://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yes or No?|approved:>http://www.baidu.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e```　~~~#### 示例2```flowst=>start: Start:>http://www.google.com[blank]e=>end:>http://www.google.comop1=>operation: My Operationsub1=>subroutine: My Subroutinecond=>condition: Yesor No?:>http://www.google.comio=>inputoutput: catch something...para=>parallel: parallel tasksst->op1->condcond(yes)->io->econd(no)->parapara(path1, bottom)->sub1(right)->op1para(path2, top)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant 客户端participant 控制器participant 业务participant 数据库客户端->控制器: 提交数据店铺Note right of 客户端: 提交数据Javascript进行验证控制器->控制器: 验证数据完整性Note left of 控制器: 返回错误的字段信息控制器-->客户端: 数据不完整控制器->业务: 保存店铺到数据库业务->业务: 保存店铺数据业务-->控制器: 保存出现异常控制器-->客户端: 保存异常，提示客户端业务-> 数据库: 保存成功数据库-->业务: success业务-->控制器: success控制器-->客户端: success 客户端Note left of 控制器: 返回正确的提示，并跳转到审核第二步</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UML流程图&quot;&gt;&lt;a href=&quot;#UML流程图&quot; class=&quot;headerlink&quot; title=&quot;UML流程图&quot;&gt;&lt;/a&gt;UML流程图&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/adrai/flowchart.js&quot;&gt;语法参考&lt;/
      
    
    </summary>
    
      <category term="Markdown" scheme="http://daijinlin.com/categories/Markdown/"/>
    
    
      <category term="Markdown UML" scheme="http://daijinlin.com/tags/Markdown-UML/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码分析</title>
    <link href="http://daijinlin.com/2017/03/11/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://daijinlin.com/2017/03/11/Retrofit源码分析/</id>
    <published>2017-03-11T08:53:46.000Z</published>
    <updated>2020-01-14T06:17:58.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.6.0'</span></span><br></pre></td></tr></table></figure><h5 id="创建Retrofit并请求数据"><a href="#创建Retrofit并请求数据" class="headerlink" title="创建Retrofit并请求数据"></a>创建Retrofit并请求数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_URL = <span class="string">"https://api.github.com"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String login;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> contributions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contributor</span><span class="params">(String login, <span class="keyword">int</span> contributions)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.login = login;</span><br><span class="line">      <span class="keyword">this</span>.contributions = contributions;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</span><br><span class="line">        <span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</span><br><span class="line">        <span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a very simple REST adapter which points the GitHub API.</span></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(API_URL)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an instance of our GitHub API interface.</span></span><br><span class="line">    GitHub github = retrofit.create(GitHub<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a call instance for looking up Retrofit contributors.</span></span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to the library.</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = call.execute().body();</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h5 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建<code>Retrofit</code>对象</h5><p>创建<code>Retrofit</code>时，我们调用了<code>new Retrofit.Builder()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ①</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...省略代码专用...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Build a new &#123;<span class="doctag">@link</span> Retrofit&#125;.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Calling &#123;<span class="doctag">@link</span> #baseUrl&#125; is required before calling &#123;<span class="doctag">@link</span> #build()&#125;. All other methods</span></span><br><span class="line"><span class="comment">   * are optional.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Retrofit retrofit) &#123;</span><br><span class="line">      platform = Platform.get();</span><br><span class="line">      callFactory = retrofit.callFactory;</span><br><span class="line">      baseUrl = retrofit.baseUrl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not add the default BuiltIntConverters and platform-aware converters added by build().</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,</span><br><span class="line">          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();</span><br><span class="line">          i &lt; size; i++) &#123;</span><br><span class="line">        converterFactories.add(retrofit.converterFactories.get(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not add the default, platform-aware call adapters added by build().</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,</span><br><span class="line">          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();</span><br><span class="line">          i &lt; size; i++) &#123;</span><br><span class="line">        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      callbackExecutor = retrofit.callbackExecutor;</span><br><span class="line">      validateEagerly = retrofit.validateEagerly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The HTTP client used for requests.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This is a convenience method for calling &#123;<span class="doctag">@link</span> #callFactory&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callFactory(Objects.requireNonNull(client, <span class="string">"client == null"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify a custom call factory for creating &#123;<span class="doctag">@link</span> Call&#125; instances.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: Calling &#123;<span class="doctag">@link</span> #client&#125; automatically sets this value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">callFactory</span><span class="params">(okhttp3.Call.Factory factory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callFactory = Objects.requireNonNull(factory, <span class="string">"factory == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #baseUrl(HttpUrl)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(URL baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #baseUrl(HttpUrl)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The specified endpoint values (such as with &#123;<span class="doctag">@link</span> GET <span class="doctag">@GET</span>&#125;) are resolved against this</span></span><br><span class="line"><span class="comment">     * value using &#123;<span class="doctag">@link</span> HttpUrl#resolve(String)&#125;. The behavior of this matches that of an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> &lt;a href=""&gt;&#125; link on a website resolving on the current URL.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Base URLs should always end in &#123;<span class="doctag">@code</span> /&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A trailing &#123;<span class="doctag">@code</span> /&#125; ensures that endpoints values which are relative paths will correctly</span></span><br><span class="line"><span class="comment">     * append themselves to a base which has path components.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Correct:&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/api/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Incorrect:&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method enforces that &#123;<span class="doctag">@code</span> baseUrl&#125; has a trailing &#123;<span class="doctag">@code</span> /&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Endpoint values which contain a leading &#123;<span class="doctag">@code</span> /&#125; are absolute.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Absolute values retain only the host from &#123;<span class="doctag">@code</span> baseUrl&#125; and ignore any specified path</span></span><br><span class="line"><span class="comment">     * components.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: /foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: /foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Endpoint values may be a full URL.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Values which have a host replace the host of &#123;<span class="doctag">@code</span> baseUrl&#125; and values also with a scheme</span></span><br><span class="line"><span class="comment">     * replace the scheme of &#123;<span class="doctag">@code</span> baseUrl&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: https://github.com/square/retrofit/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: https://github.com/square/retrofit/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: //github.com/square/retrofit/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add converter factory for serialization and deserialization of objects. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> </span>&#123;</span><br><span class="line">      converterFactories.add(Objects.requireNonNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a call adapter factory for supporting service method return types other than &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Call&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">      callAdapterFactories.add(Objects.requireNonNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The executor on which &#123;<span class="doctag">@link</span> Callback&#125; methods are invoked when returning &#123;<span class="doctag">@link</span> Call&#125; from</span></span><br><span class="line"><span class="comment">     * your service method.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: &#123;<span class="doctag">@code</span> executor&#125; is not used for &#123;<span class="doctag">@linkplain</span> #addCallAdapterFactory custom method</span></span><br><span class="line"><span class="comment">     * return types&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">callbackExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = Objects.requireNonNull(executor, <span class="string">"executor == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a modifiable list of call adapter factories. */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.callAdapterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a modifiable list of converter factories. */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Converter.Factory&gt; converterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.converterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When calling &#123;<span class="doctag">@link</span> #create&#125; on the resulting &#123;<span class="doctag">@link</span> Retrofit&#125; instance, eagerly validate</span></span><br><span class="line"><span class="comment">     * the configuration of all methods in the supplied interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">validateEagerly</span><span class="params">(<span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the &#123;<span class="doctag">@link</span> Retrofit&#125; instance using the configured values.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: If neither &#123;<span class="doctag">@link</span> #client&#125; nor &#123;<span class="doctag">@link</span> #callFactory&#125; is called a default &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * OkHttpClient&#125; will be created and used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">      converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">      converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看出，通过创建<code>Retrofit.Builder</code>对象运用<code>Builder</code>设计模式链式调用为<code>Retrofit.Builder</code>中的属性进行赋值,调用<code>build</code>方法时，将这些属性赋值给一个<code>Retrofit</code>对象，最后将这个<code>Retrofit</code>对象返回。我们看一下这里面的属性都是什么意思。</p><div id="sequence-0"></div><p>在介绍各个属性之前先介绍一下</p><h4 id="serviceMethodCache集合"><a href="#serviceMethodCache集合" class="headerlink" title="serviceMethodCache集合"></a>serviceMethodCache集合</h4><p>在Retrofit类的内部会首先创建一个集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这个集合的<code>Key</code>是一个<code>Mehtod</code>对象，<code>Value</code>是与<code>Key</code>相对应的<code>ServiceMethod</code>对象。<code>ServiceMethod</code>对象是根据<code>Method</code>解析之后获得，这里面包含了<code>Method</code>的方法注解、参数注解等一些列属性。我们从集合的名字就能看出来，这里面是将<code>Method</code>和对应<code>ServiceMethod</code>进行缓存的集合，这种方法我们在<code>EventBus</code>源码解析的时候就遇到过。这样做的目的就是为了加快运行速度，我们在今后的开发中也能加以借鉴并运用。有关<code>Method</code>和<code>ServiceMethod</code>都会在下文中进行讲解，这里如果不知道是什么意思也没关系。</p><h3 id="Platform平台信息"><a href="#Platform平台信息" class="headerlink" title="Platform平台信息"></a>Platform平台信息</h3><p>这个对象是<code>Retrofit.Builder</code>对象中进行定义的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private final Platform platform;</span><br><span class="line">    ...</span><br><span class="line">    Builder(Retrofit retrofit) &#123;</span><br><span class="line">      platform = Platform.get();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">class Platform &#123;</span><br><span class="line">  private static final Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  static Platform get() &#123;</span><br><span class="line">    return PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line">  private static Platform findPlatform() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class.forName(&quot;android.os.Build&quot;);</span><br><span class="line">      // 如果是Android平台</span><br><span class="line">      if (Build.VERSION.SDK_INT != 0) &#123;</span><br><span class="line">        return new Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 如果是Java平台</span><br><span class="line">      Class.forName(&quot;java.util.Optional&quot;);</span><br><span class="line">      return new Java8();</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Platform();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在这里我们可以看到这里会根据不同的平台信息返回对应的<code>Platform</code>对象，分别是<code>Android</code>和<code>Java8</code>,重点分析一下<code>Android</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static class Android extends Platform &#123;</span><br><span class="line">    // 1、判断方法是否是默认方法，所谓默认方法是指是否是Object类中已经定义的方法</span><br><span class="line">    //    如果是就返回true，否则返回false</span><br><span class="line">    @IgnoreJRERequirement // Guarded by API check.</span><br><span class="line">    @Override boolean isDefaultMethod(Method method) &#123;</span><br><span class="line">      if (Build.VERSION.SDK_INT &lt; 24) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return method.isDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public Executor defaultCallbackExecutor() &#123;</span><br><span class="line">      // 2、获取一个Executor对象，这个对象代表了回调执行器</span><br><span class="line">      return new MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、获得Android版本下默认的网络适配器集合</span><br><span class="line">    @Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">        @Nullable Executor callbackExecutor) &#123;</span><br><span class="line">      if (callbackExecutor == null) throw new AssertionError();</span><br><span class="line">      // 默认的请求适配器</span><br><span class="line">      DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);</span><br><span class="line">      // 如果Android系统版本大于24，则会返回一个CompletableFutureCallAdapterFactory和DefaultCallAdapterFactory组成的集合。</span><br><span class="line">      // 否则返回只有DefaultCallAdapterFactory对象的集合</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24</span><br><span class="line">        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">        : singletonList(executorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override int defaultCallAdapterFactoriesSize() &#123;</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24 ? 2 : 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4、获取Android版本下默认的转换器集合</span><br><span class="line">    @Override List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">      // 如果Android系统版本大于24，则会返回只有CompletableFutureCallAdapterFactory对象的集合</span><br><span class="line">      // 否则返回一个长度为0的集合</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24</span><br><span class="line">          ? singletonList(OptionalConverterFactory.INSTANCE)</span><br><span class="line">          : Collections.&lt;Converter.Factory&gt;emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override int defaultConverterFactoriesSize() &#123;</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24 ? 1 : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.1 这里返回的是Android主线程的回调</span><br><span class="line">    // 也就是说当网络请求完成后会回调到Android主线程中去，这也是Retrofit和OkHttp的不同点之一</span><br><span class="line">    static class MainThreadExecutor implements Executor &#123;</span><br><span class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在<code>Android</code>平台里面我们关注四点：</p><blockquote><p>1、判断传入的<code>Method</code>对象是否是默认方法<br> 2、获取执行回调器，这里默认的是将网络请求结果回调到<code>Android</code>主线程中。<br> 3、获得<code>Android</code>版本下默认的网络适配器集合，这里会根据<code>Android</code>版本号进行返回。<br> 4、获取<code>Android</code>版本下默认的转换器集合，它也是会根据<code>Android</code>版本号进行返回。</p></blockquote><p>这里有必要跟大家提前说一下，有关请求适配器（<code>CallAdapter.Factory</code>）和转换器（<code>Converter.Factory</code>）会在下面的文章中给出，这里先留一个印象。</p><h3 id="callFactory对象"><a href="#callFactory对象" class="headerlink" title="callFactory对象"></a>callFactory对象</h3><p>我们从单词的表面意思可以知道这个是请求工厂类，这个请求工厂类<code>okhttp3</code>的<code>Call</code>类型，这也说明了<code>Retrofit</code>是基于<code>okhttp</code>进行封装的。定义<code>callFactory</code>对象我们可以调用<code>Retrofit.Builder.callFactory</code>方法进行设置,在<code>Retrofit.Builder.build</code>方法中会将这个对象赋值个<code>Retrofit</code>对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private @Nullable okhttp3.Call.Factory callFactory;</span><br><span class="line">    ...</span><br><span class="line">    public Builder callFactory(okhttp3.Call.Factory factory) &#123;</span><br><span class="line">      this.callFactory = checkNotNull(factory, &quot;factory == null&quot;);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">      if (callFactory == null) &#123;</span><br><span class="line">        callFactory = new OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到当我们没有调用<code>Retrofit.Builder.callFactory</code>方法时，会给我们默认设置一个<code>OkHttpClient</code>对象。</p><h3 id="baseUrl基础请求路径"><a href="#baseUrl基础请求路径" class="headerlink" title="baseUrl基础请求路径"></a>baseUrl基础请求路径</h3><p><code>baseUrl</code>作为请求的基础路径，它与我们在<code>HTTP API</code>接口中定义的方法注解中的相对路径组成了完整的请求路径。我们可以调用<code>Retrofit.Builder.baseUrl</code>方法进行设置，最后通过<code>Retrofit.Builder.build</code>方法中会将这个对象赋值个<code>Retrofit</code>对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private @Nullable HttpUrl baseUrl;</span><br><span class="line">    ...</span><br><span class="line">    // 传入URL</span><br><span class="line">    public Builder baseUrl(URL baseUrl) &#123;</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      return baseUrl(HttpUrl.get(baseUrl.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 传入String</span><br><span class="line">    public Builder baseUrl(String baseUrl) &#123;</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      return baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Builder baseUrl(HttpUrl baseUrl) &#123;</span><br><span class="line">      // 判空</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      // 将url进行分割</span><br><span class="line">      List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">      // 如果baseUrl不是以&quot;/&quot;结尾，抛出异常</span><br><span class="line">      if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);</span><br><span class="line">      &#125;</span><br><span class="line">      this.baseUrl = baseUrl;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      // 再次判空</span><br><span class="line">      if (baseUrl == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      // 传入Retrofit对象中</span><br><span class="line">      return new Retrofit(..., baseUrl, ...,</span><br><span class="line">          ..., ..., ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>设置的流程：</p><blockquote><p>1、 可以调用两种方法，分别传入<code>URL</code>和<code>String</code>。<br> 2、 对<code>baseUrl</code>进行判空，然后进行分割，如果是以<code>&quot;/&quot;</code>结尾会抛出异常。<br> 3、 再进行一次判空，最后赋值给<code>Retrofit</code>对象。</p></blockquote><h3 id="converterFactories转换器集合"><a href="#converterFactories转换器集合" class="headerlink" title="converterFactories转换器集合"></a>converterFactories转换器集合</h3><p><code>converterFactories</code>集合内部存放的都是<code>Converter.Factory</code>对象，我们可以调用<code>Retrofit.Builder.addConverterFactory</code>方法进行添加。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    public Builder addConverterFactory(Converter.Factory factory) &#123;</span><br><span class="line">      // 检查factory是否为null，然后加入到集合中</span><br><span class="line">      converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   public Retrofit build() &#123;</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(</span><br><span class="line">          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">      // Add the built-in converter factory first. This prevents overriding its behavior but also</span><br><span class="line">      // ensures correct behavior when using converters that consume all types.</span><br><span class="line">      // 首先添加BuiltInConverters</span><br><span class="line">      converterFactories.add(new BuiltInConverters());</span><br><span class="line">      // 然后添加调用addConverterFactory方法传入的Converter.Factory的集合</span><br><span class="line">      converterFactories.addAll(this.converterFactories);</span><br><span class="line">      // 最后添加platform默认的Converter.Factory集合</span><br><span class="line">      converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">      // 根据converterFactories创建一个不可变集合传入</span><br><span class="line">      return new Retrofit(..., ..., unmodifiableList(converterFactories),</span><br><span class="line">          ..., ..., ...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>Converter.Factory</code>从字面意思我们能猜出它是和转换有关，具体的探究会放到下文中。</p><h3 id="callAdapterFactories请求适配器集合"><a href="#callAdapterFactories请求适配器集合" class="headerlink" title="callAdapterFactories请求适配器集合"></a>callAdapterFactories请求适配器集合</h3><p><code>callAdapterFactories</code>集合中存放的是<code>CallAdapter.Factory</code>对象，调用<code>Retrofit.Builder.addCallAdapterFactory</code>方法来设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123;</span><br><span class="line">      callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   public Retrofit build() &#123;</span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</span><br><span class="line">      // 这里不仅添加了调用addCallAdapterFactory方法时设置的CallAdapter.Factory对象</span><br><span class="line">      // 同时还添加了platform中默认的CallAdapter.Factory对象</span><br><span class="line">      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line">      </span><br><span class="line">      // 根据callAdapterFactories创建一个不可变的集合传入</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          unmodifiableList(callAdapterFactories), ..., ...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>CallAdapter.Factory</code>从字面意思可以看出是请求适配器，有关于请求适配器是什么，也会放到下文中进行探究。</p><h3 id="callbackExecutor回调执行器"><a href="#callbackExecutor回调执行器" class="headerlink" title="callbackExecutor回调执行器"></a>callbackExecutor回调执行器</h3><p>设置回调执行器我们可以通过<code>Retrofit.Builder.callbackExecutor</code>来设置，默认的会使用<code>Platform</code>的回调执行器，也就是会将请求的执行结果回调到<code>Android</code>主线程中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private @Nullable Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    public Builder callbackExecutor(Executor executor) &#123;</span><br><span class="line">      this.callbackExecutor = checkNotNull(executor, &quot;executor == null&quot;);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">      if (callbackExecutor == null) &#123;</span><br><span class="line">        // 默认为platform中的回调执行器，会将请求结果回调到Android主线程</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          ..., callbackExecutor, ...);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="validateEagerly提前验证方法标识"><a href="#validateEagerly提前验证方法标识" class="headerlink" title="validateEagerly提前验证方法标识"></a>validateEagerly提前验证方法标识</h3><p>这个标识表示是否需要提前验证<code>HTTP API</code>接口中的方法，我们通过调用<code>Retrofit.Builder.validateEagerly</code>方法进行设置，默认为<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private boolean validateEagerly;</span><br><span class="line">    ...</span><br><span class="line">    public Builder validateEagerly(boolean validateEagerly) &#123;</span><br><span class="line">      this.validateEagerly = validateEagerly;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          ..., ..., validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>到这里我们已经把<code>Retrofit.Buidler</code>中的属性分析完了，但是我们还遗留了两个问题：<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>。这两个类到底是做什么的？这里来看一下。</p><h3 id="CallAdapter-Factory"><a href="#CallAdapter-Factory" class="headerlink" title="CallAdapter.Factory"></a>CallAdapter.Factory</h3><p>既然我们已经知道这个类是用来进行请求适配的，那么我们看一下里面是怎么运行的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将响应类型为R的Call调整为T类型</span><br><span class="line">public interface CallAdapter&lt;R, T&gt; &#123;</span><br><span class="line">  // 返回此适配器将HTTP响应正文转换为Java时使用的值类型对象。 </span><br><span class="line">  // 例如, Call &lt;Repo&gt;的响应类型是Repo。 这个类型用于准备传递给adapt的call。</span><br><span class="line">  Type responseType();</span><br><span class="line">  // 这个方法是将Call&lt;R&gt;对象转成代理类T</span><br><span class="line">  T adapt(Call&lt;R&gt; call);</span><br><span class="line">  //CallAdapter工厂，retrofit默认的DefaultCallAdapterFactory其中不对Call做处理，是直接返回Call。</span><br><span class="line">  abstract class Factory &#123;</span><br><span class="line">    // 在这个方法中判断returnType是否是我们支持的类型，</span><br><span class="line">    // DefaultCallAdapterFactory没有做处理，因为在定义HTTP API接口中的方式时，returnType 即为Call&lt;Requestbody&gt;</span><br><span class="line">    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型</span><br><span class="line">    // 不支持时返回null</span><br><span class="line">    // 返回值必须是Custom并且带有泛型（参数类型），根据HTTP API接口中的方法返回值，确定returnType</span><br><span class="line">    // 如： CustomCall&lt;String&gt; getCategories()，那确定returnType就是CustomCall&lt;String&gt;</span><br><span class="line">    public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br><span class="line">        </span><br><span class="line">    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody</span><br><span class="line">    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;</span><br><span class="line">      return Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 用于获取泛型的原始类型</span><br><span class="line">    // 如Call&lt;Requestbody&gt;拿到的原始类型就是Call</span><br><span class="line">    protected static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      return Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看了这么多代码，可能还是有点云里雾里，我们找两个例子看一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">        Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    </span><br><span class="line">    // 如果返回值不是Call类型返回空</span><br><span class="line">    // 也就是说我们在定义HTTP API接口中的方法时，返回值不是Call&lt;?&gt;类型的，将不会处理</span><br><span class="line">    if (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override public Type responseType() &#123;</span><br><span class="line">        return ...;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">        return ...;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们经常会看到<code>Retrofit + RxJava</code>进行网络封装，如果要将<code>Retrofit</code>和<code>RxJava</code>结合到一起就需要<code>RxJavaCallAdapterFactory</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RxJavaCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  ...</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    Class&lt;?&gt; rawType = getRawType(returnType);</span><br><span class="line">    boolean isSingle = rawType == Single.class;</span><br><span class="line">    boolean isCompletable = rawType == Completable.class;</span><br><span class="line">    // 如果返回值不是Observable类型返回空</span><br><span class="line">    // 也就是说我们在定义HTTP API接口中的方法时，返回值不是Observable&lt;?&gt;类型的，将不会处理</span><br><span class="line">    if (rawType != Observable.class &amp;&amp; !isSingle &amp;&amp; !isCompletable) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>经过上面两个例子我们应该对<code>CallAdapter.Factory</code>有所了解了，这里来解释一下吧。</p><blockquote><p>在我们定义<code>HTTP API</code>接口时，里面方法的返回值需要由<code>Retrofit</code>中添加的<code>CallAdapter.Factory</code>决定，如果定义了<code>CallAdapter.Factory</code>不支持的类型，请求将不会被执行。</p></blockquote><h3 id="Converter-Factory"><a href="#Converter-Factory" class="headerlink" title="Converter.Factory"></a>Converter.Factory</h3><p>从上面我们也知道<code>Converter.Factory</code>适用于转换的，我们看下源码，看看它到底是怎么转换的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将F类型转成T类型</span><br><span class="line">public interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">  @Nullable T convert(F value) throws IOException;</span><br><span class="line">  abstract class Factory &#123;</span><br><span class="line">    // 判断能否将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">    // 如果不能直接返回null，反之返回对应的Converter.Factory对象</span><br><span class="line">    // type是由CallAdapter 接口里面的responseType()函数返回的。</span><br><span class="line">    public @Nullable Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class="line">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将API方法的输入参数类型从 type转换为requestBody</span><br><span class="line">    // 用于转换被注解@Body, @Part 和 @PartMap标记的类型</span><br><span class="line">    public @Nullable Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将API方法的输入参数类型从 type 转换为String</span><br><span class="line">    // 用于转换被注解 @Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型</span><br><span class="line">    public @Nullable Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从type中提取index处泛型参数的上界</span><br><span class="line">    // 例如Map&lt;String, ? extends Runnable&gt;索引为1处返回Runnable</span><br><span class="line">    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;</span><br><span class="line">      return Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从type中提取原始类类型</span><br><span class="line">    // 例如：List&lt;? extends Runnable&gt;返回的是List.class</span><br><span class="line">    protected static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      return Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看完之后还是有点懵懵哒，我们还是找一个列子，还记的我们调用<code>Retrofit.Builder.addConverterFactory</code>传入的<code>GsonConverterFactory</code>吗，看一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个Converter.Factory类使用Gson来解析Json</span><br><span class="line">public final class GsonConverterFactory extends Converter.Factory &#123;</span><br><span class="line">  // 使用默认的Gson对象来创建GsonConverterFactory</span><br><span class="line">  // 通过Gson将对象序列化或者反序列化成Json字符串</span><br><span class="line">  public static GsonConverterFactory create() &#123;</span><br><span class="line">    return create(new Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static GsonConverterFactory create(Gson gson) &#123;</span><br><span class="line">    // 检查传入的gson对象是否为空</span><br><span class="line">    // 如果为空直接抛出异常</span><br><span class="line">    if (gson == null) throw new NullPointerException(&quot;gson == null&quot;);</span><br><span class="line">    return new GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">      Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    return new GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123;</span><br><span class="line">  private final Gson gson;</span><br><span class="line">  private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    this.gson = gson;</span><br><span class="line">    this.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public T convert(ResponseBody value) throws IOException &#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    try &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      if (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        throw new JsonIOException(&quot;JSON document was not fully consumed.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将API方法的输入参数类型从 type转换为requestBody</span><br><span class="line">final class GsonRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123;</span><br><span class="line">  private static final MediaType MEDIA_TYPE = MediaType.get(&quot;application/json; charset=UTF-8&quot;);</span><br><span class="line">  private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line">  </span><br><span class="line">  private final Gson gson;</span><br><span class="line">  private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonRequestBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    this.gson = gson;</span><br><span class="line">    this.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public RequestBody convert(T value) throws IOException &#123;</span><br><span class="line">    Buffer buffer = new Buffer();</span><br><span class="line">    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">    JsonWriter jsonWriter = gson.newJsonWriter(writer);</span><br><span class="line">    adapter.write(jsonWriter, value);</span><br><span class="line">    jsonWriter.close();</span><br><span class="line">    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从<code>GsonRequestBodyConverter</code>的例子中我们总结一下<code>Converter.Factory</code>的作用：</p><blockquote><p><code>Converter.Factory</code>是将<code>HTTP API</code>方法中的参数在<code>requestBody和responseBody</code>之间进行转换。</p></blockquote><p>到这里我们才算真正的把<code>Retrofit.Buidler</code>中所涉及的属性和类分析完，休息一下，进行下半部分的分析。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/5/16ed536ac558c073?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="调用Retrofit-create方法"><a href="#调用Retrofit-create方法" class="headerlink" title="调用Retrofit.create方法"></a>调用Retrofit.create方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    // 1、验证HTTP API接口</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      // 2、验证HTTP API接口中的方法</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3、动态代理，整个Retrofit的核心之一</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line">          private final Object[] emptyArgs = new Object[0];</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面这段代码中有给出了三处注释，我们逐个看一下</p><h3 id="注释1：Utils-validateServiceInterface-Class-service"><a href="#注释1：Utils-validateServiceInterface-Class-service" class="headerlink" title="注释1：Utils.validateServiceInterface(Class service):"></a>注释1：Utils.validateServiceInterface(Class service):</h3><p>从<code>注释1</code>中我们得知这个方法是对我们定义的<code>HTTP API</code>接口进行验证，看一下它是怎么验证的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class Utils &#123;</span><br><span class="line">    ...</span><br><span class="line">  static &lt;T&gt; void validateServiceInterface(Class&lt;T&gt; service) &#123;</span><br><span class="line">    if (!service.isInterface()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (service.getInterfaces().length &gt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;API interfaces must not extend other interfaces.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里做了两步验证：</p><blockquote><p>1、验证传入的对象是否是一个接口，如果不是直接抛出异常。<br> 2、如果是一个接口，看看这个接口是否是继接口，如果继承了，也会抛出异常。</p></blockquote><h3 id="注释2：eagerlyValidateMethods-Class-lt-gt-service"><a href="#注释2：eagerlyValidateMethods-Class-lt-gt-service" class="headerlink" title="注释2：eagerlyValidateMethods(Class&lt;?&gt; service)"></a>注释2：eagerlyValidateMethods(Class&lt;?&gt; service)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里是<code>注释2</code>处的代码，<code>validateEagerly</code>这个变量在之前的代码注释中已经给出了解释，它是对方法进行提前验证的标识，一般为<code>false</code>，但是我们还是需要看一下这个方法中是怎么进行验证的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  private void eagerlyValidateMethods(Class&lt;?&gt; service) &#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    //获得接口中所有定义的方法，并遍历</span><br><span class="line">    for (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">      // 1、判断是否如果是default方法，Android平台返回false</span><br><span class="line">      // 2、判断方法是否是静态方法</span><br><span class="line">      if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">        // 如果符合条件，直接加载</span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在<code>eagerlyValidateMethods</code>方法中也是做了两件事：</p><blockquote><p>1、找出接口中的所有方法，看看是否符合条件。<br> 2、如果符合条件，直接加载方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  //缓存集合，支持多线程访问、线程安全</span><br><span class="line">  //key：Method</span><br><span class="line">  //value：Method对应的ServiceMethod</span><br><span class="line">  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    // 1、首先从方法缓存集合中获取</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    // 2、如果有，直接返回</span><br><span class="line">    if (result != null) return result;</span><br><span class="line">    </span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line">      // 3、在再次确认缓存中的是否有方法</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        // 4、对方法的注解进行解析</span><br><span class="line">        result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">        // 5、将方法传到方法缓存集合中</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>loadServiceMethod</code>这里做了三步事情：</p><blockquote><p>1、根据传入的<code>Method</code>从缓存集合中获取对应的<code>ServiceMethod</code>对象，如果有，直接返回；如果没有，对集合进行加锁，再次获取。这种方法将对象缓存起来的做法在分析<code>EventBus</code>源码的时候就见过，目的就是为了提高效率。<br> 2、如果上一步中没有获取到<code>ServiceMethod</code>对象，将对<code>Method</code>进行解析。<br> 3、将<code>Method</code>和它对应的<code>ServiceMethod</code>对象存入到缓存集合中，返回结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ServiceMethod&lt;T&gt; &#123;</span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      throw methodError(method,</span><br><span class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnType == void.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>注释2</code>处的验证<code>HTTP API</code>接口中的方法我们先分析到这里，上面这段代码我们先不进行探究，因为很快我们又会看到，具体流程会在接下来的分析中详细探究，希望大家对这个方法有所印象。我们先来总结一下<code>注释2</code>处都是做了哪些事情：</p><blockquote><p>1、获取到<code>HTTP API</code>接口中所有方法，遍历加载这些方法。<br> 2、加载的过程中先去缓存集合中看一下有没有与<code>Method</code>对应的<code>ServiceMethod</code>对象，如果有，直接返回；如果没有，对<code>Method</code>进行解析，将解析结果封装成一个<code>ServiceMethod</code>对象，并存入到缓存集合中，最后将<code>ServiceMethod</code>返回。</p></blockquote><h3 id="注释3-动态代理"><a href="#注释3-动态代理" class="headerlink" title="注释3: 动态代理"></a>注释3: 动态代理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          // 1、这里返回的是Android平台</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line">          // 2、创建一个Object数组，长度为0</span><br><span class="line">          private final Object[] emptyArgs = new Object[0];</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            // 3、如果该方法是来自Object的方法，则遵从正常调用。</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            // 4、在Android平台始终返回false</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            // 5、加载方法</span><br><span class="line">            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当调用<code>retrofit.create(ServiceApi.class)</code>实际上会生成一个<code>ServiceApi</code>的代理类对象。从前面的基础知识准备中我们知道，当调用代理类对象中的方法时，最终会调用创建代理类对象所传入的第三个参数<code>InvocationHandler.invoke</code>方法回调中去，在这个回调中对方法进行处理。<code>retrofit.create(ServiceApi.class)</code>方法的主要流程已经在上面的代码注释中给出，这个方法最重要的一步是最后的加载方法，我们来看一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    if (result != null) return result;</span><br><span class="line"></span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>嗯哼？上面这段代码是不是非常熟悉？没错，在之提前验证方法的过程中，我们已经见到过这个方法，方法中的流程这里就不再赘述，我们继续往下看。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ServiceMethod&lt;T&gt; &#123;</span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    // 1、根据传入的retrofit和method对象封装成RequestFactory</span><br><span class="line">    // 这一步主要是进行解析注解</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    // 2、获取方法的returnType</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    // 3、对方法的returnType进行验证</span><br><span class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      throw methodError(method,</span><br><span class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnType == void.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、对方法的注解进行解析，并封装成一个ServiceMethod对象</span><br><span class="line">    // 这里返回的是HttpServiceMethod对象，他是ServiceMethod的子类</span><br><span class="line">    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>哎呦，这个方法我们也见过，当时只是加深了一下印象，并没有对其进行探究。这个方法中做了四步操作，它们对应的操作已经在上面代码的注释中给出。我们重点来看一下第一步和第四步。</p><h4 id="RequestFactory-parseAnnotations-retrofit-method"><a href="#RequestFactory-parseAnnotations-retrofit-method" class="headerlink" title="RequestFactory.parseAnnotations(retrofit, method)"></a>RequestFactory.parseAnnotations(retrofit, method)</h4><p>这个方法主要是根据传入的<code>retrofit</code>对象和<code>method</code>对象封装成<code>RequestFactory</code>对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class RequestFactory &#123;</span><br><span class="line">  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    return new Builder(retrofit, method).build();</span><br><span class="line">  &#125;</span><br><span class="line">  // method对象</span><br><span class="line">  private final Method method;</span><br><span class="line">  // 基础url</span><br><span class="line">  private final HttpUrl baseUrl;</span><br><span class="line">  // 请求方法</span><br><span class="line">  final String httpMethod;</span><br><span class="line">  // 相对url，它与基础url组成请求路径</span><br><span class="line">  private final @Nullable String relativeUrl;</span><br><span class="line">  // 请求头</span><br><span class="line">  private final @Nullable Headers headers;</span><br><span class="line">  // 表示具体请求中的媒体类型信息</span><br><span class="line">  private final @Nullable MediaType contentType;</span><br><span class="line">  // 是否有请求体</span><br><span class="line">  private final boolean hasBody;</span><br><span class="line">  // 是否是Form表单提交</span><br><span class="line">  private final boolean isFormEncoded;</span><br><span class="line">  // 是否支持文件上传的Form表单</span><br><span class="line">  private final boolean isMultipart;</span><br><span class="line">  // </span><br><span class="line">  private final ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">  // 是否是kotlin挂起函数</span><br><span class="line">  final boolean isKotlinSuspendFunction;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">   * Inspects the annotations on an interface method to construct a reusable service method. This</span><br><span class="line">   * requires potentially-expensive reflection so it is best to build each service method only once</span><br><span class="line">   * and reuse it. Builders cannot be reused.</span><br><span class="line">   */</span><br><span class="line">  // 检查接口方法上的注释以构造可重用的服务方法。这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。</span><br><span class="line">  // 构建器不能重用。</span><br><span class="line">  static final class Builder &#123;</span><br><span class="line">    private static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;</span><br><span class="line">    private static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\&#123;(&quot; + PARAM + &quot;)\\&#125;&quot;);</span><br><span class="line">    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line">    // 传入的retrofit对象</span><br><span class="line">    final Retrofit retrofit;</span><br><span class="line">    // 传入的method对象</span><br><span class="line">    final Method method;</span><br><span class="line">    // method对象中的注解</span><br><span class="line">    final Annotation[] methodAnnotations;</span><br><span class="line">    // method中参数注解数组</span><br><span class="line">    final Annotation[][] parameterAnnotationsArray;</span><br><span class="line">    // method中参数类型数组</span><br><span class="line">    final Type[] parameterTypes;</span><br><span class="line">    </span><br><span class="line">    boolean gotField;</span><br><span class="line">    boolean gotPart;</span><br><span class="line">    boolean gotBody;</span><br><span class="line">    boolean gotPath;</span><br><span class="line">    boolean gotQuery;</span><br><span class="line">    boolean gotQueryName;</span><br><span class="line">    boolean gotQueryMap;</span><br><span class="line">    boolean gotUrl;</span><br><span class="line">    @Nullable String httpMethod;</span><br><span class="line">    boolean hasBody;</span><br><span class="line">    boolean isFormEncoded;</span><br><span class="line">    boolean isMultipart;</span><br><span class="line">    @Nullable String relativeUrl;</span><br><span class="line">    @Nullable Headers headers;</span><br><span class="line">    @Nullable MediaType contentType;</span><br><span class="line">    @Nullable Set&lt;String&gt; relativeUrlParamNames;</span><br><span class="line">    @Nullable ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">    boolean isKotlinSuspendFunction;</span><br><span class="line">    </span><br><span class="line">    Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      this.retrofit = retrofit;</span><br><span class="line">      this.method = method;</span><br><span class="line">      // 获取方法注解</span><br><span class="line">      this.methodAnnotations = method.getAnnotations();</span><br><span class="line">      // 获取方法参数类型</span><br><span class="line">      this.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      // 获取方法注解数组</span><br><span class="line">      this.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RequestFactory build() &#123;</span><br><span class="line">      // 遍历注解，对注解进行解析</span><br><span class="line">      for (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (httpMethod == null) &#123;</span><br><span class="line">        throw methodError(method, &quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!hasBody) &#123;</span><br><span class="line">        if (isMultipart) &#123;</span><br><span class="line">          throw methodError(method,</span><br><span class="line">              &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isFormEncoded) &#123;</span><br><span class="line">          throw methodError(method, &quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class="line">              + &quot;request body (e.g., @POST).&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      int parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        parameterHandlers[p] =</span><br><span class="line">            parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        throw methodError(method, &quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        throw methodError(method, &quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        throw methodError(method, &quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        throw methodError(method, &quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 返回一个RequestFactory对象</span><br><span class="line">      return new RequestFactory(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对注解进行解析</span><br><span class="line">    private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">      // 判断解析类型，根据注解的类型进行相应的解析</span><br><span class="line">      if (annotation instanceof DELETE) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof GET) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof HEAD) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof PATCH) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof POST) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof PUT) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof OPTIONS) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof HTTP) &#123;</span><br><span class="line">        HTTP http = (HTTP) annotation;</span><br><span class="line">        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">      &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">        if (headersToParse.length == 0) &#123;</span><br><span class="line">          throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        headers = parseHeaders(headersToParse);</span><br><span class="line">      &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">        if (isFormEncoded) &#123;</span><br><span class="line">          throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isMultipart = true;</span><br><span class="line">      &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">        if (isMultipart) &#123;</span><br><span class="line">          throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isFormEncoded = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //解析Http请求方法和路径</span><br><span class="line">    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 解析请求头</span><br><span class="line">    private Headers parseHeaders(String[] headers) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里没有把<code>RequestFactory</code>中所有的方法列出来，但是我们从上面的代码和注释中我们可以知道这个类都是做了哪些操作：</p><blockquote><p>1、创建一个<code>RequestFactory.Builder</code>对象，同时传入<code>Retrofit</code>对象和<code>Method</code>对象。<br> 2、创建完<code>RequestFactory.Builder</code>对象之后，会对<code>Method</code>对象的注解进行解析，解析的同时会对<code>Buidler</code>对象进行初始化。<br> 3、最后通过<code>build</code>方法，创建一个<code>RequestFactory</code>对象，并进行初始化。</p></blockquote><h4 id="HttpServiceMethod-parseAnnotations-retrofit-method-requestFactory"><a href="#HttpServiceMethod-parseAnnotations-retrofit-method-requestFactory" class="headerlink" title="HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)"></a>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</h4><p>在得到<code>RequestFactory</code>对象之后，会调用<code>HttpServiceMethod.parseAnnotations</code>方法，将获取的<code>RequestFactory</code>传入，我们看一下这里面都是做了什么操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Adapts an invocation of an interface method into an HTTP call. */</span><br><span class="line">// 将接口方法的调用调整为HTTP请求</span><br><span class="line">abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Inspects the annotations on an interface method to construct a reusable service method that</span><br><span class="line">   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service</span><br><span class="line">   * method only once and reuse it.</span><br><span class="line">   */</span><br><span class="line">  // 检查接口方法上的注释，以构造一个可重用的服务方法，该服务方法表示HTTP。</span><br><span class="line">  // 这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。</span><br><span class="line">  static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(</span><br><span class="line">      Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;</span><br><span class="line">    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    boolean continuationWantsResponse = false;</span><br><span class="line">    boolean continuationBodyNullable = false;</span><br><span class="line"></span><br><span class="line">    // 获得所有方法上的所有注解</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    // 方法返回值类型</span><br><span class="line">    Type adapterType;</span><br><span class="line">    // 是否是kotlin挂起函数</span><br><span class="line">    if (isKotlinSuspendFunction) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 获取方法返回类型</span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 1、获取CallAdapter对象</span><br><span class="line">    // 根据之前的分析，这里获得的是DefaultCallAdapterFactory</span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">    // 校验返回类型是否正确</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    // 返回类型不能为okhttp3.Response类型</span><br><span class="line">    if (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;&apos;&quot;</span><br><span class="line">          + getRawType(responseType).getName()</span><br><span class="line">          + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回类型不能是Response，必须要包含泛型才行,类似于Response&lt;String&gt;</span><br><span class="line">    if (responseType == Response.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO support Unit for Kotlin?</span><br><span class="line">    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">      throw methodError(method, &quot;HEAD method must use Void as response type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2、获得Converter对象</span><br><span class="line">    // 由于我们设置了GsonConverterFactory，所以这里获得的是GsonConverterFactory对象</span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        </span><br><span class="line">    // 获取一个okhttp3.Call.Factory对象，其实就是一个OkHttpClient对象</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    if (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; else if (continuationWantsResponse) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(</span><br><span class="line">      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 4、从retrofit中根据returnType和annotations获取CallAdapter</span><br><span class="line">      return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw methodError(method, e, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(</span><br><span class="line">      Retrofit retrofit, Method method, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    try &#123;</span><br><span class="line">      // 5、从retrofit中根据responseType和annotations获取Converter</span><br><span class="line">      return retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw methodError(method, e, &quot;Unable to create converter for %s&quot;, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final class Retrofit &#123;</span><br><span class="line">...</span><br><span class="line">  // 创建CallAdapter对象</span><br><span class="line">  public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    // 调用nextCallAdapter传入skipPast、returnType、annotations</span><br><span class="line">    // 注意：这里传入的skipPast为null</span><br><span class="line">    return nextCallAdapter(null, returnType, annotations);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    // 检查一下returnType和annotations是否为null</span><br><span class="line">    checkNotNull(returnType, &quot;returnType == null&quot;);</span><br><span class="line">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class="line">    </span><br><span class="line">    // 这里找到callAdapterFactories集合的起始位置</span><br><span class="line">    // 由于skipPast为null所以获得的index为-1，然后加上1，起始位置还是0</span><br><span class="line">    // 开始遍历集合</span><br><span class="line">    int start = callAdapterFactories.indexOf(skipPast) + 1;</span><br><span class="line">    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      // 我们在分析CallAdapter.Factory时知道，调用get方法表示了，</span><br><span class="line">      // 判断returnType是否是该CallAdapter.Factory支持的类型</span><br><span class="line">      // 如果不支持将会返回null</span><br><span class="line">      // 反之会返回对应的CallAdapter.Factory</span><br><span class="line">      // 由于没有额外设置，所以这里返回的是DefaultCallAdapterFactory</span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);</span><br><span class="line">      // 如果有直接返回</span><br><span class="line">      if (adapter != null) &#123;</span><br><span class="line">        return adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 到这里说明没有对应的CallAdapter.Factory</span><br><span class="line">    // 拼接错误信息</span><br><span class="line">    StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</span><br><span class="line">        .append(returnType)</span><br><span class="line">        .append(&quot;.\n&quot;);</span><br><span class="line">    if (skipPast != null) &#123;</span><br><span class="line">      builder.append(&quot;  Skipped:&quot;);</span><br><span class="line">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class="line">        builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(&apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(&quot;  Tried:&quot;);</span><br><span class="line">    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    throw new IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // 创建Converter对象</span><br><span class="line">  public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    // 调用nextResponseBodyConverter传入skipPast、returnType、annotations</span><br><span class="line">    // 注意：这里传入的skipPast为null</span><br><span class="line">    return nextResponseBodyConverter(null, type, annotations);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class="line">      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class="line">    // 检查一下returnType和annotations是否为null</span><br><span class="line">    checkNotNull(type, &quot;type == null&quot;);</span><br><span class="line">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class="line">    // 这里找到converterFactories集合的起始位置</span><br><span class="line">    // 由于skipPast为null所以获得的index为-1，然后加上1，起始位置还是0</span><br><span class="line">    // 开始遍历集合</span><br><span class="line">    int start = converterFactories.indexOf(skipPast) + 1;</span><br><span class="line">    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      // 我们在分析Converter.Factory时知道，调用responseBodyConverter方法表示了，</span><br><span class="line">      // 判断能否将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">      // 如果不能直接返回null，</span><br><span class="line">      // 返回对应的Converter.Factory对象,我们之前设置的是GsonConverterFactory，所以这里返回的是GsonConverterFactory</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, this);</span><br><span class="line">      if (converter != null) &#123;</span><br><span class="line">        // 如果有直接返回</span><br><span class="line">        return (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 到这里说明没有对应的Converter.Factory</span><br><span class="line">    // 拼接错误信息</span><br><span class="line">    StringBuilder builder = new StringBuilder(&quot;Could not locate ResponseBody converter for &quot;)</span><br><span class="line">        .append(type)</span><br><span class="line">        .append(&quot;.\n&quot;);</span><br><span class="line">    if (skipPast != null) &#123;</span><br><span class="line">      builder.append(&quot;  Skipped:&quot;);</span><br><span class="line">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class="line">        builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(&apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(&quot;  Tried:&quot;);</span><br><span class="line">    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    throw new IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里由于代码过长，所以我们分步分析，在上面代码中有<code>5处</code>比较重要的注释，首先看一下<code>注释1</code>和<code>注释2</code>，它们分别是用来获取<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>,分别对应了<code>注释4</code>和<code>注释5</code>处。<code>注释4</code>和<code>注释5</code>都是从<code>retrofit</code>对象中获取，具体的操作需要看上段代码的下半部分，最终获取的是<code>DefaultCallAdapterFactory</code>和<code>GsonConverterFactory</code>，具体流程已经在注释中给出。<br> 我们来看一下<code>注释3</code>处的操作,下面是<code>注释3</code>处的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;</span><br><span class="line">  static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(</span><br><span class="line">      Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;</span><br><span class="line">    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    ...</span><br><span class="line">    // 获取一个okhttp3.Call.Factory对象，其实就是一个OkHttpClient对象</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    if (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      // 新建一个CallAdapted对象，传入requestFactory、callFactory、responseConverter、callAdapter</span><br><span class="line">      // 最后返回出去</span><br><span class="line">      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; else if (continuationWantsResponse) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter) &#123;</span><br><span class="line">    this.requestFactory = requestFactory;</span><br><span class="line">    this.callFactory = callFactory;</span><br><span class="line">    this.responseConverter = responseConverter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override final @Nullable ReturnT invoke(Object[] args) &#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    // 这里首先找的是子类的adapt方法</span><br><span class="line">    // 因为创建的是CallAdapted，所以会调用CallAdapted的adapt放方法</span><br><span class="line">    return adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args);</span><br><span class="line">  </span><br><span class="line">  // CallAdapted继承自HttpServiceMethod</span><br><span class="line">  static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123;</span><br><span class="line">    private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line">    </span><br><span class="line">    // CallAdapted构造方法</span><br><span class="line">    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">      // 调用父类的构造方法，也就是HttpServiceMethod的构造方法</span><br><span class="line">      super(requestFactory, callFactory, responseConverter);</span><br><span class="line">      this.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class="line">      // 返回callAdapter.adapt的结果</span><br><span class="line">      return callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里我们需要把<code>注释3</code>处的过程捋一捋，由于这个过程跟之前的分析联系比较紧密，所以会有点绕：</p><blockquote><p>1、新建一个<code>CallAdapted</code>对象，传入<code>requestFactory</code>、<code>callFactory</code>、<code>responseConverter</code>、<code>callAdapter</code>。<br> 2、创建<code>CallAdapted</code>对象时调用其构造方法，由于它继承自<code>HttpServiceMethod</code>，又调用了<code>HttpServiceMethod</code>的构造方法，将参数传入。<br> 3、我们在之前的动态代理最后一步会调用<code>return loadServiceMethod(method).invoke(...)</code>方法之后，又回调用<code>HttpServiceMethod.adapt</code>方法。这个方法在<code>HttpServiceMethod</code>中属于抽象方法，所以最终会调用其子类<code>CallAdapted.adapt</code>方法。<br> 4、在<code>CallAdapted.adapt</code>的方法中会调用<code>callAdapter.adapt</code>方法，在分析<code>CallAdapte.Factory</code>时，我们知道这个方法是将<code>Call</code>对象转成代理类<code>T</code>。我们没有设置<code>CallAdapte.Factory</code>，所以使用的是<code>DefaultCallAdapterFactory</code>，所以又调用了<code>DefaultCallAdapterFactory</code>中的<code>adapt</code>方法,并将<code>OkHttpCall</code>传入了。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  private final @Nullable Executor callbackExecutor;</span><br><span class="line">  // 这个构造方法在Platform的Android子类中的defaultCallAdapterFactories方法中已经被调用。</span><br><span class="line">  DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</span><br><span class="line">    //callbackExecutor为MainThreadExecutor，也就是说会将响应回调到Android主线程去</span><br><span class="line">    this.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line">  // </span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    // 如果不是Call类型不予处理</span><br><span class="line">    if (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(returnType instanceof ParameterizedType)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">          &quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);</span><br><span class="line">    // 查看注解是否包含SkipCallbackExecutor类型，我们在使用时并没有使用SkipCallbackExecutor的注解</span><br><span class="line">    // 所以这里的executor不为null</span><br><span class="line">    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">        ? null</span><br><span class="line">        : callbackExecutor;</span><br><span class="line">    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override public Type responseType() &#123;</span><br><span class="line">        return responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">        // 判断executor是否为空，如果为空返回Call,这个call属于OkHttpCall</span><br><span class="line">        // 如果不为空返回ExecutorCallbackCall</span><br><span class="line">        return executor == null</span><br><span class="line">            ? call</span><br><span class="line">            : new ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于这里与之前的分析联系比较紧密，有些绕，一不小心就会被绕进去，所以还是分步分析。</p><blockquote><p>1、在<code>Platform</code>的子类<code>Android</code>中，已经创建了<code>DefaultCallAdapterFactory</code>对象，并且传入了<code>MainThreadExecutor</code>，这保证了响应会被回调到<code>Android</code>主线程。<br> 2、之前在获取<code>CallAdapter</code>类型的时候，已经调用了<code>DefaultCallAdapterFactory.get</code>方法，所以<code>executor</code>对象不为空，并且返回了一个匿名的<code>CallAdapter</code>对象。<br> 3、在上面我们调用<code>DefaultCallAdapterFactory.adapt</code>方法时，就是调用了这个匿名对象的<code>adapt</code>方法，这里返回的是<code>ExecutorCallbackCall</code>对象。也就是说我们在做网络请求时就是使用这个<code>ExecutorCallbackCall</code>对象。</p></blockquote><h2 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h2><p>我们在上面的分析中知道，其实是<code>ExecutorCallbackCall</code>对象进行网络请求，所以看一下它的源码。</p><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><p>同步请求的方法我们也在之前的举例给出，我们看一下源码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    // 构造方法传入callbackExecutor、Call</span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      // callbackExecutor属于MainThreadExecutor</span><br><span class="line">      this.callbackExecutor = callbackExecutor;</span><br><span class="line">      // delegate为OkHttpCall对象</span><br><span class="line">      this.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">      // delegate其实就是OkHttpCall对象</span><br><span class="line">      return delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    </span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line">      call = rawCall;</span><br><span class="line">      if (call == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // requestFactory根据args创建request对象</span><br><span class="line">          // 然后创建okhttp3.Call对象</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.</span><br><span class="line">          creationFailure = e;</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用okhttp3.Call对象进行请求，并将响应结果进行解析</span><br><span class="line">    return parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    // requestFactory根据args创建request对象</span><br><span class="line">    // 然后根据request对象创建一个okhttp3.Call对象</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回okhttp3.Call对象</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 对响应进行解析</span><br><span class="line">  Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</span><br><span class="line">    // 响应体</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line">        </span><br><span class="line">    // 获得响应码</span><br><span class="line">    int code = rawResponse.code();</span><br><span class="line">    // 根据响应码进行判断</span><br><span class="line">    if (code &lt; 200 || code &gt;= 300) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        // Buffer the entire body to avoid future I/O.</span><br><span class="line">        ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">        return Response.error(bufferedBody, rawResponse);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (code == 204 || code == 205) &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">      return Response.success(null, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    try &#123;</span><br><span class="line">      // 将响应体传入responseConverter对象也就是我们之前设置的GsonConverterFactory中去</span><br><span class="line">      // 将响应体转成对应的Java对象</span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      return Response.success(body, rawResponse);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      // If the underlying source threw an exception, propagate that rather than indicating it was</span><br><span class="line">      // a runtime exception.</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>同步请求的过程：</p><blockquote><p>1、<code>ExecutorCallbackCall</code>通过调用<code>excute</code>方法，调用了传入的<code>OkhttpCall</code>对象的<code>excute</code>方法。<br> 2、<code>OkhttpCall</code>的<code>excute</code>方法中，首先通过<code>requestFactory</code>根据<code>args</code>创建<code>request</code>对象，然后创建<code>okhttp3.Call</code>对象。<br> 3、调用<code>okhttp3.Call</code>的<code>excute</code>方法，获取响应。<br> 4、拿到响应后会根据响应码进行判断，通过判断后通过<code>responseConverter</code>对象将响应体转成对应的<code>Java</code>对象，并返回。</p></blockquote><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>关于异步请求的使用，在我们之前的举例中已经给出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    // callbackExecutor属于MainThreadExecutor</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line">    </span><br><span class="line">    // 异步请求</span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line">      // 根据同步请求我们知道delegate就是一个OkhttpCall对象</span><br><span class="line">      // 调用OkhttpCall.exqueue方法执行异步请求</span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        // 获取响应的回调</span><br><span class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">          // 进行线程切换</span><br><span class="line">          // callbackExecutor就是MainThreadExecutor，其内部是通过主线程的Handler将Runnable发送到主线程去</span><br><span class="line">          // 从而达到切换线程的效果</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              if (delegate.isCanceled()) &#123;</span><br><span class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 请求失败的回调</span><br><span class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          // 线程切换，原理同上</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  // 异步请求方法</span><br><span class="line">  @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">    checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      if (call == null &amp;&amp; failure == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 创建Call对象</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          failure = creationFailure = t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (failure != null) &#123;</span><br><span class="line">      callback.onFailure(this, failure);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    // 执行异步请求</span><br><span class="line">    call.enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 解析网络请求，过程和同步请求中一样</span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">          throwIfFatal(e);</span><br><span class="line">          callFailure(e);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          // 请求成功的回调</span><br><span class="line">          callback.onResponse(OkHttpCall.this, response);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          t.printStackTrace(); // TODO this is not great</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">        // 请求失败</span><br><span class="line">        callFailure(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      private void callFailure(Throwable e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 请求失败回调</span><br><span class="line">          callback.onFailure(OkHttpCall.this, e);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          t.printStackTrace(); // TODO this is not great</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    // requestFactory根据args创建一个request对象</span><br><span class="line">    // 将request对象分装成一个Call对象</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>异步请求中有一个重要的操作就是将请求结果通过主线程的<code>Handle</code>发送到主线程去，从而达到线程切换的效果。</p><h1 id="涉及的设计模式"><a href="#涉及的设计模式" class="headerlink" title="涉及的设计模式"></a>涉及的设计模式</h1><p>在源码分析的过程中，我们能发现<code>Retrofit</code>中运用了大量的设置模式，这样做的好处就是将代码进行封装，方便我们调用。这里面用到的设计模式包括：<code>构建者模式</code>、<code>单例模式</code>、<code>工厂模式</code>、<code>代理模式</code>、<code>外观模式</code>、<code>装饰模式</code>、<code>策略模式</code>、<code>适配器模式</code>。<br> 由于在之前的文章中已经提到了<code>构建者模式</code>、<code>单例模式</code>、<code>工厂模式</code>，所以这里不再多做陈述，但是我会给出它们在<code>Retrofit</code>中具体的出处。</p><blockquote><p>1、构建者模式：最明显的就是在最初创建<code>Retrofit</code>对象时调用的<code>new Retrofit.Builder().build()</code>。<br> 2、单例模式：在<code>Platform</code>类中获取<code>Plathform</code>对象时使用的就是单例模式，有关单例的几种写法和它们之间的区别还希望大家能够有所了解。<br> 3、工厂模式：最明显的是<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>，但是工厂模式中又有：<code>简单工厂</code>、<code>抽象工厂</code>和<code>工厂方法</code>，需要区分开来。</p></blockquote><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>说到代理模式，有静态代理和动态代理之分。在<code>Retrofit</code>中我们最初接触的是动态代理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    ...</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          ...</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里只有动态代理，那<code>Retrofit</code>中的静态代理在哪？在说静态代理之前要明白什么是静态代理：静态代理是指代理类在程序运行前已经存在的代理方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 这个delegate属于静态代理</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line">    </span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line">      </span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">          </span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              // 额外操作</span><br><span class="line">              if (delegate.isCanceled()) &#123;</span><br><span class="line">                ...</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>有关代理模式，在基础知识准备的时候已经给大家准备了几篇文章，这里就不再一一列出了。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServiceApi &#123;</span><br><span class="line">    @GET(&quot;wxarticle/chapters/json&quot;)</span><br><span class="line">    Call&lt;Bean&gt; getWxArtical();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceApi serviceApi = retrofit.create(ServiceApi.class);</span><br><span class="line">final Call&lt;Bean&gt; officialAccounts = serviceApi.getOfficialAccounts();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们在<code>HTTP API</code>接口中定义了很多方法，参数都在方法上进行定义，只会告诉调用者需要传入哪些参数，具体的操作并不向外暴露，这个就是外观设计模式。这里为到家准备了一篇<a href="https://juejin.im/post/5a37d48e518825256362c6e2">设计模式之外观模式</a>。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以将<code>ExecutorCallbackCall</code>看作是装饰类，但真正去执行请求的是OkHttpCall。之所以要有个装饰类，是希望做一些额外操作。这里的操作就是线程转换，将子线程切换到主线程上去。有关装饰设计模式，为大家准备了两篇文章： <a href="https://www.jianshu.com/p/427342d3b5c0">设计模式之死磕装饰器模式（原创）</a>、 <a href="https://www.jianshu.com/p/4a530a3c70af">装饰者模式</a>。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>简单的来说，策略模式就是做某些事情可能同时有多个方案，不同的时期使用不同的方案，怎样在调用的过程中尽可能的减少代码的修改，主要还是使用了<code>Java</code>中的多态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RxJava2CallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line"></span><br><span class="line">    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);</span><br><span class="line">    Class&lt;?&gt; rawObservableType = getRawType(observableType);</span><br><span class="line">    if (rawObservableType == Response.class) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else if (rawObservableType == Result.class) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在<code>RxJava2CallAdapterFactory</code>的<code>get</code>方法中使用了策略模式，这里会根据<code>rawObservableType</code>的类型，作出对应的操作，如果感兴趣的小伙伴可以到源码里面看一下。<br> 有关策略模式这里为大家准备了一篇文章：<a href="https://juejin.im/post/57d65eac7db2a200684109dc">LOL设计模式之「策略模式」</a>。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>我们在看<code>Retrofit</code>源码时，有可能在分析<code>CallAdapter</code>时被搞的晕头转向。如果从适配器的概念上来讲，就是将一个已经存在的东西，转成适合使用的东西。最常见的场景就是出国游玩的时候由于电源接口标准的不同，我们需要带一个转换头。<br> 回头看<code>Retrofit</code>，如果我们一直时在<code>Android</code>上使用，那就需要通过静态代理<code>ExecutorCallbackCall</code>来切换线程，但是后来出现了新的技术<code>Rxjava</code>，感觉还挺好用的，不需要通过<code>Handler</code>进行线程切换了。这时就需要转换一下，将将<code>OkHttpCall</code>转换成<code>rxjava(Scheduler)</code>的写法，大概就是这么一个套路。<br> 关于适配器模式，也给大家准备了一篇文章：<a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们已经把<code>Retrofit</code>的源码分析了一遍， 这里还是建议大家自己跟着源码走一遍，毕竟纸上得来终觉浅。最后还是那句话，本人是一名<code>Android</code>小学生，文中如有不妥之处还望各位不吝赐教，本人将不胜感激。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant Retrofitparticipant Builderparticipant Platformparticipant GsonConverterFactoryBuilder -> Platform: Builder(Platform platform)Platform -> Platform: get()Builder -> Builder: baseUrl(String url)Builder -> GsonConverterFactory: addConverterFactory()GsonConverterFactory -> GsonConverterFactory: create()Builder -> Retrofit: build()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;h5 id
      
    
    </summary>
    
      <category term="源码分析" scheme="http://daijinlin.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Retrofit 网络 源码" scheme="http://daijinlin.com/tags/Retrofit-%E7%BD%91%E7%BB%9C-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动过程分析(从Launcher启动)</title>
    <link href="http://daijinlin.com/2017/02/21/%E4%BB%8ELaucher%E5%90%AF%E5%8A%A8Activity%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://daijinlin.com/2017/02/21/从Laucher启动Activity过程分析/</id>
    <published>2017-02-21T08:53:46.000Z</published>
    <updated>2019-12-20T17:20:23.053Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>在Android系统中，Activity是应用程序的四大组件之一，在开发Android应用时无时无刻都在使用它们。但是它们的启动过程是怎么样的？Activity的什么周期方法到底是怎么被执行？本篇将结合源码（7.0.0_r1）进行分析。<br><a id="more"></a></p><p>先来看看启动调用的时序图<br><img src="http://ooackh347.bkt.clouddn.com/UML_%E4%BB%8ELaucher%E5%90%AF%E5%8A%A8Activity%E8%BF%87%E7%A8%8B.png" alt=""></p><p>源码:<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, <span class="title">OnLongClickListener</span>, <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>,<span class="title">View</span>.<span class="title">OnTouchListener</span>, <span class="title">PageSwitchListener</span>, <span class="title">LauncherProviderChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Launches the intent referred by the clicked shortcut.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v The view representing the clicked shortcut.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...省略代码专用...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Workspace) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">                showWorkspace(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> CellLayout) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">                showWorkspace(mWorkspace.indexOfChild(v), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object tag = v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">            onClickAppShortcut(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> FolderInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> FolderIcon) &#123;</span><br><span class="line">                onClickFolderIcon(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == mAllAppsButton) &#123;</span><br><span class="line">            onClickAllAppsButton(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> AppInfo) &#123;</span><br><span class="line">            startAppShortcutOrInfoActivity(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PendingAppWidgetHostView) &#123;</span><br><span class="line">                onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Android</code>中桌面的应用程序都是由<code>Launcher</code>启动的，其中<code>Launcher</code>本身也是一个应用，当应用程序安装完成后都会在桌面创建相应的应用程序图标，点击这个图标，<code>Launcher</code>就会将其启动起来。桌面其实用了一个<code>RecyclerView</code>来构建，具体请看<code>AllAppsContainerView</code>源码。当我们点击图标的时候，则直接执行<code>onClickAppShortcut</code>方法，来看其代码</p><p>源码:<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Event handler for an app shortcut click.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v The view that was clicked. Must be a tagged with a &#123;<span class="doctag">@link</span> ShortcutInfo&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onClickAppShortcut</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open shortcut</span></span><br><span class="line">    <span class="keyword">final</span> ShortcutInfo shortcut = (ShortcutInfo) tag;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for abandoned promise</span></span><br><span class="line">    <span class="keyword">if</span> ((v <span class="keyword">instanceof</span> BubbleTextView)</span><br><span class="line">            &amp;&amp; shortcut.isPromise()</span><br><span class="line">            &amp;&amp; !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) &#123;</span><br><span class="line">        showBrokenAppInstallDialog(</span><br><span class="line">                shortcut.getTargetComponent().getPackageName(),</span><br><span class="line">                <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">                        startAppShortcutOrInfoActivity(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start activities</span></span><br><span class="line">    startAppShortcutOrInfoActivity(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mLauncherCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLauncherCallbacks.onClickAppShortcut(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释可以看到调用了<code>startAppShortcutOrInfoActivity</code>方法，继续来看</p><p>源码:<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Thunk</span> <span class="function"><span class="keyword">void</span> <span class="title">startAppShortcutOrInfoActivity</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = startActivitySafely(v, intent, tag);</span><br><span class="line">    mStats.recordLaunch(v, intent, shortcut);</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用的是<code>startActivitySafely</code>方法。</p><p>源码:<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        success = startActivity(v, intent, tag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Log.e(TAG, <span class="string">"Unable to launch. tag="</span> + tag + <span class="string">" intent="</span> + intent, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部调用的就是<code>startActivity</code>方法。</p><p>源码:<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        ...省略代码专用...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(UserHandleCompat.myUserHandle())) &#123;</span><br><span class="line">            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Temporarily disable deathPenalty on all default checks. For eg, shortcuts</span></span><br><span class="line">                <span class="comment">// containing file Uris would cause a crash as penaltyDeathOnFileUriExposure</span></span><br><span class="line">                <span class="comment">// is enabled by default on NYC.</span></span><br><span class="line">                StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder().detectAll()</span><br><span class="line">                        .penaltyLog().build());</span><br><span class="line">                <span class="comment">// Could be launching some bookkeeping activity</span></span><br><span class="line">                startActivity(intent, optsBundle); <span class="comment">// ②</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                StrictMode.setVmPolicy(oldPolicy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TODO Component can be null when shortcuts are supported for secondary user</span></span><br><span class="line">            launcherApps.startActivityForProfile(intent.getComponent(), user,</span><br><span class="line">                    intent.getSourceBounds(), optsBundle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        ...省略代码专用...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处可以看出新开的<code>Activity</code>是在新的任务栈里面。注释2处调用<code>Activity</code>的<code>startActivity</code>方法</p><p>源码:<code>frameworks/base/core/java/android/app/Activity.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">        <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码:<code>frameworks/base/core/java/android/app/Activity.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        ...省略代码专用...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...省略代码专用...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mParent</code>是<code>Activity</code>类型的成员变量，表示当前<code>Activity</code>的父类。因为目前根<code>Activity</code>还没有创建出来，则<code>mParent == null</code>成立。接着调用<code>Instrumentation</code>的<code>execStartActivity</code>方法。<code>execStartActivity</code>方法的代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/Instrumentation.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用<code>ActivityManagerNative</code>的<code>getDefault</code>来获取<code>ActivityManageService</code>（后续简称为AMS)的代理对象，接着调用它的<code>startActivity</code>方法。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve the system's default/global activity manager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>); <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b); <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>getDefault</code>方法调用了<code>gDefault</code>的<code>get</code>方法，我们接着往下看，<code>gDefault</code>是一个单例<code>Singleton</code>。注释1处得到名为<code>”activity”</code>的<code>Service</code>代理对象，实质就是<code>ActivityManagerService</code>的代理对象。接着在注释2处将它封装成<code>ActivityManagerProxy</code>(以后简称为AMP)类型对象，并将它保存到<code>gDefault</code>中，此后调用<code>ActivityManagerNative</code>的<code>getDefault</code>方法就会直接获得AMS的代理AMP对象。<br>回到Instrumentation类的execStartActivity方法中，从上面得知就是调用AMP的startActivity，其中AMP是ActivityManagerNative的内部类，代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityManagerNative.java$ActivityManagerProxy</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeStrongBinder(resultTo);</span><br><span class="line">    data.writeString(resultWho);</span><br><span class="line">    data.writeInt(requestCode);</span><br><span class="line">    data.writeInt(startFlags);</span><br><span class="line">    <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        data.writeInt(<span class="number">1</span>);</span><br><span class="line">        profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        data.writeInt(<span class="number">1</span>);</span><br><span class="line">        options.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>); <span class="comment">// ①</span></span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会将传入的参数写入到<code>Parcel</code>类型的<code>data</code>中。在注释1处通过<code>IBinder</code>对象<code>mRemote</code>向AMS发送一个<code>START_ACTIVITY_TRANSACTION</code>类型的进程间通信请求。那么服务端AMS就会从<code>Binder</code>线程池中读取我们客户端发来的数据，最终会调用<code>ActivityManagerNative</code>的<code>onTransact</code>方法中执行，如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">        String callingPackage = data.readString();</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line">        IBinder resultTo = data.readStrongBinder();</span><br><span class="line">        String resultWho = data.readString();</span><br><span class="line">        <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">        <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">        ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        Bundle options = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTransact</code>中会调用AMS的<code>startActivity</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">         Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">             resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">             UserHandle.getCallingUserId());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>AMS的<code>startActivity</code>方法中直接返回了<code>startActivityAsUser</code>方法：</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivityAsUser</code>方法中又返回了<code>mActivityStarter</code>的<code>startActivityMayWait</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">         String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">         IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">         IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">         ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">         Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">         IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">     ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">             aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">             resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">             callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">             options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">             inTask);</span><br><span class="line">             </span><br><span class="line">     ...省略代码专用...</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部又调用了<code>startActivityLocked</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">       String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">       IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">       IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">       String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">       ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">       ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">       TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivityLocked</code>函数代码非常多，我们只需要关注<code>doPendingActivityLaunchesLocked</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPendingActivityLaunchesLocked</span><span class="params">(<span class="keyword">boolean</span> doResume)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">final</span> PendingActivityLaunch pal = mPendingActivityLaunches.remove(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> result = startActivityUnchecked(</span><br><span class="line">                   pal.r, pal.sourceRecord, <span class="keyword">null</span>, <span class="keyword">null</span>, pal.startFlags, resume, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           postStartActivityUncheckedProcessing(</span><br><span class="line">                   pal.r, result, mSupervisor.mFocusedStack.mStackId, mSourceRecord,</span><br><span class="line">                   mTargetStack);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Slog.e(TAG, <span class="string">"Exception during pending activity launch pal="</span> + pal, e);</span><br><span class="line">           pal.sendErrorResult(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着又调用<code>startActivityUnchecked</code>方法：</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">       IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">   ...省略代码专用...  </span><br><span class="line"> </span><br><span class="line">   mSupervisor.resumeFocusedStackTopActivityLocked(); </span><br><span class="line">     </span><br><span class="line">   ...省略代码专用... </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivityUnchecked</code>方法中调用了<code>ActivityStackSupervisor</code>类型的<code>mSupervisor</code>的<code>resumeFocusedStackTopActivityLocked</code>方法，如下所示。<br>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">       <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">   <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">       mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// ①</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1处又调用了<code>ActivityStack</code>类型<code>mFocusedStack</code>的<code>resumeTopActivityUncheckedLocked</code>方法：</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        ...省略代码专用...</span><br><span class="line">       </span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着查看<code>ActivityStack</code>的<code>resumeTopActivityInnerLocked</code>方法：</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked();</span><br><span class="line">        </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ...省略代码专用...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">       ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">       mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resumeTopActivityInnerLocked</code>方法代码非常多，我们只需要关注调用了<code>ActivityStackSupervisor</code>类型<code>mStackSupervisor</code>的<code>startSpecificActivityLocked</code>方法，代码如下所示。<br>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">  ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">          r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">  r.task.stack.setLaunchTime(r);</span><br><span class="line">  <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                  || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">              app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                      mService.mProcessStats);</span><br><span class="line">          &#125;</span><br><span class="line">          realStartActivityLocked(r, app, andResume, checkConfig);<span class="comment">//2</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">          Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                  + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">          <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1处如果当前<code>Activity</code>所在的<code>Application</code>运行的话，会执行注释2处的代码。<code>realStartActivityLocked</code>方法的代码如下所示。</p><p>源码:<code>frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          </span><br><span class="line">   ...省略代码专用...</span><br><span class="line">   </span><br><span class="line">      app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">              System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">              <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">              task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">              newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">              </span><br><span class="line">  ...省略代码专用...      </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>app.thread</code>指的是<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>，其中<code>ApplicationThread</code>继承了<code>ApplicationThreadNative</code>，而<code>ApplicationThreadNative</code>继承了<code>Binder</code>并实现了<code>IApplicationThread</code>接口。在应用程序进程启动时会创建<code>ActivityThread</code>实例。<code>ActivityThread</code>作为应用程序进程的核心类，它是如何启动应用程序<code>Activity</code>的呢？接着往下看。接着查看<code>ApplicationThread</code>的<code>scheduleLaunchActivity</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityThread.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"> updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    r.voiceInteractor = voiceInteractor;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line">    r.persistentState = persistentState;</span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line">    r.profilerInfo = profilerInfo;</span><br><span class="line">    r.overrideConfig = overrideConfig;</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scheduleLaunchActivity</code>方法会将启动<code>Activity</code>的参数封装成<code>ActivityClientRecord</code>，再将<code>ActivityClientRecord</code>通过<code>sendMessage</code>方法向应用进程的主线程发送类型为<code>LAUNCH_ACTIVITY</code>的消息，<code>sendMessage</code>方法的代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityThread.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...省略代码专用...</span><br><span class="line"></span><br><span class="line">  mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>mH</code>指的是<code>H</code>，它是<code>ActivityThread</code>的内部类并继承<code>Handler</code>，<code>H</code>的代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityThread.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAUNCH_ACTIVITY         = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAUSE_ACTIVITY          = <span class="number">101</span>;</span><br><span class="line">      </span><br><span class="line">...省略代码专用...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">          <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">              <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">                  <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;<span class="comment">//1</span></span><br><span class="line">                  r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                          r.activityInfo.applicationInfo, r.compatInfo);<span class="comment">//2</span></span><br><span class="line">                  handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);<span class="comment">//3</span></span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">              &#125; <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">                  ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">                  handleRelaunchActivity(r);</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">              &#125; <span class="keyword">break</span>;</span><br><span class="line">              </span><br><span class="line">            ...省略代码专用...</span><br><span class="line">            </span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>查看<code>H</code>的<code>handleMessage</code>方法中对<code>LAUNCH_ACTIVITY</code>的处理，在注释1处将传过来的<code>msg</code>的成员变量<code>obj</code>转换为<code>ActivityClientRecord</code>。<br>在注释2处通过<code>getPackageInfoNoCheck</code>方法获得<code>LoadedApk</code>类型的对象并赋值给<code>ActivityClientRecord</code>的成员变量<code>packageInfo</code>。应用程序进程要启动<code>Activity</code>时需要将该<code>Activity</code>所属的APK加载进来，而<code>LoadedApk</code>就是用来描述已加载的APK文件。<br>在注释3处调用<code>handleLaunchActivity</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityThread.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">  Activity a = performLaunchActivity(r, customIntent);<span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">      r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">      reportSizeConfigurations(r);</span><br><span class="line">      Bundle oldState = r.state;</span><br><span class="line">      handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">              !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); <span class="comment">// ①</span></span><br><span class="line">      <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;      </span><br><span class="line">          performPauseActivityIfNeeded(r, reason);</span><br><span class="line">          <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">              r.state = oldState;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ActivityManagerNative.getDefault()</span><br><span class="line">              .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                      Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的<code>performLaunchActivity</code>方法用来启动<code>Activity</code> ，注释2处的代码用来将<code>Activity</code>的状态置为<code>Resume</code>。如果该<code>Activity</code>为<code>null</code>则会通知<code>ActivityManager</code>停止启动<code>Activity</code>。来查看<code>performLaunchActivity</code>方法做了什么：</p><p>源码:<code>frameworks/base/core/java/android/app/ActivityThread.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">    ActivityInfo aInfo = r.activityInfo; <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                 Context.CONTEXT_INCLUDE_CODE); <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = r.intent.getComponent(); <span class="comment">// ③</span></span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent); <span class="comment">// ④</span></span><br><span class="line">                </span><br><span class="line">        ...省略代码专用...</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">        ...省略代码专用...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation); <span class="comment">// ⑤</span></span><br><span class="line">        </span><br><span class="line">        ...省略代码专用...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Context appContext = createBaseContextForActivity(r, activity); <span class="comment">// ⑥</span></span><br><span class="line">               </span><br><span class="line">        ...省略代码专用...</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">               <span class="comment">// ⑦</span></span><br><span class="line">               activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                     r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line">                    </span><br><span class="line">          ...省略代码专用...</span><br><span class="line">          </span><br><span class="line">              <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                  mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<span class="comment">//8</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              ...省略代码专用...</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处用来获取<code>ActivityInfo</code>，在注释2处获取APK文件的描述类<code>LoadedApk</code>。注释3处获取要启动的<code>Activity</code>的<code>ComponentName</code>类，<code>ComponentName</code>类中保存了该<code>Activity</code>的包名和类名。注释4处根据<code>ComponentName</code>中存储的<code>Activity</code>类名，用类加载器来创建该<code>Activity</code>的实例。注释5处用来创建<code>Application</code>，<code>makeApplication</code>方法内部会调用<code>Application</code>的<code>onCreate</code>方法。注释6处用来创建要启动<code>Activity</code>的上下文环境。注释7处调用<code>Activity</code>的attach方法初始化<code>Activity</code>，<code>attach</code>方法中会创建<code>Window</code>对象（<code>PhoneWindow</code>）并与<code>Activity</code>自身进行关联。注释8处会调用<code>Instrumentation</code>的<code>callActivityOnCreate</code>方法来启动<code>Activity</code>：</p><p>源码:<code>frameworks/base/core/java/android/app/Instrumentation.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">         PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle, persistentState); <span class="comment">// ①</span></span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处调用了<code>Activity</code>的<code>performCreate</code>方法，代码如下所示。</p><p>源码:<code>frameworks/base/core/java/android/app/Activity.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performCreate</code>方法中会调用<code>Activity</code>的<code>onCreate</code>方法，这样<code>Activity</code>就启动了，即应用程序就启动了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;在Android系统中，Activity是应用程序的四大组件之一，在开发Android应用时无时无刻都在使用它们。但是它们的启动过程是怎么样的？Activity的什么周期方法到底是怎么被执行？本篇将结合源码（7.0.0_r1）进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://daijinlin.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Activity启动过程" scheme="http://daijinlin.com/tags/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法之二分查找</title>
    <link href="http://daijinlin.com/2017/02/12/algorithm-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://daijinlin.com/2017/02/12/algorithm-二分查找/</id>
    <published>2017-02-12T08:12:15.000Z</published>
    <updated>2017-04-12T08:24:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br><a id="more"></a></p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><img src="/res/algorithm/Binary_search_into_array.png" alt="二分查找"></p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">搜索算法</td><td style="text-align:center">数组</td><td style="text-align:center">O(log n)</td><td style="text-align:center">О(1)</td><td style="text-align:center">O(log n)</td><td style="text-align:center">迭代：O(1), 递归：O(log n)</td></tr></tbody></table><h4 id="代码范例"><a href="#代码范例" class="headerlink" title="代码范例"></a>代码范例</h4><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, start, mid - <span class="number">1</span>, khey);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, mid + <span class="number">1</span>, end, khey);</span><br><span class="line">    <span class="keyword">return</span> mid; <span class="comment">//最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arr,start,end,hkey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; hkey:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, start, mid - <span class="number">1</span>, hkey)</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &lt; hkey:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, mid + <span class="number">1</span>, end, hkey)</span><br><span class="line">    <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.binary_search = <span class="function"><span class="keyword">function</span>(<span class="params">low, high, khey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[mid] &gt; khey)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.binary_search(low, mid - <span class="number">1</span>, khey);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[mid] &lt; khey)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.binary_search(mid + <span class="number">1</span>, high, khey);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a><br>    折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。（n代表集合中元素的个数）<br><a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a><br>    О(1)。虽以递归形式定义，但是尾递归，可改写为循环。</p><p>参考：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。&lt;br&gt;
    
    </summary>
    
      <category term="二分查找" scheme="http://daijinlin.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="算法" scheme="http://daijinlin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之插入排序</title>
    <link href="http://daijinlin.com/2017/01/29/algorithm-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://daijinlin.com/2017/01/29/algorithm-插入排序/</id>
    <published>2017-01-29T10:10:13.000Z</published>
    <updated>2017-04-05T09:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br><a id="more"></a></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="/res/algorithm/Insertion_sort_animation.gif" alt="插入排序"></p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center">数组</td><td style="text-align:center">О(n²)</td><td style="text-align:center">О(n)</td><td style="text-align:center">О(n²)</td><td style="text-align:center">总共О(n), 辅助空间 O(1)</td></tr></tbody></table><p>使用插入排序为一列数字进行排序的过程<br><img src="/res/algorithm/220px-Insertion-sort-example-300px.gif" alt="插入排序"></p><h4 id="代码范例"><a href="#代码范例" class="headerlink" title="代码范例"></a>代码范例</h4><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    temp = arr[i]; </span><br><span class="line">    <span class="comment">//與已排序的數逐一比較，大於temp時，該數向後移</span></span><br><span class="line">    j = i - <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// 如果将赋值放到下一行的for循环内, 会导致在第10行出现j未声明的错误</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--) &#123;</span><br><span class="line">        <span class="comment">//j循环到-1时，由于[[短路求值]](http://zh.wikipedia.org/wiki/短路求值)，不会运算array[-1]</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp; </span><br><span class="line">    <span class="comment">//被排序数放到正确的位置</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    n=len(lst)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> lst</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[j<span class="number">-1</span>] : lst[j], lst[j<span class="number">-1</span>] = lst[j<span class="number">-1</span>], lst[j]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h4 id="Python的另一个版本"><a href="#Python的另一个版本" class="headerlink" title="Python的另一个版本"></a>Python的另一个版本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">        temp = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> temp &lt; lst[j]:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j-<span class="number">1</span>] &lt;= arr[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java的另一个版本"><a href="#Java的另一个版本" class="headerlink" title="Java的另一个版本"></a>Java的另一个版本</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将arr[i] 插入到arr[0]...arr[i - 1]中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;  </span><br><span class="line">        <span class="comment">//如果将赋值放到下一行的for循环内, 会导致在第13行出现j未声明的错误</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-- ) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.insertion_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.splice(j, <span class="number">0</span>, <span class="keyword">this</span>[i]);</span><br><span class="line">                <span class="keyword">this</span>.splice(i+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion_sort</span><span class="params">(&amp;$arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//php的陣列視為基本型別，所以必須用傳參考才能修改原陣列</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; count($arr); $i++) &#123;</span><br><span class="line">         $temp = $arr[$i];</span><br><span class="line">         <span class="keyword">for</span> ($j = $i - <span class="number">1</span>; $j &gt;= <span class="number">0</span> &amp;&amp; $arr[$j] &gt; $temp; $j--)</span><br><span class="line">         $arr[$j + <span class="number">1</span>] = $arr[$j];</span><br><span class="line">         $arr[$j + <span class="number">1</span>] = $temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需<code>(n-1)</code>次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有<code>n(n-1)/2</code>次。插入排序的赋值操作是比较操作的次数加上<code>(n-1)</code>次。平均来说插入排序算法复杂度为<code>О(n²)</code>。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><p>参考：<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;br&gt;
    
    </summary>
    
      <category term="插入排序" scheme="http://daijinlin.com/categories/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://daijinlin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之选择排序</title>
    <link href="http://daijinlin.com/2017/01/29/algorithm-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://daijinlin.com/2017/01/29/algorithm-选择排序/</id>
    <published>2017-01-29T09:50:43.000Z</published>
    <updated>2017-04-12T08:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br><a id="more"></a></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="/res/algorithm/Selection_sort_animation.gif" alt="选择排序"></p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">选择排序</td><td style="text-align:center">数组</td><td style="text-align:center">О(n²)</td><td style="text-align:center">О(n²)</td><td style="text-align:center">О(n²)</td><td style="text-align:center">总共О(n), 辅助空间 O(1)</td></tr></tbody></table><h4 id="代码范例"><a href="#代码范例" class="headerlink" title="代码范例"></a>代码范例</h4><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">                min = j;</span><br><span class="line">        temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    N = len(L)</span><br><span class="line">    exchanges_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">if</span> L[min_index] &gt; L[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            L[min_index], L[i] = L[i], L[min_index]</span><br><span class="line">            exchanges_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'iteration #&#123;&#125;: &#123;&#125;'</span>.format(i, L))</span><br><span class="line">    print(<span class="string">'Total &#123;&#125; swappings'</span>.format(exchanges_count))</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">17</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">81</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">print(<span class="string">'Before selection sort: &#123;&#125;'</span>.format(testlist))</span><br><span class="line">print(<span class="string">'After selection sort:  &#123;&#125;'</span>.format(selection_sort(testlist)))</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min, temp, len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">                min = j;</span><br><span class="line">        temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selection_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, min;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="keyword">this</span>.length; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[min] &gt; <span class="keyword">this</span>[j])</span><br><span class="line">                min = j;</span><br><span class="line">        temp = <span class="keyword">this</span>[min];</span><br><span class="line">        <span class="keyword">this</span>[min] = <span class="keyword">this</span>[i];</span><br><span class="line">        <span class="keyword">this</span>[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$x, &amp;$y)</span> </span>&#123;</span><br><span class="line">    $t = $x;</span><br><span class="line">    $x = $y;</span><br><span class="line">    $y = $t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection_sort</span><span class="params">(&amp;$arr)</span> </span>&#123;<span class="comment">//php的陣列視為基本型別，所以必須用傳參考才能修改原陣列</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr) - <span class="number">1</span>; $i++) &#123;</span><br><span class="line">        $min = $i;</span><br><span class="line">        <span class="keyword">for</span> ($j = $i + <span class="number">1</span>; $j &lt; count($arr); $j++)</span><br><span class="line">            <span class="keyword">if</span> ($arr[$min] &gt; $arr[$j])</span><br><span class="line">                $min = $j;</span><br><span class="line">        swap($arr[$min], $arr[$i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>选择排序的交换操作介于 <code>0</code>和 <code>(n-1)</code>次之间。选择排序的比较操作为 <code>n(n-1)/2</code>次之间。选择排序的赋值操作介于 <code>0</code>和 <code>3(n-1)</code>次之间。<br>比较次数 <code>О(n²)</code>，比较次数与关键字的初始状态无关，总的比较次数<code>N=(n-1)+(n-2)+...+1=n * (n-1)/2</code>。交换次数<code>O(n)</code>，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换<code>n-1</code>次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，<code>n</code>值较小时，选择排序比冒泡排序快。<br>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><p>参考：<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;br&gt;
    
    </summary>
    
      <category term="选择排序" scheme="http://daijinlin.com/categories/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://daijinlin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之冒泡排序</title>
    <link href="http://daijinlin.com/2017/01/29/algorithm-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://daijinlin.com/2017/01/29/algorithm-冒泡排序/</id>
    <published>2017-01-29T07:50:50.000Z</published>
    <updated>2017-04-05T09:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><a id="more"></a></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><img src="/res/algorithm/Bubble_sort_animation.gif" alt="冒泡排序"></p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">交换排序</td><td style="text-align:center">数组</td><td style="text-align:center">О(n²)</td><td style="text-align:center">О(n)</td><td style="text-align:center">О(n²)</td><td style="text-align:center">总共О(n), 辅助空间 O(1)</td></tr></tbody></table><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubble_sort (array, length) &#123;</span><br><span class="line">    var i, j;</span><br><span class="line">    for(i from 0 to length-1)&#123;</span><br><span class="line">        for(j from 0 to length-1-i)&#123;</span><br><span class="line">            if (array[j] &gt; array[j+1])</span><br><span class="line">                swap(array[j], array[j+1])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数 冒泡排序 输入 一个数组名称为array 其长度为length </span><br><span class="line">    i 从 0 到 (length - 1) </span><br><span class="line">        j 从 0 到 (length - 1 - i) </span><br><span class="line">            如果 array[j] &gt; array[j + 1] </span><br><span class="line">                交换 array[j] 和 array[j + 1] 的值 </span><br><span class="line">            如果结束 </span><br><span class="line">        j循环结束 </span><br><span class="line">    i循环结束 </span><br><span class="line">函数结束</span><br></pre></td></tr></table></figure><h4 id="助记码"><a href="#助记码" class="headerlink" title="助记码"></a>助记码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i∈[0,N-1)                //循环N-1遍</span><br><span class="line">  j∈[0,N-1-i)            //每遍循环要处理的无序部分</span><br><span class="line">    swap(j,j+1)          //两两排序（升序/降序）</span><br></pre></td></tr></table></figure><p><img src="/res/algorithm/Bubble_sort.jpg" alt="冒泡排序助记图"></p><h4 id="代码范例"><a href="#代码范例" class="headerlink" title="代码范例"></a>代码范例</h4><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(List)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(List) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">            <span class="keyword">if</span> List[i] &gt; List[i+<span class="number">1</span>]:</span><br><span class="line">                List[i], List[i+<span class="number">1</span>] = List[i+<span class="number">1</span>], List[i]</span><br><span class="line">    <span class="keyword">return</span> List</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size-<span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; size-<span class="number">1</span>-i ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[j] &gt; numbers[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = numbers[j];</span><br><span class="line">                numbers[j] = numbers[j+<span class="number">1</span>];</span><br><span class="line">                numbers[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubble_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = <span class="keyword">this</span>[j];</span><br><span class="line">                <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span>];</span><br><span class="line">num.bubble_sort();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">    <span class="built_in">document</span>.body.innerHTML += num[i] + <span class="string">" "</span>;</span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$x, &amp;$y)</span> </span>&#123;</span><br><span class="line">    $t = $x;</span><br><span class="line">    $x = $y;</span><br><span class="line">    $y = $t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span><span class="params">(&amp;$arr)</span> </span>&#123;<span class="comment">//php的陣列視為基本型別，所以必須用傳參考才能修改原陣列</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr) - <span class="number">1</span>; $i++)</span><br><span class="line">        <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; count($arr) - <span class="number">1</span> - $i; $j++)</span><br><span class="line">            <span class="keyword">if</span> ($arr[$j] &gt; $arr[$j + <span class="number">1</span>])</span><br><span class="line">                swap($arr[$j], $arr[$j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">21</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span>);</span><br><span class="line">bubble_sort($arr);</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr); $i++)</span><br><span class="line">    <span class="keyword">echo</span> $arr[$i] . <span class="string">' '</span>;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>冒泡排序对<code>n</code>个项目需要<code>О(n²)</code>的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。<br>冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最好的情况，冒泡排序需要 <code>О(n²)</code>次交换，而插入排序只要最多<code>O(n)</code>交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行（<code>О(n²)</code>），而插入排序在这个例子只需要<code>O(n)</code>个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到<code>O(n)</code>。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p><p>参考：<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;
    
    </summary>
    
      <category term="冒泡排序" scheme="http://daijinlin.com/categories/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://daijinlin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Apk打包流程</title>
    <link href="http://daijinlin.com/2016/11/12/Apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>http://daijinlin.com/2016/11/12/Apk打包流程/</id>
    <published>2016-11-12T06:22:34.000Z</published>
    <updated>2017-04-12T07:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>Android 构建系统编译应用资源和源代码，然后将它们打包成可供您测试、部署、签署和分发的 APK。<br><a id="more"></a></p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>在构建过程中，Android项目将被编译并打包成.apk文件，该apk文件是二进制文件的容器。它包含在设备或模拟器上运行应用程序所需的所有信息，例如已编译的.dex文件（.class文件转换为Dalvik字节码），二进制版本的AndroidManifest.xml文件，已编译资源（resources.arsc）和未编译的资源文件。下图是早期旧版<a href="https://stuff.mit.edu/afs/sipb/project/android/docs/tools/building/index.html">官网</a>的一张构建流程图<br><img src="/res/compile/build-simplified.png" alt="简单流程图"></p><p>再来看一张稍微详细一点（圆形为操作，方形为对象）<br><img src="/res/compile/android_build.png" alt="详细流程图"></p><p>从上面的流程图，我们可以看出apk打包流程可以分为以下七步</p><ol><li>通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）</li><li>处理.aidl文件，生成对应的Java接口文件</li><li>通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件</li><li>通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex</li><li>通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk</li><li>通过Jarsigner工具，对上面的apk进行debug或release签名</li><li>通过zipalign工具，将签名后的apk进行对齐处理。</li></ol><p>以上就是一个Android从源码构建到Apk打包的基本流程。如今几乎Android Studio空前盛行的大环境下。新<a href="https://developer.android.com/studio/build/index.html?hl=zh-cn#build-process">官网</a>也给出了最新的构建过程图，完全基于Android Studio使用Gradle作为构建工具<br><img src="/res/compile/build-process_2x.png" alt="典型 Android 应用模块的构建流程"></p><p>典型 Android 应用模块的构建流程通常依循下列步骤：</p><ol><li>编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。</li><li>APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。</li><li>APK 打包器使用调试或发布密钥库签署您的 APK：<ol><li>如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。</li><li>如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署您的应用。要创建发布密钥库，请阅读在 Android Studio 中签署您的应用。</li></ol></li><li>在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。</li></ol><p>最后再看一张更加详细的流程图，高能预警<br><a href="http://tools.android.com/tech-docs/new-build-system/build-workflow"><img src="/res/compile/android_build_detail.png" alt="image" title="android_build_detail"></a></p><p>参考:<br><a href="http://blog.zhaiyifan.cn/2016/02/13/android-reverse-2/">http://blog.zhaiyifan.cn/2016/02/13/android-reverse-2/</a><br><a href="https://developer.android.com/studio/build/index.html?hl=zh-cn#build-config">https://developer.android.com/studio/build/index.html?hl=zh-cn#build-config</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;Android 构建系统编译应用资源和源代码，然后将它们打包成可供您测试、部署、签署和分发的 APK。&lt;br&gt;
    
    </summary>
    
      <category term="打包" scheme="http://daijinlin.com/categories/%E6%89%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>简单分析RecyclerView三大流程</title>
    <link href="http://daijinlin.com/2016/05/13/%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90RecyclerView%E4%B8%89%E5%A4%A7%E6%B5%81%E7%A8%8B/"/>
    <id>http://daijinlin.com/2016/05/13/简单分析RecyclerView三大流程/</id>
    <published>2016-05-13T12:02:46.000Z</published>
    <updated>2017-04-12T08:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>在日常开发中，列表的使用非常的普遍，从起初的AdapterView到现在的RecyclerView都实现了展示大量数据集，而内存不会出现OOM的情况。它们各自都实现了对应的缓存机制来实现回收功能。关于RecyclerView的缓存机制，后续使用独立篇幅介绍，本篇着重从View的三大基本流程分析。<br><a id="more"></a><br>本篇所有源码基于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.android.support:recyclerview-v7:23.2.1&apos;</span><br></pre></td></tr></table></figure></p><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果LayoutManager为空，则走默认的measure逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) &#123; <span class="comment">// 如果LayoutManager设置了setAutoMeasureEnabled为true</span></span><br><span class="line">        <span class="comment">// 第一部分：</span></span><br><span class="line">        <span class="comment">// 1) 调用LayoutManager#onMeasure，在其内部调用了RecyclerView#defaultOnMeasure，然后调用LayoutManager.chooseSize。</span></span><br><span class="line">        <span class="comment">// 2) 检查如果width和height都是精确值，那么就不用再根据内容进行计算所需要的width和height，跳过之后的步骤。如果有其中任何一个值不是精确值，则进入到下面计算所需长宽的步骤。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">if</span> (skipMeasure || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二部分：</span></span><br><span class="line">        <span class="comment">// 1) 开启布局流程计算出所有Child的边界</span></span><br><span class="line">        <span class="comment">// 2) 然后根据计算出的Child的边界计算出RecyclerView的所需width和height</span></span><br><span class="line">        <span class="comment">// 3) 检查是否需要再次测量</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span></span><br><span class="line">        <span class="comment">// consistency</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        <span class="comment">// 布局过程结束，根据Children中的边界信息计算并设置RecyclerView长宽的测量值</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">        <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">        <span class="comment">// 检查是否需要再次测量。如果RecyclerView仍然有非精确的宽和高，或者这里还有至少一个Child还有非精确的宽和高，我们就需要在此测量。</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一部分：如果RecyclerView已经设置了Size固定，则执行LayoutManager#onMeasure方法</span></span><br><span class="line">        <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二部分：</span></span><br><span class="line">        <span class="comment">// 1) 如果在测量的过程中有数据有更新，则先处理更新的数据</span></span><br><span class="line">        <span class="comment">// 2) 执行自定义测量流程，这需要自定义的LayoutManager#onMeasure方法。</span></span><br><span class="line">        <span class="comment">// custom onMeasure</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">            eatRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// consume remaining updates to provide a consistent state with the layout pass.</span></span><br><span class="line">                mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapterUpdateDuringMeasure = <span class="keyword">false</span>;</span><br><span class="line">            resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完新更新的数据，然后执行自定义测量操作。</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eatRequestLayout();</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>; <span class="comment">// clear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，进入的都是自动测量模式。系统提供的<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>、<code>StaggeredGridLayoutManager</code>基本上都在构造函数中直接或者间接设置了<code>setAutoMeasureEnabled</code>为<code>true</code>。如果我们自定义<code>LayoutManager</code>的时候，需要根据需求决定是否开启自动测量，默认是不开启的。</p><h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...省略部分代码</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        <span class="comment">// 1) 没有执行过布局流程的情况</span></span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() ||</span><br><span class="line">            mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        <span class="comment">// 2) 执行过布局流程，但是之后size又有变化的情况</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 执行过布局流程，可以直接使用之前数据的情况</span></span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>RecyclerView</code>的布局过程分为3步：<code>dispatchLayoutStep1</code>，<code>dispatchLayoutStep2</code>和<code>dispatchLayoutStep3</code>。在上面自动测量过程中我们为了得到Child的边界值，使用了<code>dispatchLayoutStep1</code>和<code>dispatchLayoutStep2</code>，所以在<code>dispatchLayout</code>中分了三种情况进行处理</p><ul><li>1.没有执行过布局流程的情况</li><li>2.执行过布局流程，但是之后size又有变化的情况</li><li>3.执行过布局流程，可以直接使用之前数据的情况</li></ul><p>不过，无论何种情况，最终都是完成<code>dispatchLayoutStep1</code>，<code>dispatchLayoutStep2</code>和<code>dispatchLayoutStep3</code>这三步，其中<code>dispatchLayoutStep1</code>就是pre layout，<code>dispatchLayoutStep3</code>是post layout，而<code>dispatchLayoutStep2</code>是处理真正测量&amp;布局的了。这样的情况区分只是为了避免重复计算。接下来按步分析。</p><h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The first step of a layout where we;</span></span><br><span class="line"><span class="comment"> * - process adapter updates</span></span><br><span class="line"><span class="comment"> * - decide which animation should run</span></span><br><span class="line"><span class="comment"> * - save information about current views</span></span><br><span class="line"><span class="comment"> * - If necessary, run predictive layout and save its information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags(); <span class="comment">// 动画相关</span></span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                            ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                            holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">            <span class="keyword">if</span> (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">                <span class="comment">// This is NOT the only place where a ViewHolder is added to old change holders</span></span><br><span class="line">                <span class="comment">// list. There is another case where:</span></span><br><span class="line">                <span class="comment">//    * A VH is currently hidden but not deleted</span></span><br><span class="line">                <span class="comment">//    * The hidden item is changed in the adapter</span></span><br><span class="line">                <span class="comment">//    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span></span><br><span class="line">                <span class="comment">// When this case is detected, RV will un-hide that view and add to the old</span></span><br><span class="line">                <span class="comment">// change holders list.</span></span><br><span class="line">                mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        saveOldPositions();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didStructureChange = mState.mStructureChanged;</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// temporarily disable flag because we are asking for previous layout</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mChildHelper.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">            <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                <span class="keyword">boolean</span> wasHidden = viewHolder</span><br><span class="line">                        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                <span class="keyword">if</span> (!wasHidden) &#123;</span><br><span class="line">                    flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                        mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                <span class="keyword">if</span> (wasHidden) &#123;</span><br><span class="line">                    recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we don't process disappearing list because they may re-appear in post layout pass.</span></span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类<code>ItemHolderInfo</code>是<code>RecyclerView</code>的内部类<code>ItemAnimator</code>的内部类。其中封装了对应ItemView的边界信息，即ItemView的left、top、right、bottom值。对象mViewInfoStore的作用注释写的很清楚，是提供给动画使用的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps data about views to be used for animations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> ViewInfoStore mViewInfoStore = <span class="keyword">new</span> ViewInfoStore();</span><br></pre></td></tr></table></figure><p>继续来看<code>ViewInfoStore</code>的<code>addToPreLayout</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the item information to the prelayout tracking</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> holder The ViewHolder whose information is being saved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info The information to save</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPreLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.preInfo = info;</span><br><span class="line">    record.flags |= FLAG_PRE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>RecyclerView</code>将pre layout阶段的ItemView信息存放在了ViewInfoStore中的mLayoutHolderMap集合中。</p><h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The second layout step where we do the actual layout of the views for the final state.</span></span><br><span class="line"><span class="comment"> * This step might be run multiple times if necessary (e.g. measure).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 调用LayoutManager#onLayoutChildren方法，如果我们自定义LayoutManager则需要重写此方法，具体可以参考系统提供的三种LayoutManager</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释就可以看出这是我们做实际布局的逻辑。</p><h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The final step of the layout where we save the information about views for animations,</span></span><br><span class="line"><span class="comment"> * trigger animations and do any necessary cleanup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 3: Find out where things are now, and process change animations.</span></span><br><span class="line">        <span class="comment">// traverse list in reverse because we may call animateChange in the loop which may</span></span><br><span class="line">        <span class="comment">// remove the target view holder.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPostLayoutInformation(mState, holder);</span><br><span class="line">            ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class="line">            <span class="keyword">if</span> (oldChangeViewHolder != <span class="keyword">null</span> &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="comment">// run a change animation</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If an Item is CHANGED but the updated version is disappearing, it creates</span></span><br><span class="line">                <span class="comment">// a conflicting case.</span></span><br><span class="line">                <span class="comment">// Since a view that is marked as disappearing is likely to be going out of</span></span><br><span class="line">                <span class="comment">// bounds, we run a change animation. Both views will be cleaned automatically</span></span><br><span class="line">                <span class="comment">// once their animations finish.</span></span><br><span class="line">                <span class="comment">// On the other hand, if it is the same view holder instance, we run a</span></span><br><span class="line">                <span class="comment">// disappearing animation instead because we are not going to rebind the updated</span></span><br><span class="line">                <span class="comment">// VH unless it is enforced by the layout manager.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class="line">                        oldChangeViewHolder);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class="line">                <span class="keyword">if</span> (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                    <span class="comment">// run disappear animation instead of change</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class="line">                            oldChangeViewHolder);</span><br><span class="line">                    <span class="comment">// we add and remove so that any post info is merged.</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                    ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class="line">                    <span class="keyword">if</span> (preInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class="line">                                oldDisappearing, newDisappearing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">    mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class="line">    mDataSetHasChangedAfterLayout = <span class="keyword">false</span>;</span><br><span class="line">    mState.mRunSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mState.mRunPredictiveAnimations = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.mRequestedSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecycler.mChangedScrap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecycler.mChangedScrap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">        <span class="comment">// Initial prefetch has expanded cache, so reset until next prefetch.</span></span><br><span class="line">        <span class="comment">// This prevents initial prefetches from expanding the cache permanently.</span></span><br><span class="line">        mLayout.mPrefetchMaxCountObserved = <span class="number">0</span>;</span><br><span class="line">        mLayout.mPrefetchMaxObservedInInitialPrefetch = <span class="keyword">false</span>;</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayout.onLayoutCompleted(mState);</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    <span class="keyword">if</span> (didChildRangeChange(mMinMaxLayoutPositions[<span class="number">0</span>], mMinMaxLayoutPositions[<span class="number">1</span>])) &#123;</span><br><span class="line">        dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recoverFocusFromState();</span><br><span class="line">    resetFocusInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看<code>ViewInfoStore</code>的<code>addToPostLayout</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the item information to the post layout list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> holder The ViewHolder whose information is being saved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info The information to save</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;</span><br><span class="line">    record.flags |= FLAG_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与pre layout阶段相同<code>RecyclerView</code>也是将post layout阶段的ItemView信息存放在mViewInfoStore的mLayoutHolderMap集合中，并且不难看出，同一个ItemView（或者叫ViewHolder）的pre layout信息与post layout信息封装在了同一个InfoRecord中，分别叫InfoRecord.preInfo与InforRecord.postInfo，这样InfoRecord就保存着同一个ItemView在数据集变化前后的信息，我们可以根据此信息定义动画的开始和结束状态。 </p><h4 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onDraw</code>的代码比较简单，调用<code>super.onDraw(c)</code>执行绘制逻辑，同时获取<code>ItemDecoration</code>个数，分别调用<code>ItemDecoration</code>的<code>onDraw</code>对分割线进行了绘制。这里有个疑问就是<code>ItemDecoration</code>还有个<code>onDrawOver</code>方法是在哪里调用的呢？我们看<code>RecyclerView</code>的<code>draw</code>方法有下面这样一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到<code>ItemDecoration</code>的<code>onDraw</code>是优先于<code>onDrawOver</code>调用的。（具体请自行了解View的绘制流程中draw方法的代码细节）</p><p>到此，<code>RecyclerView</code>的三大基本流程就简要分析完了。至于很多细节，诸如缓存机制、动画更新等都没有做详细的分析，后续会单独开辟博文继续剖析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;在日常开发中，列表的使用非常的普遍，从起初的AdapterView到现在的RecyclerView都实现了展示大量数据集，而内存不会出现OOM的情况。它们各自都实现了对应的缓存机制来实现回收功能。关于RecyclerView的缓存机制，后续使用独立篇幅介绍，本篇着重从View的三大基本流程分析。&lt;br&gt;
    
    </summary>
    
      <category term="View" scheme="http://daijinlin.com/categories/View/"/>
    
    
      <category term="RecyclerView" scheme="http://daijinlin.com/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Android开发中常用的python脚本</title>
    <link href="http://daijinlin.com/2016/04/13/python-tools/"/>
    <id>http://daijinlin.com/2016/04/13/python-tools/</id>
    <published>2016-04-13T12:02:46.000Z</published>
    <updated>2017-04-05T09:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>Android开发中常用的python脚本<br><a id="more"></a></p><h1 id="图片压缩（tinypng）"><a href="#图片压缩（tinypng）" class="headerlink" title="图片压缩（tinypng）"></a>图片压缩（tinypng）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">导入Tinify</span></span><br><span class="line"><span class="string"> pip install --upgrade tinify</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> tinify</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去https://tinypng.com/developers申请API KEY</span></span><br><span class="line">tinify.key = <span class="string">"你申请到的API KEY"</span>     <span class="comment"># API KEY</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩的核心</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress_core</span><span class="params">(input_file, output_file, img_width, img_height)</span>:</span></span><br><span class="line">    source = tinify.from_file(input_file)</span><br><span class="line">    <span class="keyword">if</span> img_width <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">-1</span>:</span><br><span class="line">        resized = source.resize(</span><br><span class="line">            method = <span class="string">"scale"</span>,</span><br><span class="line">            width  = img_width,</span><br><span class="line">            height = img_height</span><br><span class="line">        )</span><br><span class="line">        resized.to_file(output_file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        source.to_file(output_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩一个文件夹下的图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress_path</span><span class="params">(path, width, height)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"compress_path-------------------------------------"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"not a dir!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_path = path               <span class="comment"># 源路径</span></span><br><span class="line">        output_path = path+<span class="string">"/tiny"</span>      <span class="comment"># 输出路径</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"input_path = %s"</span> %input_path)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"output_path = %s"</span> %output_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(input_path):</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"root = %s"</span> %root)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"dirs = %s"</span> %dirs)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"files = %s"</span> %files)</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">                file_name, file_suffix = os.path.splitext(name)</span><br><span class="line">                <span class="keyword">if</span> file_suffix == <span class="string">'.png'</span> <span class="keyword">or</span> file_suffix == <span class="string">'.jpg'</span> <span class="keyword">or</span> file_suffix == <span class="string">'.jpeg'</span>:</span><br><span class="line">                    output_full_path = output_path + root[len(input_path):]</span><br><span class="line">                    output_full_name = output_path + <span class="string">'/'</span> + name</span><br><span class="line">                    <span class="keyword">if</span> os.path.isdir(output_full_path):</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        os.mkdir(output_full_path)</span><br><span class="line">                    compress_core(root + <span class="string">'/'</span> + name, output_full_name, width, height)</span><br><span class="line">                <span class="keyword">break</span>                   <span class="comment"># 仅遍历当前目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    compress_path(os.getcwd(), <span class="number">-1</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="查找项目中同名文件"><a href="#查找项目中同名文件" class="headerlink" title="查找项目中同名文件"></a>查找项目中同名文件</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">names = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_file</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">".java"</span> <span class="keyword">in</span> name:</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">print</span> name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            names.add(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_file</span><span class="params">(level, name)</span>:</span></span><br><span class="line">    rrrrdir = level + name</span><br><span class="line">    srcfiles = os.listdir(rrrrdir)</span><br><span class="line">    <span class="keyword">for</span> srcfile <span class="keyword">in</span> srcfiles:</span><br><span class="line">        srcfilepath = level + name + <span class="string">"/"</span> + srcfile</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(srcfilepath):</span><br><span class="line">            find_file(level + name + <span class="string">"/"</span>, srcfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"/."</span> <span class="keyword">not</span> <span class="keyword">in</span> srcfilepath:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"/java"</span> <span class="keyword">in</span> srcfilepath:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">"build"</span> <span class="keyword">not</span> <span class="keyword">in</span> srcfilepath:</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">"Test"</span> <span class="keyword">not</span> <span class="keyword">in</span> srcfilepath:</span><br><span class="line">                            check_file(srcfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">srcdir = os.getcwd() </span><br><span class="line">name = <span class="string">""</span></span><br><span class="line">find_file(srcdir, name)</span><br></pre></td></tr></table></figure><h1 id="根据字符串生成二维码"><a href="#根据字符串生成二维码" class="headerlink" title="根据字符串生成二维码"></a>根据字符串生成二维码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Python将Url生成二维码图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">安装PIL：pip install pillow</span></span><br><span class="line"><span class="string">安装qrcode：pip install qrcode</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line">__author__ = <span class="string">'Jinlin'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment">#生成二维码图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qr</span><span class="params">(url,save)</span>:</span></span><br><span class="line">    qr=qrcode.QRCode(</span><br><span class="line">        version=<span class="number">5</span>,  <span class="comment">#生成二维码尺寸的大小 1-40  1:21*21（21+(n-1)*4）</span></span><br><span class="line">        error_correction=qrcode.constants.ERROR_CORRECT_M, <span class="comment">#L:7%的字码可被容错 M:15%的字码可被容错 Q:25%的字码可被容错 H:30%的字码可被容错</span></span><br><span class="line">        box_size=<span class="number">10</span>, <span class="comment">#每个格子的像素大小</span></span><br><span class="line">        border=<span class="number">1</span>, <span class="comment">#边框的格子宽度大小（默认是4）</span></span><br><span class="line">    )</span><br><span class="line">    qr.add_data(url)</span><br><span class="line">    qr.make(fit=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">    img=qr.make_image()</span><br><span class="line">    img.save(save)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    save_path=<span class="string">'theqrcode.png'</span> <span class="comment">#生成后的保存文件</span></span><br><span class="line">    str = <span class="string">'测试'</span></span><br><span class="line">    <span class="comment"># if sys.version_info &lt; (3, ):</span></span><br><span class="line">    <span class="comment">#     str=raw_input('请输入要生成二维码的文本内容：')</span></span><br><span class="line">    <span class="comment"># else :</span></span><br><span class="line">    <span class="comment">#     str=input('请输入要生成二维码的文本内容：')</span></span><br><span class="line"> </span><br><span class="line">    make_qr(str, save_path)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;Android开发中常用的python脚本&lt;br&gt;
    
    </summary>
    
      <category term="辅助脚本" scheme="http://daijinlin.com/categories/%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Python" scheme="http://daijinlin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RxJava线程调度</title>
    <link href="http://daijinlin.com/2016/04/12/RxJava-Scheduler/"/>
    <id>http://daijinlin.com/2016/04/12/RxJava-Scheduler/</id>
    <published>2016-04-12T04:22:25.000Z</published>
    <updated>2020-01-14T10:26:55.741Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>RxJava 在切换线程时用到了两个方法 <code>subscribeOn()</code> 和 <code>observeOn()</code> ，那么它纠结做了什么呢？<br><a id="more"></a></p><blockquote><p>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.</p><p>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</p><p>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its <code>Subscribe</code> method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</p><p>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use <em>below</em> where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</p></blockquote><p><img src="http://reactivex.io/documentation/operators/images/schedulers.png" alt=""></p><ul><li><code>subscribeOn()</code>：影响的是最开始的被观察者所在的线程。当使用多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用；</li><li><code>observeOn()</code>：影响的是跟在后面的操作（指定观察者运行的线程）。所以如果想要多次改变线程，可以多次使用 observeOn；</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"create: "</span> + Thread.currentThread().getName());</span><br><span class="line">      emitter.onNext(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"String -&gt; Integer: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .flatMap(<span class="keyword">new</span> Function&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"Integer-&gt;Observable: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Log.e(TAG, <span class="string">"Observable&lt;String&gt; call: "</span> + Thread.currentThread().getName());</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer; i++) &#123;</span><br><span class="line">            emitter.onNext(i + <span class="string">""</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="keyword">new</span> Function&lt;String, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"String-&gt;Long: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Long.parseLong(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"onNext: "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="observeOn-的线程切换原理"><a href="#observeOn-的线程切换原理" class="headerlink" title="observeOn() 的线程切换原理"></a>observeOn() 的线程切换原理</h4><p>从<code>observeOn</code>切入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> observeOn(scheduler, delayError, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observeOn()</code> 执行后是得到 <code>ObservableObserveOn</code> 对象，那么当 <code>ObservableObserveOn</code> 绑定监听者的时候要运行 <code>subscribe()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略代码专用...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">            ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"><span class="comment">// 这里调用了抽象方法`subscribeActual`</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">            <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">            RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">            NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">            npe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObservableObserveOn</code>实现了<code>subscribeActual</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 在当前线程调度，但不是立即执行，放入到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"><span class="comment">// 为上游Observable</span></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以知道<code>ObservableObserveOn</code> 是被 <code>ObserveOnObserver</code> 监听的，所以收到通知也是由 <code>ObserveOnObserver</code> 作出响应，接下来我们假设当 <code>Rxjava</code> 发送 <code>onNext</code> 通知时会调用 <code>ObserveOnObserver</code> 的 <code>onNext()</code> 方法 ( PS:当然如果是 onComplete()、onError() 等也是一样的逻辑 )，然后来看一看 <code>ObserveOnObserver</code> 的 <code>onNext()</code> 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6576896619930983584L</span>;</span><br><span class="line">  <span class="comment">// 下游的Observer</span></span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line">  <span class="comment">// 调度工作者</span></span><br><span class="line">    <span class="keyword">final</span> Scheduler.Worker worker;</span><br><span class="line">  <span class="comment">// 是否延迟错误，默认false</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">  <span class="comment">// 队列大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line"><span class="comment">// 存储上游Observable下发的数据队列</span></span><br><span class="line">    SimpleQueue&lt;T&gt; queue;</span><br><span class="line"><span class="comment">// 存储下游的Observer的Disposable</span></span><br><span class="line">    Disposable s;</span><br><span class="line"><span class="comment">// 错误信息</span></span><br><span class="line">    Throwable error;</span><br><span class="line">  <span class="comment">// 校验是否完毕</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> done;</span><br><span class="line"><span class="comment">// 是否被取消</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"><span class="comment">// 执行模式，同步或者异步</span></span><br><span class="line">    <span class="keyword">int</span> sourceMode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> outputFused;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">          QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class="line"><span class="comment">// 判断执行模式并调用onSubscribe传递给下游Observer</span></span><br><span class="line">          <span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">            sourceMode = m;</span><br><span class="line">            queue = qd;</span><br><span class="line">            <span class="comment">// 后面的onXX方法都不会被调用</span></span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 同步模式下，直接调用schedule</span></span><br><span class="line">            schedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">            sourceMode = m;</span><br><span class="line">            queue = qd;</span><br><span class="line">            actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 异步模式下，等待schedule</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line"><span class="comment">// 判断执行模式并调用onSubscribe传递给下游Observer</span></span><br><span class="line">        actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 数据源是同步模式或者执行过 error / complete 会是true</span></span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 如果数据源不是异步类型</span></span><br><span class="line">      <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 上游Observable下发的数据压入queue</span></span><br><span class="line">        queue.offer(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开始调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// 已经完成再执行会抛异常</span></span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录错误信息</span></span><br><span class="line">      error = t;</span><br><span class="line">      <span class="comment">// 标记已完成</span></span><br><span class="line">      done = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 开始调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      done = <span class="keyword">true</span>;</span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>眼光转向<code>schedule()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子性</span></span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>worker</code>的<code>schedule()</code>方法，将自己传递进去。来看声明，<code>schedule</code>方法接收<code>Runnable</code>对象为参数，而<code>ObserveOnObserver</code>实现了<code>Runnable</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Schedules a Runnable for execution without any time delay.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation delegates to &#123;<span class="doctag">@link</span> #schedule(Runnable, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> run</span></span><br><span class="line"><span class="comment">    *            Runnable to schedule</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Disposable to be able to unsubscribe the action (cancel it if not executed)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> schedule(run, <span class="number">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules an Runnable for execution at some point in the future specified by a time delay</span></span><br><span class="line"><span class="comment">     * relative to the current time.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note to implementors: non-positive &#123;<span class="doctag">@code</span> delayTime&#125; should be regarded as non-delayed schedule, i.e.,</span></span><br><span class="line"><span class="comment">     * as if the &#123;<span class="doctag">@link</span> #schedule(Runnable)&#125; was called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> run</span></span><br><span class="line"><span class="comment">     *            the Runnable to schedule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay</span></span><br><span class="line"><span class="comment">     *            time to "wait" before executing the action; non-positive values indicate an non-delayed</span></span><br><span class="line"><span class="comment">     *            schedule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     *            the time unit of &#123;<span class="doctag">@code</span> delayTime&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Disposable to be able to unsubscribe the action (cancel it if not executed)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span></span>;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了重载方法，是个抽象方法。示例使用的是<code>Schedulers.io()</code>，追根溯源最终到了<code>IoScheduler</code>，直接找到<code>schedule</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pool = pool;</span><br><span class="line">      <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line">      <span class="keyword">this</span>.threadWorker = pool.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (once.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        tasks.dispose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// releasing the pool should be the last action</span></span><br><span class="line">        pool.release(threadWorker);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> once.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tasks.isDisposed()) &#123;</span><br><span class="line">        <span class="comment">// don't schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>scheduleActual</code>，在看下实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wraps the given runnable into a ScheduledRunnable and schedules it</span></span><br><span class="line"><span class="comment">     * on the underlying ScheduledExecutorService.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the schedule has been rejected, the ScheduledRunnable.wasScheduled will return</span></span><br><span class="line"><span class="comment">     * false.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> run the runnable instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime the time to delay the execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the optional tracker parent to add the created ScheduledRunnable instance to before it gets scheduled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the ScheduledRunnable instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!parent.add(sr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 判断延迟时间，然后使用线程池运行 Runnable</span></span><br><span class="line">            <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            sr.setFuture(f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.remove(sr);</span><br><span class="line">            &#125;</span><br><span class="line">            RxJavaPlugins.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜圈回到<code>ObservableObserveOn</code>的<code>run</code>方法，然后调用<code>onNext</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">      drainFused();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下<code>checkTerminated</code>方法，做了什么操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkTerminated</span><span class="params">(<span class="keyword">boolean</span> d, <span class="keyword">boolean</span> empty, Observer&lt;? <span class="keyword">super</span> T&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">      <span class="comment">// 订阅已经取消，则取消队列</span></span><br><span class="line">      queue.clear();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个d就是传进来的done</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">      <span class="comment">// done == true可能的情况onNext刚被调度完，onError或者onComplete被调用</span></span><br><span class="line">      Throwable e = error;</span><br><span class="line">      <span class="keyword">if</span> (delayError) &#123;</span><br><span class="line">        <span class="comment">// delayError == true时等到队列为空才调用</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            a.onError(e);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a.onComplete();</span><br><span class="line">          &#125;</span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          queue.clear();</span><br><span class="line">          a.onError(e);</span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            a.onComplete();</span><br><span class="line">            worker.dispose();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不终结</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看下<code>drainNormal</code>做了哪些事情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line">    <span class="comment">// 死循环，注意出口操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 上面方法被终止，不进行下面操作</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 再次死循环</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> d = done;</span><br><span class="line">        T v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 分发数据出队列</span></span><br><span class="line">          v = q.poll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="comment">// 有异常时终止退出</span></span><br><span class="line">          Exceptions.throwIfFatal(ex);</span><br><span class="line">          s.dispose();</span><br><span class="line">          q.clear();</span><br><span class="line">          a.onError(ex);</span><br><span class="line">          <span class="comment">// 停止woker（线程）</span></span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没数据跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据下发给下游Observer，onNext, onComplete和onError主要放在了checkTerminated里面回调</span></span><br><span class="line">        a.onNext(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保证此时有一个worker.schedule(this);正在执行</span></span><br><span class="line">      missed = addAndGet(-missed);</span><br><span class="line">      <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="subscribeOn-的线程切换原理"><a href="#subscribeOn-的线程切换原理" class="headerlink" title="subscribeOn() 的线程切换原理"></a>subscribeOn() 的线程切换原理</h4><p>同样，这里从<code>subscribeOn</code>作为切入点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>subscribeOn</code>得到装饰者模式对象<code>ObservableSubscribeOn</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line"></span><br><span class="line">        s.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说一说RxAndroid"><a href="#说一说RxAndroid" class="headerlink" title="说一说RxAndroid"></a>说一说RxAndroid</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Android-specific Schedulers. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> MainHolder.DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A &#123;<span class="doctag">@link</span> Scheduler&#125; which executes actions on the Android main thread. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A &#123;<span class="doctag">@link</span> Scheduler&#125; which executes actions on &#123;<span class="doctag">@code</span> looper&#125;. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">from</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"looper == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(looper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AndroidSchedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"No instances."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AndroidSchedulers.mainThread()</code>返回的是<code>HandlerScheduler</code>，传递了一个<code>Handler</code>拿到主线程的<code>Looper</code>的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;RxJava 在切换线程时用到了两个方法 &lt;code&gt;subscribeOn()&lt;/code&gt; 和 &lt;code&gt;observeOn()&lt;/code&gt; ，那么它纠结做了什么呢？&lt;br&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://daijinlin.com/categories/RxJava/"/>
    
    
      <category term="线程调度" scheme="http://daijinlin.com/tags/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符</title>
    <link href="http://daijinlin.com/2016/04/11/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://daijinlin.com/2016/04/11/RxJava操作符/</id>
    <published>2016-04-11T11:22:46.000Z</published>
    <updated>2020-01-14T09:22:02.631Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>通过代码介绍RxJava中的操作符，以及操作符的使用。<br><a id="more"></a></p><h1 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h1><h4 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h4><p>用于创建Observable的操作符</p><h5 id="Create-—-通过调用观察者的方法从头创建一个Observable"><a href="#Create-—-通过调用观察者的方法从头创建一个Observable" class="headerlink" title="Create — 通过调用观察者的方法从头创建一个Observable"></a>Create — 通过调用观察者的方法从头创建一个Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/create.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                subscriber.onNext(i);</span><br><span class="line">            &#125;</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next: "</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"Error: "</span> + error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next: 0</span><br><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Next: 4</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="From-—-将其它的对象或数据结构转换为Observable"><a href="#From-—-将其它的对象或数据结构转换为Observable" class="headerlink" title="From — 将其它的对象或数据结构转换为Observable"></a>From — 将其它的对象或数据结构转换为Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/from.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] items = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Observable&lt;Integer&gt; observable = Observable.from(items);</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error encountered: "</span> + throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Sequence complete</span><br></pre></td></tr></table></figure></p><h5 id="Just-—-将对象或者对象集合转换为一个会发射这些对象的Observable"><a href="#Just-—-将对象或者对象集合转换为一个会发射这些对象的Observable" class="headerlink" title="Just — 将对象或者对象集合转换为一个会发射这些对象的Observable"></a>Just — 将对象或者对象集合转换为一个会发射这些对象的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/just.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"Error: "</span> + error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Defer-—-在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable"><a href="#Defer-—-在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable" class="headerlink" title="Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable"></a>Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/defer.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String i = <span class="string">"旧数据"</span>;</span><br><span class="line">Observable&lt;String&gt; observable = Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Subscriber subscriber=<span class="keyword">new</span> Subscriber() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"Error: "</span> + error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next: "</span> + o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">i = <span class="string">"新数据"</span>;</span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next: 新数据</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Empty-Never-Throw-—-创建行为受限的特殊Observable"><a href="#Empty-Never-Throw-—-创建行为受限的特殊Observable" class="headerlink" title="Empty/Never/Throw — 创建行为受限的特殊Observable"></a>Empty/Never/Throw — 创建行为受限的特殊Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/empty.c.png" alt=""></p><p><img src="http://reactivex.io/documentation/operators/images/never.c.png" alt=""></p><p><img src="http://reactivex.io/documentation/operators/images/throw.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Empty</span><br><span class="line">创建一个不发射任何数据但是正常终止的Observable</span><br><span class="line"></span><br><span class="line">Never</span><br><span class="line">创建一个不发射数据也不终止的Observable</span><br><span class="line"></span><br><span class="line">Throw</span><br><span class="line">创建一个不发射数据以一个错误终止的Observable</span><br><span class="line"></span><br><span class="line">Observable.empty().subscribe(<span class="keyword">new</span> Subscriber() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + i.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Timer-—-创建在一个指定的延迟之后发射单个数据的Observable"><a href="#Timer-—-创建在一个指定的延迟之后发射单个数据的Observable" class="headerlink" title="Timer — 创建在一个指定的延迟之后发射单个数据的Observable"></a>Timer — 创建在一个指定的延迟之后发射单个数据的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/timer.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.timer(<span class="number">3</span>, TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + aLong.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I/System.out: Next:0</span><br><span class="line">I/System.out: Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Interval-—-创建一个定时发射整数序列的Observable"><a href="#Interval-—-创建一个定时发射整数序列的Observable" class="headerlink" title="Interval — 创建一个定时发射整数序列的Observable"></a>Interval — 创建一个定时发射整数序列的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/interval.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">3</span>, TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + aLong.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I/System.out: Next:0</span><br><span class="line">I/System.out: Next:1</span><br><span class="line">I/System.out: Next:2</span><br><span class="line">I/System.out: Next:3</span><br><span class="line">I/System.out: Next:4</span><br><span class="line">I/System.out: Next:5</span><br><span class="line">I/System.out: Next:6</span><br><span class="line">I/System.out: Next:7</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h5 id="Range-—-创建发射指定范围的整数序列的Observable"><a href="#Range-—-创建发射指定范围的整数序列的Observable" class="headerlink" title="Range — 创建发射指定范围的整数序列的Observable"></a>Range — 创建发射指定范围的整数序列的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/range.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">3</span>, <span class="number">8</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + integer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next:3</span><br><span class="line">Next:4</span><br><span class="line">Next:5</span><br><span class="line">Next:6</span><br><span class="line">Next:7</span><br><span class="line">Next:8</span><br><span class="line">Next:9</span><br><span class="line">Next:10</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Repeat-—-创建重复发射特定的数据或数据序列的Observable"><a href="#Repeat-—-创建重复发射特定的数据或数据序列的Observable" class="headerlink" title="Repeat — 创建重复发射特定的数据或数据序列的Observable"></a>Repeat — 创建重复发射特定的数据或数据序列的Observable</h5><p><img src="http://reactivex.io/documentation/operators/images/repeat.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">3</span>, <span class="number">3</span>).repeat(<span class="number">2</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + i.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next:3</span><br><span class="line">Next:4</span><br><span class="line">Next:5</span><br><span class="line">Next:3</span><br><span class="line">Next:4</span><br><span class="line">Next:5</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h4 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h4><h5 id="Map-—-映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项"><a href="#Map-—-映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项" class="headerlink" title="Map — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项"></a>Map — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Observable.from(integers).map(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call: "</span>+integer);</span><br><span class="line">        <span class="keyword">return</span> (integer &gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Boolean b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + b.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call: 0</span><br><span class="line">Next:false</span><br><span class="line">call: 9</span><br><span class="line">Next:true</span><br><span class="line">call: 6</span><br><span class="line">Next:true</span><br><span class="line">call: 4</span><br><span class="line">Next:false</span><br><span class="line">call: 8</span><br><span class="line">Next:true</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Cast-—-强制类型转换-通过对序列的每一项都强制类型变换Observable发射的数据"><a href="#Cast-—-强制类型转换-通过对序列的每一项都强制类型变换Observable发射的数据" class="headerlink" title="Cast — 强制类型转换,通过对序列的每一项都强制类型变换Observable发射的数据"></a>Cast — 强制类型转换,通过对序列的每一项都强制类型变换Observable发射的数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Observable.just(integers).cast(String<span class="class">.<span class="keyword">class</span>).<span class="title">subscribe</span>(<span class="title">new</span> <span class="title">Subscriber</span>&lt;<span class="title">String</span>&gt;() </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error:Cannot cast [Ljava.lang.Integer; to java.lang.String</span><br></pre></td></tr></table></figure></p><h5 id="FlatMap-—-扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。"><a href="#FlatMap-—-扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。" class="headerlink" title="FlatMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。"></a>FlatMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。</h5><p><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Observable.from(integers).flatMap(<span class="keyword">new</span> Func1&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"call: FlatMap "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    subscriber.onNext(integer + <span class="number">100</span> + <span class="string">" FlatMap"</span>);</span><br><span class="line">                    subscriber.onCompleted();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    subscriber.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.newThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Next:"</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call: FlatMap RxNewThreadScheduler-1</span><br><span class="line">call: FlatMap RxNewThreadScheduler-2</span><br><span class="line">call: FlatMap RxNewThreadScheduler-3</span><br><span class="line">Next:101 FlatMap</span><br><span class="line">Next:102 FlatMap</span><br><span class="line">Next:103 FlatMap</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="ConcatMap-该操作符是类似于最简单版本的flatMap，但是它按次序连接而不是合并那些生成的Observables，然后产生自己的数据序列。"><a href="#ConcatMap-该操作符是类似于最简单版本的flatMap，但是它按次序连接而不是合并那些生成的Observables，然后产生自己的数据序列。" class="headerlink" title="ConcatMap - 该操作符是类似于最简单版本的flatMap，但是它按次序连接而不是合并那些生成的Observables，然后产生自己的数据序列。"></a>ConcatMap - 该操作符是类似于最简单版本的flatMap，但是它按次序连接而不是合并那些生成的Observables，然后产生自己的数据序列。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Observable.from(integers).concatMap(<span class="keyword">new</span> Func1&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"call: FlatMap "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    subscriber.onNext(integer + <span class="number">100</span> + <span class="string">" FlatMap"</span>);</span><br><span class="line">                    subscriber.onCompleted();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    subscriber.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.newThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Next:"</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call: FlatMap RxNewThreadScheduler-1</span><br><span class="line">call: FlatMap RxNewThreadScheduler-2</span><br><span class="line">Next:101 FlatMap</span><br><span class="line">Next:102 FlatMap</span><br><span class="line">call: FlatMap RxNewThreadScheduler-3</span><br><span class="line">Next:103 FlatMap</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="SwitchMap-当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视产生执之前那个数据的Observable，只监视当前这一个。"><a href="#SwitchMap-当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视产生执之前那个数据的Observable，只监视当前这一个。" class="headerlink" title="SwitchMap - 当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视产生执之前那个数据的Observable，只监视当前这一个。"></a>SwitchMap - 当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视产生执之前那个数据的Observable，只监视当前这一个。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Observable.from(integers).switchMap(<span class="keyword">new</span> Func1&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call: SwitchMap "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// 如果不通过subscribeOn(Schedulers.newThread())在在子线程模拟并发操作，所有数据源依然会全部输出,也就是并发操作此操作符才有作用</span></span><br><span class="line">        <span class="comment">// 若在此通过Thread。sleep（）设置等待时间，则输出信息会不一样。相当于模拟并发程度</span></span><br><span class="line">        <span class="keyword">return</span> Observable.just((integer + <span class="number">100</span>) + <span class="string">"SwitchMap"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.newThread());</span><br><span class="line">&#125;</span><br><span class="line">&#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call: SwitchMap main</span><br><span class="line">call: SwitchMap main</span><br><span class="line">call: SwitchMap main</span><br><span class="line">Next:103SwitchMap</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="GroupBy-将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。"><a href="#GroupBy-将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。" class="headerlink" title="GroupBy - 将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。"></a>GroupBy - 将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。</h5><p><img src="http://reactivex.io/documentation/operators/images/groupBy.c.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">10</span>).groupBy(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;GroupedObservable&lt;Boolean, Integer&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete.1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:1"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(GroupedObservable&lt;Boolean, Integer&gt; booleanIntegerGroupedObservable)</span> </span>&#123;</span><br><span class="line">        booleanIntegerGroupedObservable.toList().subscribe(<span class="keyword">new</span> Subscriber&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sequence complete.2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error:2"</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;Integer&gt; integers)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext:2"</span> + integers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:2[1, 3, 5, 7, 9]</span><br><span class="line">Sequence complete.2</span><br><span class="line">onNext:2[2, 4, 6, 8, 10]</span><br><span class="line">Sequence complete.2</span><br><span class="line">Sequence complete.1</span><br></pre></td></tr></table></figure></p><h5 id="Scan-操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。"><a href="#Scan-操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。" class="headerlink" title="Scan - 操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。"></a>Scan - 操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">4</span>).scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call: integer:"</span>+integer+<span class="string">"  integer2 "</span>+integer2);</span><br><span class="line">        <span class="keyword">return</span> integer+integer2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:1</span><br><span class="line">call: integer:1  integer2 2</span><br><span class="line">onNext:3</span><br><span class="line">call: integer:3  integer2 3</span><br><span class="line">onNext:6</span><br><span class="line">call: integer:6  integer2 4</span><br><span class="line">onNext:10</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Buffer-将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合，如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。"><a href="#Buffer-将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合，如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。" class="headerlink" title="Buffer - 将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合，如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。"></a>Buffer - 将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合，如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。</h5><p><img src="http://reactivex.io/documentation/operators/images/Buffer.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">10</span>, <span class="number">6</span>).buffer(<span class="number">2</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete.2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:2"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;Integer&gt; integers)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:2"</span> + integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:[10, 11]</span><br><span class="line">onNext:[12, 13]</span><br><span class="line">onNext:[14, 15]</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="Window-Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。"><a href="#Window-Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。" class="headerlink" title="Window - Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。"></a>Window - Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。</h5><p><img src="http://reactivex.io/documentation/operators/images/window.C.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">10</span>, <span class="number">6</span>).window(<span class="number">2</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete.1 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:1 "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Observable&lt;Integer&gt; integerObservable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:1 "</span>);</span><br><span class="line">        integerObservable.subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sequence complete.2 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error:2 "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext:2 "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:1 </span><br><span class="line">onNext:2 10</span><br><span class="line">onNext:2 11</span><br><span class="line">Sequence complete.2 </span><br><span class="line">onNext:1 </span><br><span class="line">onNext:2 12</span><br><span class="line">onNext:2 13</span><br><span class="line">Sequence complete.2 </span><br><span class="line">onNext:1 </span><br><span class="line">onNext:2 14</span><br><span class="line">onNext:2 15</span><br><span class="line">Sequence complete.2 </span><br><span class="line">Sequence complete.1</span><br></pre></td></tr></table></figure></p><h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><h5 id="Filter-接收一个Func1参数，我们可以在其中通过运用你自己的判断条件去判断我们要过滤的数据，当数据通过判断条件后返回true表示发射该项数据，否则就不发射，这样就过滤出了我们想要的数据。"><a href="#Filter-接收一个Func1参数，我们可以在其中通过运用你自己的判断条件去判断我们要过滤的数据，当数据通过判断条件后返回true表示发射该项数据，否则就不发射，这样就过滤出了我们想要的数据。" class="headerlink" title="Filter - 接收一个Func1参数，我们可以在其中通过运用你自己的判断条件去判断我们要过滤的数据，当数据通过判断条件后返回true表示发射该项数据，否则就不发射，这样就过滤出了我们想要的数据。"></a>Filter - 接收一个Func1参数，我们可以在其中通过运用你自己的判断条件去判断我们要过滤的数据，当数据通过判断条件后返回true表示发射该项数据，否则就不发射，这样就过滤出了我们想要的数据。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Observable&lt;Integer&gt; observable = Observable.from(ints).filter(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer % <span class="number">2</span> != <span class="number">0</span>;<span class="comment">// 返回true，就不会过滤掉，会发射数据，过滤掉返回false的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:1</span><br><span class="line">onNext:3</span><br><span class="line">onNext:5</span><br><span class="line">onNext:7</span><br><span class="line">onNext:9</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="ofType-过滤一个Observable只返回指定类型的数据"><a href="#ofType-过滤一个Observable只返回指定类型的数据" class="headerlink" title="ofType - 过滤一个Observable只返回指定类型的数据"></a>ofType - 过滤一个Observable只返回指定类型的数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">0x68</span>, <span class="string">"Jinlin"</span>, <span class="number">6</span>, <span class="number">33</span>, <span class="string">"5upport"</span>, <span class="number">8</span>, <span class="string">"asdfasf"</span>, <span class="number">1</span>, <span class="string">"four"</span>, <span class="number">0</span>)</span><br><span class="line">.ofType(String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">.<span class="title">subscribe</span>(<span class="title">new</span> <span class="title">Subscriber</span>&lt;<span class="title">String</span>&gt;() </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Next:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next:Jinlin</span><br><span class="line">Next:5upport</span><br><span class="line">Next:asdfasf</span><br><span class="line">Next:four</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="First-如果我们只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，则可以使用First操作符。"><a href="#First-如果我们只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，则可以使用First操作符。" class="headerlink" title="First - 如果我们只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，则可以使用First操作符。"></a>First - 如果我们只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，则可以使用First操作符。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).first(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">变形</span><br><span class="line">Observable.just(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>).firstOrDefault(<span class="number">10</span>).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"call:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="number">10</span>，<span class="number">13</span>, <span class="number">16</span>).firstOrDefault(<span class="number">15</span>, <span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext:3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p><h5 id="takeFirst-该操作符与first操作符的区别就是如果原始Observable没有发射任何满足条件的数据，first会抛出一个NoSuchElementException直接执行onError-，而takeFist会返回一个空的Observable（不调用onNext-但是会调用onCompleted）"><a href="#takeFirst-该操作符与first操作符的区别就是如果原始Observable没有发射任何满足条件的数据，first会抛出一个NoSuchElementException直接执行onError-，而takeFist会返回一个空的Observable（不调用onNext-但是会调用onCompleted）" class="headerlink" title="takeFirst - 该操作符与first操作符的区别就是如果原始Observable没有发射任何满足条件的数据，first会抛出一个NoSuchElementException直接执行onError()，而takeFist会返回一个空的Observable（不调用onNext()但是会调用onCompleted）"></a>takeFirst - 该操作符与first操作符的区别就是如果原始Observable没有发射任何满足条件的数据，first会抛出一个NoSuchElementException直接执行onError()，而takeFist会返回一个空的Observable（不调用onNext()但是会调用onCompleted）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### first</span><br><span class="line">Observable.just(<span class="number">10</span>, <span class="number">11</span>).filter(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).first().subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">#### takeFirst</span><br><span class="line">Observable.just(<span class="number">10</span>, <span class="number">11</span>).takeFirst(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sequence complete."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"onNext:"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### first</span><br><span class="line">error:Sequence contains no elements</span><br><span class="line"></span><br><span class="line">#### takeFirst</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;通过代码介绍RxJava中的操作符，以及操作符的使用。&lt;br&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://daijinlin.com/categories/RxJava/"/>
    
    
      <category term="操作符" scheme="http://daijinlin.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Android热修复探究—美团Robust</title>
    <link href="http://daijinlin.com/2016/04/04/Android-hotfix-4/"/>
    <id>http://daijinlin.com/2016/04/04/Android-hotfix-4/</id>
    <published>2016-04-03T16:04:00.000Z</published>
    <updated>2017-04-05T09:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="热修复" scheme="http://daijinlin.com/categories/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>Android热修复探究—微信Tinker</title>
    <link href="http://daijinlin.com/2016/04/03/Android-hotfix-3/"/>
    <id>http://daijinlin.com/2016/04/03/Android-hotfix-3/</id>
    <published>2016-04-02T16:03:00.000Z</published>
    <updated>2017-04-05T09:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="热修复" scheme="http://daijinlin.com/categories/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>Android热修复探究—手Q方案</title>
    <link href="http://daijinlin.com/2016/04/03/Android-hotfix-2/"/>
    <id>http://daijinlin.com/2016/04/03/Android-hotfix-2/</id>
    <published>2016-04-02T16:03:00.000Z</published>
    <updated>2017-04-12T08:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="热修复" scheme="http://daijinlin.com/categories/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>Android热修复探究—QQ空间方案</title>
    <link href="http://daijinlin.com/2016/04/02/Android-hotfix-1/"/>
    <id>http://daijinlin.com/2016/04/02/Android-hotfix-1/</id>
    <published>2016-04-01T16:01:00.000Z</published>
    <updated>2017-04-12T08:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 概述：</strong>传统的app开发模式下，线上出现bug，必须通过发布新版本，用户手动更新后才能修复线上bug。那么是否存在一种方案可以在不发版的前提下修复线上bug？有！而且不只一种。今天首先来看下腾讯的QQ空间补丁方案<br><a id="more"></a><br>传统的app开发模式下，线上出现bug，必须通过发布新版本，用户手动更新后才能修复线上bug。随着app的业务越来越复杂，代码量爆发式增长，出现bug的机率也随之上升。如果单纯靠发版修复线上bug，其较长的新版覆盖期无疑会对业务造成巨大的伤害，更不要说大型app开发通常涉及多个团队协作，发版排期必须多方协调。<br>那么是否存在一种方案可以在不发版的前提下修复线上bug？有！而且不只一种，业界各家大厂都针对这一问题拿出了自家的解决方案，较为著名的有腾讯的Tinker和阿里的Andfix以及QQ空间补丁。网上对上述方案有很多介绍性文章，不过大多不全面，中间略过很多细节。笔者在学习的过程中也遇到很多麻烦。所以笔者将通过接下来几篇博客对上述两种方案进行介绍，力求不放过每一个细节。首先来看下QQ空间补丁方案。</p><h1 id="Dex分包机制"><a href="#Dex分包机制" class="headerlink" title="Dex分包机制"></a>Dex分包机制</h1><p>大家都知道，我们开发的代码在被编译成class文件后会被打包成一个dex文件。但是dex文件有一个限制，由于方法id是一个short类型，所以导致了一个dex文件最多只能存放65536个方法。随着现今App的开发日益复杂，导致方法数早已超过了这个上限。为了解决这个问题，Google提出了multidex方案，即一个apk文件可以包含多个dex文件。<br>不过值得注意的是，除了第一个dex文件以外，其他的dex文件都是以资源的形式被加载的，换句话说就是在Application.onCreate()方法中被注入到系统的ClassLoader中的。这也就为热修复提供了一种可能：将修复后的代码达成补丁包，然后发送到客户端，客户端在启动的时候到指定路径下加载对应dex文件即可。<br>根据Android虚拟机的类加载机制，同一个类只会被加载一次，所以要让修复后的类替换原有的类就必须让补丁包的类被优先加载。接下来看下Android虚拟机的类加载机制。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>Android的类加载机制和jvm加载机制类似，都是通过ClassLoader来完成，只是具体的类不同而已。<br>Android系统通过PathClassLoader来加载系统类和主dex中的类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Provides a simple &#123;@link ClassLoader&#125; implementation that operates on a list</span><br><span class="line"> * of files and directories in the local file system, but does not attempt to</span><br><span class="line"> * load classes from the network. Android uses this class for its system class</span><br><span class="line"> * loader and for its application class loader(s).</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>而DexClassLoader则用于加载其他dex文件中的类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A class loader that loads classes from &#123;@code .jar&#125; and &#123;@code .apk&#125; files</span><br><span class="line"> * containing a &#123;@code classes.dex&#125; entry. This can be used to execute code not</span><br><span class="line"> * installed as part of an application.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span><br><span class="line"> * cache optimized classes. Use &#123;@code Context.getDir(String, int)&#125; to create</span><br><span class="line"> * such a directory: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   File dexOutputDir = context.getDir(&quot;dex&quot;, 0);</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span><br><span class="line"> * External storage does not provide access controls necessary to protect your</span><br><span class="line"> * application from code injection attacks.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>上述两个类都是继承自BaseDexClassLoader，查看源码得知具体的加载方法是findClass:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for common functionality between various dex-based</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ClassLoader&#125; implementations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory directory where optimized dex files</span></span><br><span class="line"><span class="comment">     * should be written; may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> libraryPath the list of directories containing native</span></span><br><span class="line"><span class="comment">     * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看到加载类的工作转移到了pathList中，pathList是一个DexPathList类型，从变量名和类型名就可以看出这是一个维护Dex的容器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAR_SUFFIX = <span class="string">".jar"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_SUFFIX = <span class="string">".zip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** class definition context */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of dex/resource (class path) elements.</span></span><br><span class="line"><span class="comment">     * Should be called pathElements, but the Facebook app uses reflection</span></span><br><span class="line"><span class="comment">     * to modify 'dexElements' (http://b/7726934).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the named class in one of the dex files pointed at by</span></span><br><span class="line"><span class="comment">     * this instance. This will find the one in the earliest listed</span></span><br><span class="line"><span class="comment">     * path element. If the class is found but has not yet been</span></span><br><span class="line"><span class="comment">     * defined, then this method will define it in the defining</span></span><br><span class="line"><span class="comment">     * context that this instance was constructed with.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name of class to find</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suppressed exceptions encountered whilst finding the class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the named class or &#123;<span class="doctag">@code</span> null&#125; if the class is not</span></span><br><span class="line"><span class="comment">     * found in any of the dex files</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexPathList的findClass也很简单，dexElements是维护dex文件的数组，每一个item对应一个dex文件。DexPathList遍历dexElements，从每一个dex文件中查找目标类，在找到后即返回并停止遍历。所以要想达到热修复的目的就必须让补丁dex在dexElements中的位置先于原有dex：</p><p><img src="/res/hotfix/c3d8d50bdf89d50bf5254387ae761ccc_b.jpg" alt="修复前"></p><p><img src="/res/hotfix/5af6c469a4866233d82ee7521c672ea6_b.jpg" alt="修复后"></p><p>基本上以上的部分就是QQ空间动态修复方案的基本思路。下面将以一个简单的例子讲述一下QQ空间补丁热修复的过程。</p><h4 id="创建补丁"><a href="#创建补丁" class="headerlink" title="创建补丁"></a>创建补丁</h4><p>1.创建简单类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Activity也很简单，实例化Hello并且调用方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(TAG, <span class="string">"getClassLoader():"</span> + getClassLoader());</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, String.valueOf(<span class="keyword">new</span> Hello().say()), Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.创建补丁包<br>首先修改要修复的类，我们在返回的字符串后加了三个感叹号。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.重新编译项目，在<code>app/build/intermediates/classes/debug/com/jinlin/base/hotfix/</code>目录下找到Hello.class文件,将其拷出来，准备打包。注意要放置在于Hello包名相同的路径下<code>com/jinlin/base/hotfix/</code>。然后使用命令将其打成jar包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar -cvf patch.jar com</span><br></pre></td></tr></table></figure><p>再将对应的jar包打成dex包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dx --dex --output=patch_dex.jar patch.jar</span><br></pre></td></tr></table></figure></p><p>dx是将jar包打成dex包的工具，安装在<code>$sdk_home$/build-tools/version(如23.0.1)/dx</code>。生成的patch_dex.jar就是补丁包。接下来将其放到SDCard中，之后应用从sdCard上加载该补丁包。注意：这里需要添加读取内存卡的权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push patch_dex.jar /mnt/sdcard/</span><br></pre></td></tr></table></figure></p><h4 id="加载补丁"><a href="#加载补丁" class="headerlink" title="加载补丁"></a>加载补丁</h4><p>加载补丁的思路如下：</p><p>在Application的onCreate()方法中获取应用本身的BaseDexClassLoader,然后通过反射得到对应的dexElements<br>创建一个新的DexClassLoader实例，然后加载SDCard上的补丁包，通过同样的反射方法得到对应的dexElements<br>将两个dexElements合并，再利用反射将合并后的dexElements赋值给应用本身的BaseDexClassLoader<br>接下来看下具体代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotFixApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = HotFixApplication<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取补丁，如果存在就执行注入操作</span></span><br><span class="line">        String dexPath = Environment.getExternalStorageDirectory().getAbsolutePath().concat(<span class="string">"/patch_dex.jar"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(dexPath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            inject(dexPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, dexPath + <span class="string">"不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要注入的dex的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取classes的dexElements</span></span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>);</span><br><span class="line">            Object pathList = getField(cl, <span class="string">"pathList"</span>, getClassLoader());</span><br><span class="line">            Object baseElements = getField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取patch_dex的dexElements（需要先加载dex）</span></span><br><span class="line">            String dexopt = getDir(<span class="string">"dexopt"</span>, <span class="number">0</span>).getAbsolutePath();</span><br><span class="line">            DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(path, dexopt, dexopt, getClassLoader());</span><br><span class="line">            Object obj = getField(cl, <span class="string">"pathList"</span>, dexClassLoader);</span><br><span class="line">            Object dexElements = getField(obj.getClass(), <span class="string">"dexElements"</span>, obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并两个Elements</span></span><br><span class="line">            Object combineElements = combineArray(dexElements, baseElements);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将合并后的Element数组重新赋值给app的classLoader</span></span><br><span class="line">            setField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList, combineElements);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//======== 以下是测试是否成功注入 =================</span></span><br><span class="line">            Object object = getField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList);</span><br><span class="line">            <span class="keyword">int</span> length = Array.getLength(object);</span><br><span class="line">            Log.e(TAG, <span class="string">"length = "</span> + length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获取对象的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getField</span><span class="params">(Class&lt;?&gt; cl, String fieldName, Object object)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = cl.getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射设置对象的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Class&lt;?&gt; cl, String fieldName, Object object, Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = cl.getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射合并两个数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">combineArray</span><span class="params">(Object firstArr, Object secondArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstLength = Array.getLength(firstArr);</span><br><span class="line">        <span class="keyword">int</span> secondLength = Array.getLength(secondArr);</span><br><span class="line">        <span class="keyword">int</span> length = firstLength + secondLength;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; componentType = firstArr.getClass().getComponentType();</span><br><span class="line">        Object newArr = Array.newInstance(componentType, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; firstLength) &#123;</span><br><span class="line">                Array.set(newArr, i, Array.get(firstArr, i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Array.set(newArr, i, Array.get(secondArr, i - firstLength));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心代码就这么多，运行一下程序看看效果。程序依然Crash了。抛出的异常如下<br><img src="/res/hotfix/exception.png" alt="异常"></p><p>原因是类预校验问题引起的，具体请看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect">安卓App热补丁动态修复技术介绍</a>在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程。如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，并且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED。如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错<code>Class ref in pre-verified class resolved to unexpected implementation</code>所以MainActivity的onClick()方法中引用另一个dex的类就会出现上文中的问题。正常的分包方案会保证相关类被打入同一个dex文件，想要使得patch补丁包可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用。</p><h4 id="字节码注入"><a href="#字节码注入" class="headerlink" title="字节码注入"></a>字节码注入</h4><p>要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，ASM等。其实QQ空间补丁方案的关键就在于字节码的注入而不是dex的注入。相比之下ASM提供一系列字节码指令，效率更高但是要求使用者对字节码操作有一定了解。而javaassist虽然效率差一些但是使用门槛较低，我们选择使用javaassist。关于javaassist可以网上搜索一些资料了解一下,这里不做详细描述。 </p><h5 id="用-Javassist-进行类字节码插桩"><a href="#用-Javassist-进行类字节码插桩" class="headerlink" title="用 Javassist 进行类字节码插桩"></a>用 Javassist 进行类字节码插桩</h5><p>正常App开发过程中，编译，打包过程都是Android Studio自动完成。如无特殊需求无需人为干预，但是要实现插桩就必须在Android Studio的自动化打包流程中加入插桩的过程。</p><ol><li>Gradle,Task,Transform,Plugin<br>Android Studio采用Gradle作为构建工具，所有有必要了解一下Gradle构建的基本概念和流程。如果不熟悉可以参考一下下列文章：<br><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html?spm=5176.100239.blogcont70337.18.IgYelX">Gradle学习系列之一——Gradle快速入门</a><br><a href="http://blog.csdn.net/innost/article/details/48228651?spm=5176.100239.blogcont70337.19.IgYelX">深入理解Android之Gradle</a></li></ol><p>Gradle的构建工程实质上是通过一系列的Task完成的，所以在构建apk的过程中就存在一个打包dex的任务。Gradle 1.5以上版本提供了一个新的API：Transform，官方文档对于Transform的描述是：</p><blockquote><p>The goal of this API is to simplify injecting custom class manipulations without having to deal with tasks, and to offer more flexibility on what is manipulated. The internal code processing (jacoco, progard, multi-dex) have all moved to this new mechanism already in 1.5.0-beta1.</p><blockquote><ol><li>The Dex class is gone. You cannot access it anymore through the variant API (the getter is still there for now but will throw an exception)</li><li>Transform can only be registered globally which applies them to all the variants. We’ll improve this shortly.</li><li>There’s no way to control ordering of the transforms.</li></ol></blockquote></blockquote><p>Transform任务一经注册就会被插入到任务执行队列中，并且其恰好在dex打包task之前。所以要想实现插桩就必须创建一个Transform类的Task。</p><p>1.1 Task</p><p>Gradle的执行脚本就是由一系列的Task完成的。Task有一个重要的概念：input的output。每一个task需要有输入input，然后对input进行处理完成后在输出output。</p><p>1.2 Plugin</p><p>Gradle的另外一个重要概念就是Plugin。整个Gradle的构建体系都是有一个一个的plugin构成的，实际Gradle只是一个框架，提供了基本task和指定标准。而具体每一个task的执行逻辑都定义在一个个的plugin中。详细的概念可以参考：Writing Custom Plugins<br>在Android开发中我们经常使用到的plugin有：”com.android.application”，”com.android.library”,”java”等等。每一个Plugin包含了一系列的task，所以执行gradle脚本的过程也就是执行目标脚本所apply的plugin所包含的task。</p><p>1.3 创建一个包含Transform任务的Plugin</p><ol><li>新建一个module，选择library module，module名字必须叫BuildSrc</li><li>删除module下的所有文件，除了build.gradle，清空build.gradle中的内容</li><li>然后新建以下目录 src-main-groovy</li><li>修改build.gradle如下，同步</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile 'com.android.tools.build:gradle:1.5.0'</span></span><br><span class="line"><span class="function">    compile 'org.javassist:javassist:3.20.0-GA'<span class="comment">//javaassist依赖</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>像普通module一样新建package和类，不过这里的类是以groovy结尾，新建类的时候选择file，并且以.groovy作为后缀</li><li>自定义Plugin：<br>PreDexTransform.groovy</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hotfix.plugin</span><br><span class="line"></span><br><span class="line">import com.android.build.api.transform.*</span><br><span class="line">import com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line">import org.apache.commons.codec.digest.DigestUtils</span><br><span class="line">import org.apache.commons.io.FileUtils</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class PreDexTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    private Project mProject;</span><br><span class="line"></span><br><span class="line">    PreDexTransform(Project project) &#123;</span><br><span class="line">        mProject = project</span><br><span class="line">        def libPath = project.project(&quot;:hack&quot;).buildDir.absolutePath.concat(&quot;/intermediates/classes/debug&quot;)</span><br><span class="line">        println libPath</span><br><span class="line">        Inject.appendClassPath(libPath)</span><br><span class="line">        Inject.appendClassPath(&quot;/Users/liyazhou/Library/Android/sdk/platforms/android-24/android.jar&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;preDex&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException &#123;</span><br><span class="line">        // 遍历transfrom的inputs</span><br><span class="line">        // inputs有两种类型，一种是目录，一种是jar，需要分别遍历。</span><br><span class="line">        inputs.each &#123;TransformInput input -&gt;</span><br><span class="line">            input.directoryInputs.each &#123;DirectoryInput directoryInput -&gt;</span><br><span class="line">                //TODO 注入代码</span><br><span class="line">                Inject.injectDir(directoryInput.file.absolutePath)</span><br><span class="line"></span><br><span class="line">                def dest = outputProvider.getContentLocation(directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br><span class="line">                // 将input的目录复制到output指定目录</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.jarInputs.each &#123;JarInput jarInput -&gt;</span><br><span class="line">                //TODO 注入代码</span><br><span class="line">                String jarPath = jarInput.file.absolutePath;</span><br><span class="line">                String projectName = project.rootProject.name;</span><br><span class="line">                if(jarPath.endsWith(&quot;classes.jar&quot;)</span><br><span class="line">                        &amp;&amp; jarPath.contains(&quot;exploded-aar/&quot;+projectName)</span><br><span class="line">                        // hotpatch module是用来加载dex，无需注入代码</span><br><span class="line">                        &amp;&amp; !jarPath.contains(&quot;exploded-aar/&quot;+projectName+&quot;/hotpatch&quot;)) &#123;</span><br><span class="line">                    Inject.injectJar(jarPath)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 重命名输出文件（同目录copyFile会冲突）</span><br><span class="line">                def jarName = jarInput.name</span><br><span class="line">                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">                if(jarName.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">                    jarName = jarName.substring(0,jarName.length()-4)</span><br><span class="line">                &#125;</span><br><span class="line">                def dest = outputProvider.getContentLocation(jarName+md5Name, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inject.groovy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hotfix.plugin</span><br><span class="line"></span><br><span class="line">import javassist.ClassPool</span><br><span class="line">import javassist.CtClass</span><br><span class="line">import javassist.NotFoundException</span><br><span class="line">import org.apache.commons.io.FileUtils</span><br><span class="line"></span><br><span class="line">public class Inject &#123;</span><br><span class="line">    private static ClassPool sPool = ClassPool.getDefault()</span><br><span class="line">    /**</span><br><span class="line">     * 添加classPath到ClassPool</span><br><span class="line">     * @param libPath</span><br><span class="line">     */</span><br><span class="line">    public static void appendClassPath(String libPath) throws NotFoundException &#123;</span><br><span class="line">        sPool.appendClassPath(libPath)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 遍历该目录下的所有class，对所有class进行代码注入。</span><br><span class="line">     * 其中以下class是不需要注入代码的：</span><br><span class="line">     * --- 1. R文件相关</span><br><span class="line">     * --- 2. 配置文件相关（BuildConfig）</span><br><span class="line">     * --- 3. Application</span><br><span class="line">     * @param path 目录的路径</span><br><span class="line">     */</span><br><span class="line">    public static void injectDir(String path) &#123;</span><br><span class="line">        sPool.appendClassPath(path)</span><br><span class="line">        File dir = new File(path)</span><br><span class="line">        if (dir.isDirectory()) &#123;</span><br><span class="line">            dir.eachFileRecurse &#123; File file -&gt;</span><br><span class="line"></span><br><span class="line">                String filePath = file.absolutePath</span><br><span class="line">                if (filePath.endsWith(&quot;.class&quot;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&apos;R$&apos;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&apos;R.class&apos;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&quot;BuildConfig.class&quot;)</span><br><span class="line">                        // 这里是application的名字，可自行配置</span><br><span class="line">                        &amp;&amp; !filePath.contains(&quot;HotFixApplication.class&quot;)) &#123;</span><br><span class="line">                    // 应用程序包名，可自行配置</span><br><span class="line">                    int index = filePath.indexOf(&quot;com/jinlin/base/hotfix&quot;)</span><br><span class="line">                    if (index != -1) &#123;</span><br><span class="line">                        int end = filePath.length() - 6 // .class = 6</span><br><span class="line">                        String className = filePath.substring(index, end).replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;)</span><br><span class="line">                        injectClass(className, path)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里需要将jar包先解压，注入代码后再重新生成jar包</span><br><span class="line">     * @path jar包的绝对路径</span><br><span class="line">     */</span><br><span class="line">    public static void injectJar(String path) &#123;</span><br><span class="line">        if (path.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">            File jarFile = new File(path)</span><br><span class="line"></span><br><span class="line">            // jar包解压后的保存路径</span><br><span class="line">            String jarZipDir = jarFile.getParent() + &quot;/&quot; + jarFile.getName().replace(&apos;.jar&apos;, &apos;&apos;)</span><br><span class="line"></span><br><span class="line">            // 解压jar包, 返回jar包中所有class的完整类名的集合（带.class后缀）</span><br><span class="line">            List classNameList = JarZipUtils.unzipJar(path, jarZipDir)</span><br><span class="line"></span><br><span class="line">            // 删除原来的jar包</span><br><span class="line">            jarFile.delete()</span><br><span class="line"></span><br><span class="line">            // 注入代码</span><br><span class="line">            sPool.appendClassPath(jarZipDir)</span><br><span class="line">            for (String className : classNameList) &#123;</span><br><span class="line">                if (className.endsWith(&quot;.class&quot;)</span><br><span class="line">                        &amp;&amp; !className.contains(&apos;R$&apos;)</span><br><span class="line">                        &amp;&amp; !className.contains(&apos;R.class&apos;)</span><br><span class="line">                        &amp;&amp; !className.contains(&quot;BuildConfig.class&quot;)) &#123;</span><br><span class="line">                    className = className.substring(0, className.length() - 6)</span><br><span class="line">                    injectClass(className, jarZipDir)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 从新打包jar</span><br><span class="line">            JarZipUtils.zipJar(jarZipDir, path)</span><br><span class="line"></span><br><span class="line">            // 删除目录</span><br><span class="line">            FileUtils.deleteDirectory(new File(jarZipDir))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void injectClass(String className, String path) &#123;</span><br><span class="line">        CtClass c = sPool.getCtClass(className)</span><br><span class="line">        if (c.isFrozen()) &#123;</span><br><span class="line">            c.defrost()</span><br><span class="line">        &#125;</span><br><span class="line">        def constructor = c.getConstructors()[0];</span><br><span class="line">        constructor.insertAfter(&quot;System.out.println(com.jinlin.base.hack.AntilazyLoad.class);&quot;)</span><br><span class="line">        c.writeFile(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JarZipUtil.groovy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.jar.JarEntry</span><br><span class="line">import java.util.jar.JarFile</span><br><span class="line">import java.util.jar.JarOutputStream</span><br><span class="line">import java.util.zip.ZipEntry</span><br><span class="line"></span><br><span class="line">public class JarZipUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将该jar包解压到指定目录</span><br><span class="line">     * @param jarPath jar包的绝对路径</span><br><span class="line">     * @param destDirPath jar包解压后的保存路径</span><br><span class="line">     * @return 返回该jar包中包含的所有class的完整类名类名集合，其中一条数据如：com.aitski.hotpatch.Xxxx.class</span><br><span class="line">     */</span><br><span class="line">    public static List unzipJar(String jarPath, String destDirPath) &#123;</span><br><span class="line"></span><br><span class="line">        List list = new ArrayList()</span><br><span class="line">        if (jarPath.endsWith(&apos;.jar&apos;)) &#123;</span><br><span class="line"></span><br><span class="line">            JarFile jarFile = new JarFile(jarPath)</span><br><span class="line">            Enumeration&lt;JarEntry&gt; jarEntrys = jarFile.entries()</span><br><span class="line">            while (jarEntrys.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry = jarEntrys.nextElement()</span><br><span class="line">                if (jarEntry.directory) &#123;</span><br><span class="line">                    continue</span><br><span class="line">                &#125;</span><br><span class="line">                String entryName = jarEntry.getName()</span><br><span class="line">                if (entryName.endsWith(&apos;.class&apos;)) &#123;</span><br><span class="line">                    String className = entryName.replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;)</span><br><span class="line">                    list.add(className)</span><br><span class="line">                &#125;</span><br><span class="line">                String outFileName = destDirPath + &quot;/&quot; + entryName</span><br><span class="line">                File outFile = new File(outFileName)</span><br><span class="line">                outFile.getParentFile().mkdirs()</span><br><span class="line">                InputStream inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">                FileOutputStream fileOutputStream = new FileOutputStream(outFile)</span><br><span class="line">                fileOutputStream &lt;&lt; inputStream</span><br><span class="line">                fileOutputStream.close()</span><br><span class="line">                inputStream.close()</span><br><span class="line">            &#125;</span><br><span class="line">            jarFile.close()</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新打包jar</span><br><span class="line">     * @param packagePath 将这个目录下的所有文件打包成jar</span><br><span class="line">     * @param destPath 打包好的jar包的绝对路径</span><br><span class="line">     */</span><br><span class="line">    public static void zipJar(String packagePath, String destPath) &#123;</span><br><span class="line"></span><br><span class="line">        File file = new File(packagePath)</span><br><span class="line">        JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(destPath))</span><br><span class="line">        file.eachFileRecurse &#123; File f -&gt;</span><br><span class="line">            String entryName = f.getAbsolutePath().substring(packagePath.length() + 1)</span><br><span class="line">            outputStream.putNextEntry(new ZipEntry(entryName))</span><br><span class="line">            if (!f.directory) &#123;</span><br><span class="line">                InputStream inputStream = new FileInputStream(f)</span><br><span class="line">                outputStream &lt;&lt; inputStream</span><br><span class="line">                inputStream.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>在app module下build.gradle文件中添加新插件：apply plugin: com.hotpatch.plugin.Register</p></li><li><p>创建hack.jar<br>创建一个单独的module，命名为com.hotpatch.plugin.AntilazyLoad</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jinlin.base.hack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntilazyLoad</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上一篇博客介绍的方法打包hack.jar。然后将hack.jar复制到app module下的assets目录中。另外注意：app module不能依赖hack module。之所以要创建一个hack module，同时人为地在dex打包过程中插入对其他hack.jar中类的依赖，就是要让apk文件在安装的时候不被打上CLASS_ISPREVERIFIED标记。<br>另外由于hack.jar位于assets中，所以必须要在加载patch_dex之前加载hack.jar。另外由于加载其他路径的dex文件都是在Application.onCreate()方法中执行的，此时还没有加载hack.jar，所以这就是为什么在上一章节插桩的时候不能在Application中插桩的原因。</p><p>插桩的过程介绍完了，整个热修复的过程也就差不多了，读者可以参考完整的代码进行demo试用：Hotpatch Demo</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 概述：&lt;/strong&gt;传统的app开发模式下，线上出现bug，必须通过发布新版本，用户手动更新后才能修复线上bug。那么是否存在一种方案可以在不发版的前提下修复线上bug？有！而且不只一种。今天首先来看下腾讯的QQ空间补丁方案&lt;br&gt;
    
    </summary>
    
      <category term="热修复" scheme="http://daijinlin.com/categories/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Dex分包、类加载机制" scheme="http://daijinlin.com/tags/Dex%E5%88%86%E5%8C%85%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
