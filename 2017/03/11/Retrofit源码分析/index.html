<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Retrofit源码分析 · J!nl!n's Blog</title><meta name="description" content="Retrofit源码分析 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Retrofit源码分析</h1><div class="post-info">Mar 11, 2017</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.6.0'</span></span><br></pre></td></tr></table></figure>
<h5 id="创建Retrofit并请求数据"><a href="#创建Retrofit并请求数据" class="headerlink" title="创建Retrofit并请求数据"></a>创建Retrofit并请求数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_URL = <span class="string">"https://api.github.com"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String login;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> contributions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contributor</span><span class="params">(String login, <span class="keyword">int</span> contributions)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.login = login;</span><br><span class="line">      <span class="keyword">this</span>.contributions = contributions;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</span><br><span class="line">        <span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</span><br><span class="line">        <span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a very simple REST adapter which points the GitHub API.</span></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(API_URL)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an instance of our GitHub API interface.</span></span><br><span class="line">    GitHub github = retrofit.create(GitHub<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a call instance for looking up Retrofit contributors.</span></span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to the library.</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = call.execute().body();</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h5 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建<code>Retrofit</code>对象</h5><p>创建<code>Retrofit</code>时，我们调用了<code>new Retrofit.Builder()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ①</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...省略代码专用...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Build a new &#123;<span class="doctag">@link</span> Retrofit&#125;.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Calling &#123;<span class="doctag">@link</span> #baseUrl&#125; is required before calling &#123;<span class="doctag">@link</span> #build()&#125;. All other methods</span></span><br><span class="line"><span class="comment">   * are optional.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Retrofit retrofit) &#123;</span><br><span class="line">      platform = Platform.get();</span><br><span class="line">      callFactory = retrofit.callFactory;</span><br><span class="line">      baseUrl = retrofit.baseUrl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not add the default BuiltIntConverters and platform-aware converters added by build().</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,</span><br><span class="line">          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();</span><br><span class="line">          i &lt; size; i++) &#123;</span><br><span class="line">        converterFactories.add(retrofit.converterFactories.get(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not add the default, platform-aware call adapters added by build().</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,</span><br><span class="line">          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();</span><br><span class="line">          i &lt; size; i++) &#123;</span><br><span class="line">        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      callbackExecutor = retrofit.callbackExecutor;</span><br><span class="line">      validateEagerly = retrofit.validateEagerly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The HTTP client used for requests.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This is a convenience method for calling &#123;<span class="doctag">@link</span> #callFactory&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callFactory(Objects.requireNonNull(client, <span class="string">"client == null"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify a custom call factory for creating &#123;<span class="doctag">@link</span> Call&#125; instances.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: Calling &#123;<span class="doctag">@link</span> #client&#125; automatically sets this value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">callFactory</span><span class="params">(okhttp3.Call.Factory factory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callFactory = Objects.requireNonNull(factory, <span class="string">"factory == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #baseUrl(HttpUrl)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(URL baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #baseUrl(HttpUrl)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the API base URL.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The specified endpoint values (such as with &#123;<span class="doctag">@link</span> GET <span class="doctag">@GET</span>&#125;) are resolved against this</span></span><br><span class="line"><span class="comment">     * value using &#123;<span class="doctag">@link</span> HttpUrl#resolve(String)&#125;. The behavior of this matches that of an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> &lt;a href=""&gt;&#125; link on a website resolving on the current URL.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Base URLs should always end in &#123;<span class="doctag">@code</span> /&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A trailing &#123;<span class="doctag">@code</span> /&#125; ensures that endpoints values which are relative paths will correctly</span></span><br><span class="line"><span class="comment">     * append themselves to a base which has path components.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Correct:&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/api/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Incorrect:&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method enforces that &#123;<span class="doctag">@code</span> baseUrl&#125; has a trailing &#123;<span class="doctag">@code</span> /&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Endpoint values which contain a leading &#123;<span class="doctag">@code</span> /&#125; are absolute.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Absolute values retain only the host from &#123;<span class="doctag">@code</span> baseUrl&#125; and ignore any specified path</span></span><br><span class="line"><span class="comment">     * components.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/api/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: /foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: /foo/bar/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://example.com/foo/bar/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Endpoint values may be a full URL.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Values which have a host replace the host of &#123;<span class="doctag">@code</span> baseUrl&#125; and values also with a scheme</span></span><br><span class="line"><span class="comment">     * replace the scheme of &#123;<span class="doctag">@code</span> baseUrl&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: https://github.com/square/retrofit/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: https://github.com/square/retrofit/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Base URL: http://example.com&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Endpoint: //github.com/square/retrofit/&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">      List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add converter factory for serialization and deserialization of objects. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> </span>&#123;</span><br><span class="line">      converterFactories.add(Objects.requireNonNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a call adapter factory for supporting service method return types other than &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Call&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">      callAdapterFactories.add(Objects.requireNonNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The executor on which &#123;<span class="doctag">@link</span> Callback&#125; methods are invoked when returning &#123;<span class="doctag">@link</span> Call&#125; from</span></span><br><span class="line"><span class="comment">     * your service method.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: &#123;<span class="doctag">@code</span> executor&#125; is not used for &#123;<span class="doctag">@linkplain</span> #addCallAdapterFactory custom method</span></span><br><span class="line"><span class="comment">     * return types&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">callbackExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = Objects.requireNonNull(executor, <span class="string">"executor == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a modifiable list of call adapter factories. */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.callAdapterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a modifiable list of converter factories. */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Converter.Factory&gt; converterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.converterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When calling &#123;<span class="doctag">@link</span> #create&#125; on the resulting &#123;<span class="doctag">@link</span> Retrofit&#125; instance, eagerly validate</span></span><br><span class="line"><span class="comment">     * the configuration of all methods in the supplied interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">validateEagerly</span><span class="params">(<span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the &#123;<span class="doctag">@link</span> Retrofit&#125; instance using the configured values.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: If neither &#123;<span class="doctag">@link</span> #client&#125; nor &#123;<span class="doctag">@link</span> #callFactory&#125; is called a default &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * OkHttpClient&#125; will be created and used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">      converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">      converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出，通过创建<code>Retrofit.Builder</code>对象运用<code>Builder</code>设计模式链式调用为<code>Retrofit.Builder</code>中的属性进行赋值,调用<code>build</code>方法时，将这些属性赋值给一个<code>Retrofit</code>对象，最后将这个<code>Retrofit</code>对象返回。我们看一下这里面的属性都是什么意思。</p>
<div id="sequence-0"></div>

<p>在介绍各个属性之前先介绍一下</p>
<h4 id="serviceMethodCache集合"><a href="#serviceMethodCache集合" class="headerlink" title="serviceMethodCache集合"></a>serviceMethodCache集合</h4><p>在Retrofit类的内部会首先创建一个集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这个集合的<code>Key</code>是一个<code>Mehtod</code>对象，<code>Value</code>是与<code>Key</code>相对应的<code>ServiceMethod</code>对象。<code>ServiceMethod</code>对象是根据<code>Method</code>解析之后获得，这里面包含了<code>Method</code>的方法注解、参数注解等一些列属性。我们从集合的名字就能看出来，这里面是将<code>Method</code>和对应<code>ServiceMethod</code>进行缓存的集合，这种方法我们在<code>EventBus</code>源码解析的时候就遇到过。这样做的目的就是为了加快运行速度，我们在今后的开发中也能加以借鉴并运用。有关<code>Method</code>和<code>ServiceMethod</code>都会在下文中进行讲解，这里如果不知道是什么意思也没关系。</p>
<h3 id="Platform平台信息"><a href="#Platform平台信息" class="headerlink" title="Platform平台信息"></a>Platform平台信息</h3><p>这个对象是<code>Retrofit.Builder</code>对象中进行定义的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private final Platform platform;</span><br><span class="line">    ...</span><br><span class="line">    Builder(Retrofit retrofit) &#123;</span><br><span class="line">      platform = Platform.get();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">class Platform &#123;</span><br><span class="line">  private static final Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  static Platform get() &#123;</span><br><span class="line">    return PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line">  private static Platform findPlatform() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class.forName(&quot;android.os.Build&quot;);</span><br><span class="line">      // 如果是Android平台</span><br><span class="line">      if (Build.VERSION.SDK_INT != 0) &#123;</span><br><span class="line">        return new Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 如果是Java平台</span><br><span class="line">      Class.forName(&quot;java.util.Optional&quot;);</span><br><span class="line">      return new Java8();</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Platform();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在这里我们可以看到这里会根据不同的平台信息返回对应的<code>Platform</code>对象，分别是<code>Android</code>和<code>Java8</code>,重点分析一下<code>Android</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static class Android extends Platform &#123;</span><br><span class="line">    // 1、判断方法是否是默认方法，所谓默认方法是指是否是Object类中已经定义的方法</span><br><span class="line">    //    如果是就返回true，否则返回false</span><br><span class="line">    @IgnoreJRERequirement // Guarded by API check.</span><br><span class="line">    @Override boolean isDefaultMethod(Method method) &#123;</span><br><span class="line">      if (Build.VERSION.SDK_INT &lt; 24) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return method.isDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public Executor defaultCallbackExecutor() &#123;</span><br><span class="line">      // 2、获取一个Executor对象，这个对象代表了回调执行器</span><br><span class="line">      return new MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、获得Android版本下默认的网络适配器集合</span><br><span class="line">    @Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">        @Nullable Executor callbackExecutor) &#123;</span><br><span class="line">      if (callbackExecutor == null) throw new AssertionError();</span><br><span class="line">      // 默认的请求适配器</span><br><span class="line">      DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);</span><br><span class="line">      // 如果Android系统版本大于24，则会返回一个CompletableFutureCallAdapterFactory和DefaultCallAdapterFactory组成的集合。</span><br><span class="line">      // 否则返回只有DefaultCallAdapterFactory对象的集合</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24</span><br><span class="line">        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">        : singletonList(executorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override int defaultCallAdapterFactoriesSize() &#123;</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24 ? 2 : 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4、获取Android版本下默认的转换器集合</span><br><span class="line">    @Override List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">      // 如果Android系统版本大于24，则会返回只有CompletableFutureCallAdapterFactory对象的集合</span><br><span class="line">      // 否则返回一个长度为0的集合</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24</span><br><span class="line">          ? singletonList(OptionalConverterFactory.INSTANCE)</span><br><span class="line">          : Collections.&lt;Converter.Factory&gt;emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override int defaultConverterFactoriesSize() &#123;</span><br><span class="line">      return Build.VERSION.SDK_INT &gt;= 24 ? 1 : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.1 这里返回的是Android主线程的回调</span><br><span class="line">    // 也就是说当网络请求完成后会回调到Android主线程中去，这也是Retrofit和OkHttp的不同点之一</span><br><span class="line">    static class MainThreadExecutor implements Executor &#123;</span><br><span class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在<code>Android</code>平台里面我们关注四点：</p>
<blockquote>
<p>1、判断传入的<code>Method</code>对象是否是默认方法<br> 2、获取执行回调器，这里默认的是将网络请求结果回调到<code>Android</code>主线程中。<br> 3、获得<code>Android</code>版本下默认的网络适配器集合，这里会根据<code>Android</code>版本号进行返回。<br> 4、获取<code>Android</code>版本下默认的转换器集合，它也是会根据<code>Android</code>版本号进行返回。</p>
</blockquote>
<p>这里有必要跟大家提前说一下，有关请求适配器（<code>CallAdapter.Factory</code>）和转换器（<code>Converter.Factory</code>）会在下面的文章中给出，这里先留一个印象。</p>
<h3 id="callFactory对象"><a href="#callFactory对象" class="headerlink" title="callFactory对象"></a>callFactory对象</h3><p>我们从单词的表面意思可以知道这个是请求工厂类，这个请求工厂类<code>okhttp3</code>的<code>Call</code>类型，这也说明了<code>Retrofit</code>是基于<code>okhttp</code>进行封装的。定义<code>callFactory</code>对象我们可以调用<code>Retrofit.Builder.callFactory</code>方法进行设置,在<code>Retrofit.Builder.build</code>方法中会将这个对象赋值个<code>Retrofit</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private @Nullable okhttp3.Call.Factory callFactory;</span><br><span class="line">    ...</span><br><span class="line">    public Builder callFactory(okhttp3.Call.Factory factory) &#123;</span><br><span class="line">      this.callFactory = checkNotNull(factory, &quot;factory == null&quot;);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">      if (callFactory == null) &#123;</span><br><span class="line">        callFactory = new OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我们可以看到当我们没有调用<code>Retrofit.Builder.callFactory</code>方法时，会给我们默认设置一个<code>OkHttpClient</code>对象。</p>
<h3 id="baseUrl基础请求路径"><a href="#baseUrl基础请求路径" class="headerlink" title="baseUrl基础请求路径"></a>baseUrl基础请求路径</h3><p><code>baseUrl</code>作为请求的基础路径，它与我们在<code>HTTP API</code>接口中定义的方法注解中的相对路径组成了完整的请求路径。我们可以调用<code>Retrofit.Builder.baseUrl</code>方法进行设置，最后通过<code>Retrofit.Builder.build</code>方法中会将这个对象赋值个<code>Retrofit</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private @Nullable HttpUrl baseUrl;</span><br><span class="line">    ...</span><br><span class="line">    // 传入URL</span><br><span class="line">    public Builder baseUrl(URL baseUrl) &#123;</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      return baseUrl(HttpUrl.get(baseUrl.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 传入String</span><br><span class="line">    public Builder baseUrl(String baseUrl) &#123;</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      return baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Builder baseUrl(HttpUrl baseUrl) &#123;</span><br><span class="line">      // 判空</span><br><span class="line">      checkNotNull(baseUrl, &quot;baseUrl == null&quot;);</span><br><span class="line">      // 将url进行分割</span><br><span class="line">      List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">      // 如果baseUrl不是以&quot;/&quot;结尾，抛出异常</span><br><span class="line">      if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);</span><br><span class="line">      &#125;</span><br><span class="line">      this.baseUrl = baseUrl;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      // 再次判空</span><br><span class="line">      if (baseUrl == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      // 传入Retrofit对象中</span><br><span class="line">      return new Retrofit(..., baseUrl, ...,</span><br><span class="line">          ..., ..., ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>设置的流程：</p>
<blockquote>
<p>1、 可以调用两种方法，分别传入<code>URL</code>和<code>String</code>。<br> 2、 对<code>baseUrl</code>进行判空，然后进行分割，如果是以<code>&quot;/&quot;</code>结尾会抛出异常。<br> 3、 再进行一次判空，最后赋值给<code>Retrofit</code>对象。</p>
</blockquote>
<h3 id="converterFactories转换器集合"><a href="#converterFactories转换器集合" class="headerlink" title="converterFactories转换器集合"></a>converterFactories转换器集合</h3><p><code>converterFactories</code>集合内部存放的都是<code>Converter.Factory</code>对象，我们可以调用<code>Retrofit.Builder.addConverterFactory</code>方法进行添加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    public Builder addConverterFactory(Converter.Factory factory) &#123;</span><br><span class="line">      // 检查factory是否为null，然后加入到集合中</span><br><span class="line">      converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   public Retrofit build() &#123;</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(</span><br><span class="line">          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">      // Add the built-in converter factory first. This prevents overriding its behavior but also</span><br><span class="line">      // ensures correct behavior when using converters that consume all types.</span><br><span class="line">      // 首先添加BuiltInConverters</span><br><span class="line">      converterFactories.add(new BuiltInConverters());</span><br><span class="line">      // 然后添加调用addConverterFactory方法传入的Converter.Factory的集合</span><br><span class="line">      converterFactories.addAll(this.converterFactories);</span><br><span class="line">      // 最后添加platform默认的Converter.Factory集合</span><br><span class="line">      converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">      // 根据converterFactories创建一个不可变集合传入</span><br><span class="line">      return new Retrofit(..., ..., unmodifiableList(converterFactories),</span><br><span class="line">          ..., ..., ...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>Converter.Factory</code>从字面意思我们能猜出它是和转换有关，具体的探究会放到下文中。</p>
<h3 id="callAdapterFactories请求适配器集合"><a href="#callAdapterFactories请求适配器集合" class="headerlink" title="callAdapterFactories请求适配器集合"></a>callAdapterFactories请求适配器集合</h3><p><code>callAdapterFactories</code>集合中存放的是<code>CallAdapter.Factory</code>对象，调用<code>Retrofit.Builder.addCallAdapterFactory</code>方法来设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123;</span><br><span class="line">      callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   public Retrofit build() &#123;</span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</span><br><span class="line">      // 这里不仅添加了调用addCallAdapterFactory方法时设置的CallAdapter.Factory对象</span><br><span class="line">      // 同时还添加了platform中默认的CallAdapter.Factory对象</span><br><span class="line">      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line">      </span><br><span class="line">      // 根据callAdapterFactories创建一个不可变的集合传入</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          unmodifiableList(callAdapterFactories), ..., ...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>CallAdapter.Factory</code>从字面意思可以看出是请求适配器，有关于请求适配器是什么，也会放到下文中进行探究。</p>
<h3 id="callbackExecutor回调执行器"><a href="#callbackExecutor回调执行器" class="headerlink" title="callbackExecutor回调执行器"></a>callbackExecutor回调执行器</h3><p>设置回调执行器我们可以通过<code>Retrofit.Builder.callbackExecutor</code>来设置，默认的会使用<code>Platform</code>的回调执行器，也就是会将请求的执行结果回调到<code>Android</code>主线程中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private @Nullable Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    public Builder callbackExecutor(Executor executor) &#123;</span><br><span class="line">      this.callbackExecutor = checkNotNull(executor, &quot;executor == null&quot;);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">      if (callbackExecutor == null) &#123;</span><br><span class="line">        // 默认为platform中的回调执行器，会将请求结果回调到Android主线程</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          ..., callbackExecutor, ...);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="validateEagerly提前验证方法标识"><a href="#validateEagerly提前验证方法标识" class="headerlink" title="validateEagerly提前验证方法标识"></a>validateEagerly提前验证方法标识</h3><p>这个标识表示是否需要提前验证<code>HTTP API</code>接口中的方法，我们通过调用<code>Retrofit.Builder.validateEagerly</code>方法进行设置，默认为<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line"> ...</span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    private boolean validateEagerly;</span><br><span class="line">    ...</span><br><span class="line">    public Builder validateEagerly(boolean validateEagerly) &#123;</span><br><span class="line">      this.validateEagerly = validateEagerly;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      ...</span><br><span class="line">      return new Retrofit(..., ..., ...,</span><br><span class="line">          ..., ..., validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>到这里我们已经把<code>Retrofit.Buidler</code>中的属性分析完了，但是我们还遗留了两个问题：<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>。这两个类到底是做什么的？这里来看一下。</p>
<h3 id="CallAdapter-Factory"><a href="#CallAdapter-Factory" class="headerlink" title="CallAdapter.Factory"></a>CallAdapter.Factory</h3><p>既然我们已经知道这个类是用来进行请求适配的，那么我们看一下里面是怎么运行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将响应类型为R的Call调整为T类型</span><br><span class="line">public interface CallAdapter&lt;R, T&gt; &#123;</span><br><span class="line">  // 返回此适配器将HTTP响应正文转换为Java时使用的值类型对象。 </span><br><span class="line">  // 例如, Call &lt;Repo&gt;的响应类型是Repo。 这个类型用于准备传递给adapt的call。</span><br><span class="line">  Type responseType();</span><br><span class="line">  // 这个方法是将Call&lt;R&gt;对象转成代理类T</span><br><span class="line">  T adapt(Call&lt;R&gt; call);</span><br><span class="line">  //CallAdapter工厂，retrofit默认的DefaultCallAdapterFactory其中不对Call做处理，是直接返回Call。</span><br><span class="line">  abstract class Factory &#123;</span><br><span class="line">    // 在这个方法中判断returnType是否是我们支持的类型，</span><br><span class="line">    // DefaultCallAdapterFactory没有做处理，因为在定义HTTP API接口中的方式时，returnType 即为Call&lt;Requestbody&gt;</span><br><span class="line">    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型</span><br><span class="line">    // 不支持时返回null</span><br><span class="line">    // 返回值必须是Custom并且带有泛型（参数类型），根据HTTP API接口中的方法返回值，确定returnType</span><br><span class="line">    // 如： CustomCall&lt;String&gt; getCategories()，那确定returnType就是CustomCall&lt;String&gt;</span><br><span class="line">    public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br><span class="line">        </span><br><span class="line">    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody</span><br><span class="line">    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;</span><br><span class="line">      return Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 用于获取泛型的原始类型</span><br><span class="line">    // 如Call&lt;Requestbody&gt;拿到的原始类型就是Call</span><br><span class="line">    protected static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      return Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>看了这么多代码，可能还是有点云里雾里，我们找两个例子看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">        Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    </span><br><span class="line">    // 如果返回值不是Call类型返回空</span><br><span class="line">    // 也就是说我们在定义HTTP API接口中的方法时，返回值不是Call&lt;?&gt;类型的，将不会处理</span><br><span class="line">    if (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override public Type responseType() &#123;</span><br><span class="line">        return ...;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">        return ...;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我们经常会看到<code>Retrofit + RxJava</code>进行网络封装，如果要将<code>Retrofit</code>和<code>RxJava</code>结合到一起就需要<code>RxJavaCallAdapterFactory</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RxJavaCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  ...</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    Class&lt;?&gt; rawType = getRawType(returnType);</span><br><span class="line">    boolean isSingle = rawType == Single.class;</span><br><span class="line">    boolean isCompletable = rawType == Completable.class;</span><br><span class="line">    // 如果返回值不是Observable类型返回空</span><br><span class="line">    // 也就是说我们在定义HTTP API接口中的方法时，返回值不是Observable&lt;?&gt;类型的，将不会处理</span><br><span class="line">    if (rawType != Observable.class &amp;&amp; !isSingle &amp;&amp; !isCompletable) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>经过上面两个例子我们应该对<code>CallAdapter.Factory</code>有所了解了，这里来解释一下吧。</p>
<blockquote>
<p>在我们定义<code>HTTP API</code>接口时，里面方法的返回值需要由<code>Retrofit</code>中添加的<code>CallAdapter.Factory</code>决定，如果定义了<code>CallAdapter.Factory</code>不支持的类型，请求将不会被执行。</p>
</blockquote>
<h3 id="Converter-Factory"><a href="#Converter-Factory" class="headerlink" title="Converter.Factory"></a>Converter.Factory</h3><p>从上面我们也知道<code>Converter.Factory</code>适用于转换的，我们看下源码，看看它到底是怎么转换的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将F类型转成T类型</span><br><span class="line">public interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">  @Nullable T convert(F value) throws IOException;</span><br><span class="line">  abstract class Factory &#123;</span><br><span class="line">    // 判断能否将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">    // 如果不能直接返回null，反之返回对应的Converter.Factory对象</span><br><span class="line">    // type是由CallAdapter 接口里面的responseType()函数返回的。</span><br><span class="line">    public @Nullable Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class="line">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将API方法的输入参数类型从 type转换为requestBody</span><br><span class="line">    // 用于转换被注解@Body, @Part 和 @PartMap标记的类型</span><br><span class="line">    public @Nullable Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将API方法的输入参数类型从 type 转换为String</span><br><span class="line">    // 用于转换被注解 @Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型</span><br><span class="line">    public @Nullable Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从type中提取index处泛型参数的上界</span><br><span class="line">    // 例如Map&lt;String, ? extends Runnable&gt;索引为1处返回Runnable</span><br><span class="line">    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;</span><br><span class="line">      return Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从type中提取原始类类型</span><br><span class="line">    // 例如：List&lt;? extends Runnable&gt;返回的是List.class</span><br><span class="line">    protected static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      return Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>看完之后还是有点懵懵哒，我们还是找一个列子，还记的我们调用<code>Retrofit.Builder.addConverterFactory</code>传入的<code>GsonConverterFactory</code>吗，看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个Converter.Factory类使用Gson来解析Json</span><br><span class="line">public final class GsonConverterFactory extends Converter.Factory &#123;</span><br><span class="line">  // 使用默认的Gson对象来创建GsonConverterFactory</span><br><span class="line">  // 通过Gson将对象序列化或者反序列化成Json字符串</span><br><span class="line">  public static GsonConverterFactory create() &#123;</span><br><span class="line">    return create(new Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static GsonConverterFactory create(Gson gson) &#123;</span><br><span class="line">    // 检查传入的gson对象是否为空</span><br><span class="line">    // 如果为空直接抛出异常</span><br><span class="line">    if (gson == null) throw new NullPointerException(&quot;gson == null&quot;);</span><br><span class="line">    return new GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">      Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    return new GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123;</span><br><span class="line">  private final Gson gson;</span><br><span class="line">  private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    this.gson = gson;</span><br><span class="line">    this.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public T convert(ResponseBody value) throws IOException &#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    try &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      if (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        throw new JsonIOException(&quot;JSON document was not fully consumed.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将API方法的输入参数类型从 type转换为requestBody</span><br><span class="line">final class GsonRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123;</span><br><span class="line">  private static final MediaType MEDIA_TYPE = MediaType.get(&quot;application/json; charset=UTF-8&quot;);</span><br><span class="line">  private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line">  </span><br><span class="line">  private final Gson gson;</span><br><span class="line">  private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonRequestBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    this.gson = gson;</span><br><span class="line">    this.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public RequestBody convert(T value) throws IOException &#123;</span><br><span class="line">    Buffer buffer = new Buffer();</span><br><span class="line">    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">    JsonWriter jsonWriter = gson.newJsonWriter(writer);</span><br><span class="line">    adapter.write(jsonWriter, value);</span><br><span class="line">    jsonWriter.close();</span><br><span class="line">    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>从<code>GsonRequestBodyConverter</code>的例子中我们总结一下<code>Converter.Factory</code>的作用：</p>
<blockquote>
<p><code>Converter.Factory</code>是将<code>HTTP API</code>方法中的参数在<code>requestBody和responseBody</code>之间进行转换。</p>
</blockquote>
<p>到这里我们才算真正的把<code>Retrofit.Buidler</code>中所涉及的属性和类分析完，休息一下，进行下半部分的分析。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/5/16ed536ac558c073?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="调用Retrofit-create方法"><a href="#调用Retrofit-create方法" class="headerlink" title="调用Retrofit.create方法"></a>调用Retrofit.create方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    // 1、验证HTTP API接口</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      // 2、验证HTTP API接口中的方法</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3、动态代理，整个Retrofit的核心之一</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line">          private final Object[] emptyArgs = new Object[0];</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这段代码中有给出了三处注释，我们逐个看一下</p>
<h3 id="注释1：Utils-validateServiceInterface-Class-service"><a href="#注释1：Utils-validateServiceInterface-Class-service" class="headerlink" title="注释1：Utils.validateServiceInterface(Class service):"></a>注释1：Utils.validateServiceInterface(Class service):</h3><p>从<code>注释1</code>中我们得知这个方法是对我们定义的<code>HTTP API</code>接口进行验证，看一下它是怎么验证的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class Utils &#123;</span><br><span class="line">    ...</span><br><span class="line">  static &lt;T&gt; void validateServiceInterface(Class&lt;T&gt; service) &#123;</span><br><span class="line">    if (!service.isInterface()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (service.getInterfaces().length &gt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;API interfaces must not extend other interfaces.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里做了两步验证：</p>
<blockquote>
<p>1、验证传入的对象是否是一个接口，如果不是直接抛出异常。<br> 2、如果是一个接口，看看这个接口是否是继接口，如果继承了，也会抛出异常。</p>
</blockquote>
<h3 id="注释2：eagerlyValidateMethods-Class-lt-gt-service"><a href="#注释2：eagerlyValidateMethods-Class-lt-gt-service" class="headerlink" title="注释2：eagerlyValidateMethods(Class&lt;?&gt; service)"></a>注释2：eagerlyValidateMethods(Class&lt;?&gt; service)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里是<code>注释2</code>处的代码，<code>validateEagerly</code>这个变量在之前的代码注释中已经给出了解释，它是对方法进行提前验证的标识，一般为<code>false</code>，但是我们还是需要看一下这个方法中是怎么进行验证的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  private void eagerlyValidateMethods(Class&lt;?&gt; service) &#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    //获得接口中所有定义的方法，并遍历</span><br><span class="line">    for (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">      // 1、判断是否如果是default方法，Android平台返回false</span><br><span class="line">      // 2、判断方法是否是静态方法</span><br><span class="line">      if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">        // 如果符合条件，直接加载</span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在<code>eagerlyValidateMethods</code>方法中也是做了两件事：</p>
<blockquote>
<p>1、找出接口中的所有方法，看看是否符合条件。<br> 2、如果符合条件，直接加载方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  //缓存集合，支持多线程访问、线程安全</span><br><span class="line">  //key：Method</span><br><span class="line">  //value：Method对应的ServiceMethod</span><br><span class="line">  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    // 1、首先从方法缓存集合中获取</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    // 2、如果有，直接返回</span><br><span class="line">    if (result != null) return result;</span><br><span class="line">    </span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line">      // 3、在再次确认缓存中的是否有方法</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        // 4、对方法的注解进行解析</span><br><span class="line">        result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">        // 5、将方法传到方法缓存集合中</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>loadServiceMethod</code>这里做了三步事情：</p>
<blockquote>
<p>1、根据传入的<code>Method</code>从缓存集合中获取对应的<code>ServiceMethod</code>对象，如果有，直接返回；如果没有，对集合进行加锁，再次获取。这种方法将对象缓存起来的做法在分析<code>EventBus</code>源码的时候就见过，目的就是为了提高效率。<br> 2、如果上一步中没有获取到<code>ServiceMethod</code>对象，将对<code>Method</code>进行解析。<br> 3、将<code>Method</code>和它对应的<code>ServiceMethod</code>对象存入到缓存集合中，返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ServiceMethod&lt;T&gt; &#123;</span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      throw methodError(method,</span><br><span class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnType == void.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>注释2</code>处的验证<code>HTTP API</code>接口中的方法我们先分析到这里，上面这段代码我们先不进行探究，因为很快我们又会看到，具体流程会在接下来的分析中详细探究，希望大家对这个方法有所印象。我们先来总结一下<code>注释2</code>处都是做了哪些事情：</p>
<blockquote>
<p>1、获取到<code>HTTP API</code>接口中所有方法，遍历加载这些方法。<br> 2、加载的过程中先去缓存集合中看一下有没有与<code>Method</code>对应的<code>ServiceMethod</code>对象，如果有，直接返回；如果没有，对<code>Method</code>进行解析，将解析结果封装成一个<code>ServiceMethod</code>对象，并存入到缓存集合中，最后将<code>ServiceMethod</code>返回。</p>
</blockquote>
<h3 id="注释3-动态代理"><a href="#注释3-动态代理" class="headerlink" title="注释3: 动态代理"></a>注释3: 动态代理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          // 1、这里返回的是Android平台</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line">          // 2、创建一个Object数组，长度为0</span><br><span class="line">          private final Object[] emptyArgs = new Object[0];</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            // 3、如果该方法是来自Object的方法，则遵从正常调用。</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            // 4、在Android平台始终返回false</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            // 5、加载方法</span><br><span class="line">            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>当调用<code>retrofit.create(ServiceApi.class)</code>实际上会生成一个<code>ServiceApi</code>的代理类对象。从前面的基础知识准备中我们知道，当调用代理类对象中的方法时，最终会调用创建代理类对象所传入的第三个参数<code>InvocationHandler.invoke</code>方法回调中去，在这个回调中对方法进行处理。<code>retrofit.create(ServiceApi.class)</code>方法的主要流程已经在上面的代码注释中给出，这个方法最重要的一步是最后的加载方法，我们来看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    if (result != null) return result;</span><br><span class="line"></span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>嗯哼？上面这段代码是不是非常熟悉？没错，在之提前验证方法的过程中，我们已经见到过这个方法，方法中的流程这里就不再赘述，我们继续往下看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ServiceMethod&lt;T&gt; &#123;</span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    // 1、根据传入的retrofit和method对象封装成RequestFactory</span><br><span class="line">    // 这一步主要是进行解析注解</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    // 2、获取方法的returnType</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    // 3、对方法的returnType进行验证</span><br><span class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      throw methodError(method,</span><br><span class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnType == void.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、对方法的注解进行解析，并封装成一个ServiceMethod对象</span><br><span class="line">    // 这里返回的是HttpServiceMethod对象，他是ServiceMethod的子类</span><br><span class="line">    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>哎呦，这个方法我们也见过，当时只是加深了一下印象，并没有对其进行探究。这个方法中做了四步操作，它们对应的操作已经在上面代码的注释中给出。我们重点来看一下第一步和第四步。</p>
<h4 id="RequestFactory-parseAnnotations-retrofit-method"><a href="#RequestFactory-parseAnnotations-retrofit-method" class="headerlink" title="RequestFactory.parseAnnotations(retrofit, method)"></a>RequestFactory.parseAnnotations(retrofit, method)</h4><p>这个方法主要是根据传入的<code>retrofit</code>对象和<code>method</code>对象封装成<code>RequestFactory</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class RequestFactory &#123;</span><br><span class="line">  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    return new Builder(retrofit, method).build();</span><br><span class="line">  &#125;</span><br><span class="line">  // method对象</span><br><span class="line">  private final Method method;</span><br><span class="line">  // 基础url</span><br><span class="line">  private final HttpUrl baseUrl;</span><br><span class="line">  // 请求方法</span><br><span class="line">  final String httpMethod;</span><br><span class="line">  // 相对url，它与基础url组成请求路径</span><br><span class="line">  private final @Nullable String relativeUrl;</span><br><span class="line">  // 请求头</span><br><span class="line">  private final @Nullable Headers headers;</span><br><span class="line">  // 表示具体请求中的媒体类型信息</span><br><span class="line">  private final @Nullable MediaType contentType;</span><br><span class="line">  // 是否有请求体</span><br><span class="line">  private final boolean hasBody;</span><br><span class="line">  // 是否是Form表单提交</span><br><span class="line">  private final boolean isFormEncoded;</span><br><span class="line">  // 是否支持文件上传的Form表单</span><br><span class="line">  private final boolean isMultipart;</span><br><span class="line">  // </span><br><span class="line">  private final ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">  // 是否是kotlin挂起函数</span><br><span class="line">  final boolean isKotlinSuspendFunction;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">   * Inspects the annotations on an interface method to construct a reusable service method. This</span><br><span class="line">   * requires potentially-expensive reflection so it is best to build each service method only once</span><br><span class="line">   * and reuse it. Builders cannot be reused.</span><br><span class="line">   */</span><br><span class="line">  // 检查接口方法上的注释以构造可重用的服务方法。这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。</span><br><span class="line">  // 构建器不能重用。</span><br><span class="line">  static final class Builder &#123;</span><br><span class="line">    private static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;</span><br><span class="line">    private static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\&#123;(&quot; + PARAM + &quot;)\\&#125;&quot;);</span><br><span class="line">    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line">    // 传入的retrofit对象</span><br><span class="line">    final Retrofit retrofit;</span><br><span class="line">    // 传入的method对象</span><br><span class="line">    final Method method;</span><br><span class="line">    // method对象中的注解</span><br><span class="line">    final Annotation[] methodAnnotations;</span><br><span class="line">    // method中参数注解数组</span><br><span class="line">    final Annotation[][] parameterAnnotationsArray;</span><br><span class="line">    // method中参数类型数组</span><br><span class="line">    final Type[] parameterTypes;</span><br><span class="line">    </span><br><span class="line">    boolean gotField;</span><br><span class="line">    boolean gotPart;</span><br><span class="line">    boolean gotBody;</span><br><span class="line">    boolean gotPath;</span><br><span class="line">    boolean gotQuery;</span><br><span class="line">    boolean gotQueryName;</span><br><span class="line">    boolean gotQueryMap;</span><br><span class="line">    boolean gotUrl;</span><br><span class="line">    @Nullable String httpMethod;</span><br><span class="line">    boolean hasBody;</span><br><span class="line">    boolean isFormEncoded;</span><br><span class="line">    boolean isMultipart;</span><br><span class="line">    @Nullable String relativeUrl;</span><br><span class="line">    @Nullable Headers headers;</span><br><span class="line">    @Nullable MediaType contentType;</span><br><span class="line">    @Nullable Set&lt;String&gt; relativeUrlParamNames;</span><br><span class="line">    @Nullable ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">    boolean isKotlinSuspendFunction;</span><br><span class="line">    </span><br><span class="line">    Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      this.retrofit = retrofit;</span><br><span class="line">      this.method = method;</span><br><span class="line">      // 获取方法注解</span><br><span class="line">      this.methodAnnotations = method.getAnnotations();</span><br><span class="line">      // 获取方法参数类型</span><br><span class="line">      this.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      // 获取方法注解数组</span><br><span class="line">      this.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RequestFactory build() &#123;</span><br><span class="line">      // 遍历注解，对注解进行解析</span><br><span class="line">      for (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (httpMethod == null) &#123;</span><br><span class="line">        throw methodError(method, &quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!hasBody) &#123;</span><br><span class="line">        if (isMultipart) &#123;</span><br><span class="line">          throw methodError(method,</span><br><span class="line">              &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isFormEncoded) &#123;</span><br><span class="line">          throw methodError(method, &quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class="line">              + &quot;request body (e.g., @POST).&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      int parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        parameterHandlers[p] =</span><br><span class="line">            parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        throw methodError(method, &quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        throw methodError(method, &quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        throw methodError(method, &quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        throw methodError(method, &quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 返回一个RequestFactory对象</span><br><span class="line">      return new RequestFactory(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对注解进行解析</span><br><span class="line">    private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">      // 判断解析类型，根据注解的类型进行相应的解析</span><br><span class="line">      if (annotation instanceof DELETE) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof GET) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof HEAD) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof PATCH) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof POST) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof PUT) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);</span><br><span class="line">      &#125; else if (annotation instanceof OPTIONS) &#123;</span><br><span class="line">        parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);</span><br><span class="line">      &#125; else if (annotation instanceof HTTP) &#123;</span><br><span class="line">        HTTP http = (HTTP) annotation;</span><br><span class="line">        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">      &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">        if (headersToParse.length == 0) &#123;</span><br><span class="line">          throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        headers = parseHeaders(headersToParse);</span><br><span class="line">      &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">        if (isFormEncoded) &#123;</span><br><span class="line">          throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isMultipart = true;</span><br><span class="line">      &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">        if (isMultipart) &#123;</span><br><span class="line">          throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isFormEncoded = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //解析Http请求方法和路径</span><br><span class="line">    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 解析请求头</span><br><span class="line">    private Headers parseHeaders(String[] headers) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里没有把<code>RequestFactory</code>中所有的方法列出来，但是我们从上面的代码和注释中我们可以知道这个类都是做了哪些操作：</p>
<blockquote>
<p>1、创建一个<code>RequestFactory.Builder</code>对象，同时传入<code>Retrofit</code>对象和<code>Method</code>对象。<br> 2、创建完<code>RequestFactory.Builder</code>对象之后，会对<code>Method</code>对象的注解进行解析，解析的同时会对<code>Buidler</code>对象进行初始化。<br> 3、最后通过<code>build</code>方法，创建一个<code>RequestFactory</code>对象，并进行初始化。</p>
</blockquote>
<h4 id="HttpServiceMethod-parseAnnotations-retrofit-method-requestFactory"><a href="#HttpServiceMethod-parseAnnotations-retrofit-method-requestFactory" class="headerlink" title="HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)"></a>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</h4><p>在得到<code>RequestFactory</code>对象之后，会调用<code>HttpServiceMethod.parseAnnotations</code>方法，将获取的<code>RequestFactory</code>传入，我们看一下这里面都是做了什么操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Adapts an invocation of an interface method into an HTTP call. */</span><br><span class="line">// 将接口方法的调用调整为HTTP请求</span><br><span class="line">abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Inspects the annotations on an interface method to construct a reusable service method that</span><br><span class="line">   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service</span><br><span class="line">   * method only once and reuse it.</span><br><span class="line">   */</span><br><span class="line">  // 检查接口方法上的注释，以构造一个可重用的服务方法，该服务方法表示HTTP。</span><br><span class="line">  // 这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。</span><br><span class="line">  static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(</span><br><span class="line">      Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;</span><br><span class="line">    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    boolean continuationWantsResponse = false;</span><br><span class="line">    boolean continuationBodyNullable = false;</span><br><span class="line"></span><br><span class="line">    // 获得所有方法上的所有注解</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    // 方法返回值类型</span><br><span class="line">    Type adapterType;</span><br><span class="line">    // 是否是kotlin挂起函数</span><br><span class="line">    if (isKotlinSuspendFunction) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 获取方法返回类型</span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 1、获取CallAdapter对象</span><br><span class="line">    // 根据之前的分析，这里获得的是DefaultCallAdapterFactory</span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">    // 校验返回类型是否正确</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    // 返回类型不能为okhttp3.Response类型</span><br><span class="line">    if (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;&apos;&quot;</span><br><span class="line">          + getRawType(responseType).getName()</span><br><span class="line">          + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回类型不能是Response，必须要包含泛型才行,类似于Response&lt;String&gt;</span><br><span class="line">    if (responseType == Response.class) &#123;</span><br><span class="line">      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO support Unit for Kotlin?</span><br><span class="line">    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">      throw methodError(method, &quot;HEAD method must use Void as response type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2、获得Converter对象</span><br><span class="line">    // 由于我们设置了GsonConverterFactory，所以这里获得的是GsonConverterFactory对象</span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        </span><br><span class="line">    // 获取一个okhttp3.Call.Factory对象，其实就是一个OkHttpClient对象</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    if (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; else if (continuationWantsResponse) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(</span><br><span class="line">      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 4、从retrofit中根据returnType和annotations获取CallAdapter</span><br><span class="line">      return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw methodError(method, e, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(</span><br><span class="line">      Retrofit retrofit, Method method, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    try &#123;</span><br><span class="line">      // 5、从retrofit中根据responseType和annotations获取Converter</span><br><span class="line">      return retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw methodError(method, e, &quot;Unable to create converter for %s&quot;, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final class Retrofit &#123;</span><br><span class="line">...</span><br><span class="line">  // 创建CallAdapter对象</span><br><span class="line">  public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    // 调用nextCallAdapter传入skipPast、returnType、annotations</span><br><span class="line">    // 注意：这里传入的skipPast为null</span><br><span class="line">    return nextCallAdapter(null, returnType, annotations);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    // 检查一下returnType和annotations是否为null</span><br><span class="line">    checkNotNull(returnType, &quot;returnType == null&quot;);</span><br><span class="line">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class="line">    </span><br><span class="line">    // 这里找到callAdapterFactories集合的起始位置</span><br><span class="line">    // 由于skipPast为null所以获得的index为-1，然后加上1，起始位置还是0</span><br><span class="line">    // 开始遍历集合</span><br><span class="line">    int start = callAdapterFactories.indexOf(skipPast) + 1;</span><br><span class="line">    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      // 我们在分析CallAdapter.Factory时知道，调用get方法表示了，</span><br><span class="line">      // 判断returnType是否是该CallAdapter.Factory支持的类型</span><br><span class="line">      // 如果不支持将会返回null</span><br><span class="line">      // 反之会返回对应的CallAdapter.Factory</span><br><span class="line">      // 由于没有额外设置，所以这里返回的是DefaultCallAdapterFactory</span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);</span><br><span class="line">      // 如果有直接返回</span><br><span class="line">      if (adapter != null) &#123;</span><br><span class="line">        return adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 到这里说明没有对应的CallAdapter.Factory</span><br><span class="line">    // 拼接错误信息</span><br><span class="line">    StringBuilder builder = new StringBuilder(&quot;Could not locate call adapter for &quot;)</span><br><span class="line">        .append(returnType)</span><br><span class="line">        .append(&quot;.\n&quot;);</span><br><span class="line">    if (skipPast != null) &#123;</span><br><span class="line">      builder.append(&quot;  Skipped:&quot;);</span><br><span class="line">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class="line">        builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(&apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(&quot;  Tried:&quot;);</span><br><span class="line">    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      builder.append(&quot;\n   * &quot;).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    throw new IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // 创建Converter对象</span><br><span class="line">  public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    // 调用nextResponseBodyConverter传入skipPast、returnType、annotations</span><br><span class="line">    // 注意：这里传入的skipPast为null</span><br><span class="line">    return nextResponseBodyConverter(null, type, annotations);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class="line">      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</span><br><span class="line">    // 检查一下returnType和annotations是否为null</span><br><span class="line">    checkNotNull(type, &quot;type == null&quot;);</span><br><span class="line">    checkNotNull(annotations, &quot;annotations == null&quot;);</span><br><span class="line">    // 这里找到converterFactories集合的起始位置</span><br><span class="line">    // 由于skipPast为null所以获得的index为-1，然后加上1，起始位置还是0</span><br><span class="line">    // 开始遍历集合</span><br><span class="line">    int start = converterFactories.indexOf(skipPast) + 1;</span><br><span class="line">    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      // 我们在分析Converter.Factory时知道，调用responseBodyConverter方法表示了，</span><br><span class="line">      // 判断能否将API方法的返回类型从ResponseBody 转换为type</span><br><span class="line">      // 如果不能直接返回null，</span><br><span class="line">      // 返回对应的Converter.Factory对象,我们之前设置的是GsonConverterFactory，所以这里返回的是GsonConverterFactory</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, this);</span><br><span class="line">      if (converter != null) &#123;</span><br><span class="line">        // 如果有直接返回</span><br><span class="line">        return (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 到这里说明没有对应的Converter.Factory</span><br><span class="line">    // 拼接错误信息</span><br><span class="line">    StringBuilder builder = new StringBuilder(&quot;Could not locate ResponseBody converter for &quot;)</span><br><span class="line">        .append(type)</span><br><span class="line">        .append(&quot;.\n&quot;);</span><br><span class="line">    if (skipPast != null) &#123;</span><br><span class="line">      builder.append(&quot;  Skipped:&quot;);</span><br><span class="line">      for (int i = 0; i &lt; start; i++) &#123;</span><br><span class="line">        builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(&apos;\n&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(&quot;  Tried:&quot;);</span><br><span class="line">    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      builder.append(&quot;\n   * &quot;).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    throw new IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里由于代码过长，所以我们分步分析，在上面代码中有<code>5处</code>比较重要的注释，首先看一下<code>注释1</code>和<code>注释2</code>，它们分别是用来获取<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>,分别对应了<code>注释4</code>和<code>注释5</code>处。<code>注释4</code>和<code>注释5</code>都是从<code>retrofit</code>对象中获取，具体的操作需要看上段代码的下半部分，最终获取的是<code>DefaultCallAdapterFactory</code>和<code>GsonConverterFactory</code>，具体流程已经在注释中给出。<br> 我们来看一下<code>注释3</code>处的操作,下面是<code>注释3</code>处的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;</span><br><span class="line">  static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(</span><br><span class="line">      Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;</span><br><span class="line">    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    ...</span><br><span class="line">    // 获取一个okhttp3.Call.Factory对象，其实就是一个OkHttpClient对象</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    if (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      // 新建一个CallAdapted对象，传入requestFactory、callFactory、responseConverter、callAdapter</span><br><span class="line">      // 最后返回出去</span><br><span class="line">      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; else if (continuationWantsResponse) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter) &#123;</span><br><span class="line">    this.requestFactory = requestFactory;</span><br><span class="line">    this.callFactory = callFactory;</span><br><span class="line">    this.responseConverter = responseConverter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override final @Nullable ReturnT invoke(Object[] args) &#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    // 这里首先找的是子类的adapt方法</span><br><span class="line">    // 因为创建的是CallAdapted，所以会调用CallAdapted的adapt放方法</span><br><span class="line">    return adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args);</span><br><span class="line">  </span><br><span class="line">  // CallAdapted继承自HttpServiceMethod</span><br><span class="line">  static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123;</span><br><span class="line">    private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line">    </span><br><span class="line">    // CallAdapted构造方法</span><br><span class="line">    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">      // 调用父类的构造方法，也就是HttpServiceMethod的构造方法</span><br><span class="line">      super(requestFactory, callFactory, responseConverter);</span><br><span class="line">      this.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;</span><br><span class="line">      // 返回callAdapter.adapt的结果</span><br><span class="line">      return callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里我们需要把<code>注释3</code>处的过程捋一捋，由于这个过程跟之前的分析联系比较紧密，所以会有点绕：</p>
<blockquote>
<p>1、新建一个<code>CallAdapted</code>对象，传入<code>requestFactory</code>、<code>callFactory</code>、<code>responseConverter</code>、<code>callAdapter</code>。<br> 2、创建<code>CallAdapted</code>对象时调用其构造方法，由于它继承自<code>HttpServiceMethod</code>，又调用了<code>HttpServiceMethod</code>的构造方法，将参数传入。<br> 3、我们在之前的动态代理最后一步会调用<code>return loadServiceMethod(method).invoke(...)</code>方法之后，又回调用<code>HttpServiceMethod.adapt</code>方法。这个方法在<code>HttpServiceMethod</code>中属于抽象方法，所以最终会调用其子类<code>CallAdapted.adapt</code>方法。<br> 4、在<code>CallAdapted.adapt</code>的方法中会调用<code>callAdapter.adapt</code>方法，在分析<code>CallAdapte.Factory</code>时，我们知道这个方法是将<code>Call</code>对象转成代理类<code>T</code>。我们没有设置<code>CallAdapte.Factory</code>，所以使用的是<code>DefaultCallAdapterFactory</code>，所以又调用了<code>DefaultCallAdapterFactory</code>中的<code>adapt</code>方法,并将<code>OkHttpCall</code>传入了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  private final @Nullable Executor callbackExecutor;</span><br><span class="line">  // 这个构造方法在Platform的Android子类中的defaultCallAdapterFactories方法中已经被调用。</span><br><span class="line">  DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123;</span><br><span class="line">    //callbackExecutor为MainThreadExecutor，也就是说会将响应回调到Android主线程去</span><br><span class="line">    this.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line">  // </span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    // 如果不是Call类型不予处理</span><br><span class="line">    if (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(returnType instanceof ParameterizedType)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">          &quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);</span><br><span class="line">    // 查看注解是否包含SkipCallbackExecutor类型，我们在使用时并没有使用SkipCallbackExecutor的注解</span><br><span class="line">    // 所以这里的executor不为null</span><br><span class="line">    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">        ? null</span><br><span class="line">        : callbackExecutor;</span><br><span class="line">    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override public Type responseType() &#123;</span><br><span class="line">        return responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">        // 判断executor是否为空，如果为空返回Call,这个call属于OkHttpCall</span><br><span class="line">        // 如果不为空返回ExecutorCallbackCall</span><br><span class="line">        return executor == null</span><br><span class="line">            ? call</span><br><span class="line">            : new ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>由于这里与之前的分析联系比较紧密，有些绕，一不小心就会被绕进去，所以还是分步分析。</p>
<blockquote>
<p>1、在<code>Platform</code>的子类<code>Android</code>中，已经创建了<code>DefaultCallAdapterFactory</code>对象，并且传入了<code>MainThreadExecutor</code>，这保证了响应会被回调到<code>Android</code>主线程。<br> 2、之前在获取<code>CallAdapter</code>类型的时候，已经调用了<code>DefaultCallAdapterFactory.get</code>方法，所以<code>executor</code>对象不为空，并且返回了一个匿名的<code>CallAdapter</code>对象。<br> 3、在上面我们调用<code>DefaultCallAdapterFactory.adapt</code>方法时，就是调用了这个匿名对象的<code>adapt</code>方法，这里返回的是<code>ExecutorCallbackCall</code>对象。也就是说我们在做网络请求时就是使用这个<code>ExecutorCallbackCall</code>对象。</p>
</blockquote>
<h2 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h2><p>我们在上面的分析中知道，其实是<code>ExecutorCallbackCall</code>对象进行网络请求，所以看一下它的源码。</p>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><p>同步请求的方法我们也在之前的举例给出，我们看一下源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    // 构造方法传入callbackExecutor、Call</span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      // callbackExecutor属于MainThreadExecutor</span><br><span class="line">      this.callbackExecutor = callbackExecutor;</span><br><span class="line">      // delegate为OkHttpCall对象</span><br><span class="line">      this.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">      // delegate其实就是OkHttpCall对象</span><br><span class="line">      return delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    </span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line">      call = rawCall;</span><br><span class="line">      if (call == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // requestFactory根据args创建request对象</span><br><span class="line">          // 然后创建okhttp3.Call对象</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.</span><br><span class="line">          creationFailure = e;</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用okhttp3.Call对象进行请求，并将响应结果进行解析</span><br><span class="line">    return parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    // requestFactory根据args创建request对象</span><br><span class="line">    // 然后根据request对象创建一个okhttp3.Call对象</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回okhttp3.Call对象</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 对响应进行解析</span><br><span class="line">  Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</span><br><span class="line">    // 响应体</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line">        </span><br><span class="line">    // 获得响应码</span><br><span class="line">    int code = rawResponse.code();</span><br><span class="line">    // 根据响应码进行判断</span><br><span class="line">    if (code &lt; 200 || code &gt;= 300) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        // Buffer the entire body to avoid future I/O.</span><br><span class="line">        ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">        return Response.error(bufferedBody, rawResponse);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (code == 204 || code == 205) &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">      return Response.success(null, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    try &#123;</span><br><span class="line">      // 将响应体传入responseConverter对象也就是我们之前设置的GsonConverterFactory中去</span><br><span class="line">      // 将响应体转成对应的Java对象</span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      return Response.success(body, rawResponse);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      // If the underlying source threw an exception, propagate that rather than indicating it was</span><br><span class="line">      // a runtime exception.</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>同步请求的过程：</p>
<blockquote>
<p>1、<code>ExecutorCallbackCall</code>通过调用<code>excute</code>方法，调用了传入的<code>OkhttpCall</code>对象的<code>excute</code>方法。<br> 2、<code>OkhttpCall</code>的<code>excute</code>方法中，首先通过<code>requestFactory</code>根据<code>args</code>创建<code>request</code>对象，然后创建<code>okhttp3.Call</code>对象。<br> 3、调用<code>okhttp3.Call</code>的<code>excute</code>方法，获取响应。<br> 4、拿到响应后会根据响应码进行判断，通过判断后通过<code>responseConverter</code>对象将响应体转成对应的<code>Java</code>对象，并返回。</p>
</blockquote>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>关于异步请求的使用，在我们之前的举例中已经给出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    // callbackExecutor属于MainThreadExecutor</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line">    </span><br><span class="line">    // 异步请求</span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line">      // 根据同步请求我们知道delegate就是一个OkhttpCall对象</span><br><span class="line">      // 调用OkhttpCall.exqueue方法执行异步请求</span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        // 获取响应的回调</span><br><span class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">          // 进行线程切换</span><br><span class="line">          // callbackExecutor就是MainThreadExecutor，其内部是通过主线程的Handler将Runnable发送到主线程去</span><br><span class="line">          // 从而达到切换线程的效果</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              if (delegate.isCanceled()) &#123;</span><br><span class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 请求失败的回调</span><br><span class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          // 线程切换，原理同上</span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  // 异步请求方法</span><br><span class="line">  @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">    checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      if (call == null &amp;&amp; failure == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 创建Call对象</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          failure = creationFailure = t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (failure != null) &#123;</span><br><span class="line">      callback.onFailure(this, failure);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    // 执行异步请求</span><br><span class="line">    call.enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 解析网络请求，过程和同步请求中一样</span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">          throwIfFatal(e);</span><br><span class="line">          callFailure(e);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          // 请求成功的回调</span><br><span class="line">          callback.onResponse(OkHttpCall.this, response);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          t.printStackTrace(); // TODO this is not great</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">        // 请求失败</span><br><span class="line">        callFailure(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      private void callFailure(Throwable e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 请求失败回调</span><br><span class="line">          callback.onFailure(OkHttpCall.this, e);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          t.printStackTrace(); // TODO this is not great</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    // requestFactory根据args创建一个request对象</span><br><span class="line">    // 将request对象分装成一个Call对象</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>异步请求中有一个重要的操作就是将请求结果通过主线程的<code>Handle</code>发送到主线程去，从而达到线程切换的效果。</p>
<h1 id="涉及的设计模式"><a href="#涉及的设计模式" class="headerlink" title="涉及的设计模式"></a>涉及的设计模式</h1><p>在源码分析的过程中，我们能发现<code>Retrofit</code>中运用了大量的设置模式，这样做的好处就是将代码进行封装，方便我们调用。这里面用到的设计模式包括：<code>构建者模式</code>、<code>单例模式</code>、<code>工厂模式</code>、<code>代理模式</code>、<code>外观模式</code>、<code>装饰模式</code>、<code>策略模式</code>、<code>适配器模式</code>。<br> 由于在之前的文章中已经提到了<code>构建者模式</code>、<code>单例模式</code>、<code>工厂模式</code>，所以这里不再多做陈述，但是我会给出它们在<code>Retrofit</code>中具体的出处。</p>
<blockquote>
<p>1、构建者模式：最明显的就是在最初创建<code>Retrofit</code>对象时调用的<code>new Retrofit.Builder().build()</code>。<br> 2、单例模式：在<code>Platform</code>类中获取<code>Plathform</code>对象时使用的就是单例模式，有关单例的几种写法和它们之间的区别还希望大家能够有所了解。<br> 3、工厂模式：最明显的是<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>，但是工厂模式中又有：<code>简单工厂</code>、<code>抽象工厂</code>和<code>工厂方法</code>，需要区分开来。</p>
</blockquote>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>说到代理模式，有静态代理和动态代理之分。在<code>Retrofit</code>中我们最初接触的是动态代理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  ...</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    ...</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          ...</span><br><span class="line">          @Override public @Nullable Object invoke(Object proxy, Method method,</span><br><span class="line">              @Nullable Object[] args) throws Throwable &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里只有动态代理，那<code>Retrofit</code>中的静态代理在哪？在说静态代理之前要明白什么是静态代理：静态代理是指代理类在程序运行前已经存在的代理方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 这个delegate属于静态代理</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line">    </span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line">      </span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">          </span><br><span class="line">          callbackExecutor.execute(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              // 额外操作</span><br><span class="line">              if (delegate.isCanceled()) &#123;</span><br><span class="line">                ...</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>有关代理模式，在基础知识准备的时候已经给大家准备了几篇文章，这里就不再一一列出了。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServiceApi &#123;</span><br><span class="line">    @GET(&quot;wxarticle/chapters/json&quot;)</span><br><span class="line">    Call&lt;Bean&gt; getWxArtical();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceApi serviceApi = retrofit.create(ServiceApi.class);</span><br><span class="line">final Call&lt;Bean&gt; officialAccounts = serviceApi.getOfficialAccounts();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我们在<code>HTTP API</code>接口中定义了很多方法，参数都在方法上进行定义，只会告诉调用者需要传入哪些参数，具体的操作并不向外暴露，这个就是外观设计模式。这里为到家准备了一篇<a href="https://juejin.im/post/5a37d48e518825256362c6e2">设计模式之外观模式</a>。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      checkNotNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我们可以将<code>ExecutorCallbackCall</code>看作是装饰类，但真正去执行请求的是OkHttpCall。之所以要有个装饰类，是希望做一些额外操作。这里的操作就是线程转换，将子线程切换到主线程上去。有关装饰设计模式，为大家准备了两篇文章： <a href="https://www.jianshu.com/p/427342d3b5c0">设计模式之死磕装饰器模式（原创）</a>、 <a href="https://www.jianshu.com/p/4a530a3c70af">装饰者模式</a>。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>简单的来说，策略模式就是做某些事情可能同时有多个方案，不同的时期使用不同的方案，怎样在调用的过程中尽可能的减少代码的修改，主要还是使用了<code>Java</code>中的多态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RxJava2CallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line"></span><br><span class="line">    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);</span><br><span class="line">    Class&lt;?&gt; rawObservableType = getRawType(observableType);</span><br><span class="line">    if (rawObservableType == Response.class) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else if (rawObservableType == Result.class) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在<code>RxJava2CallAdapterFactory</code>的<code>get</code>方法中使用了策略模式，这里会根据<code>rawObservableType</code>的类型，作出对应的操作，如果感兴趣的小伙伴可以到源码里面看一下。<br> 有关策略模式这里为大家准备了一篇文章：<a href="https://juejin.im/post/57d65eac7db2a200684109dc">LOL设计模式之「策略模式」</a>。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>我们在看<code>Retrofit</code>源码时，有可能在分析<code>CallAdapter</code>时被搞的晕头转向。如果从适配器的概念上来讲，就是将一个已经存在的东西，转成适合使用的东西。最常见的场景就是出国游玩的时候由于电源接口标准的不同，我们需要带一个转换头。<br> 回头看<code>Retrofit</code>，如果我们一直时在<code>Android</code>上使用，那就需要通过静态代理<code>ExecutorCallbackCall</code>来切换线程，但是后来出现了新的技术<code>Rxjava</code>，感觉还挺好用的，不需要通过<code>Handler</code>进行线程切换了。这时就需要转换一下，将将<code>OkHttpCall</code>转换成<code>rxjava(Scheduler)</code>的写法，大概就是这么一个套路。<br> 关于适配器模式，也给大家准备了一篇文章：<a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们已经把<code>Retrofit</code>的源码分析了一遍， 这里还是建议大家自己跟着源码走一遍，毕竟纸上得来终觉浅。最后还是那句话，本人是一名<code>Android</code>小学生，文中如有不妥之处还望各位不吝赐教，本人将不胜感激。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant Retrofit
participant Builder
participant Platform
participant GsonConverterFactory

Builder -> Platform: Builder(Platform platform)
Platform -> Platform: get()
Builder -> Builder: baseUrl(String url)
Builder -> GsonConverterFactory: addConverterFactory()
GsonConverterFactory -> GsonConverterFactory: create()
Builder -> Retrofit: build()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/19/Markdown高级用法/" class="prev">上一篇</a><a href="/2017/02/21/从Laucher启动Activity过程分析/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>