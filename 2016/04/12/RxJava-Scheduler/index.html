<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RxJava线程调度 · J!nl!n's Blog</title><meta name="description" content="RxJava线程调度 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RxJava线程调度</h1><div class="post-info">Apr 12, 2016</div><div class="post-content"><p>　　<strong> 概述：</strong>RxJava 在切换线程时用到了两个方法 <code>subscribeOn()</code> 和 <code>observeOn()</code> ，那么它纠结做了什么呢？<br><a id="more"></a></p>
<blockquote>
<p>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.</p>
<p>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</p>
<p>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its <code>Subscribe</code> method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</p>
<p>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use <em>below</em> where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</p>
</blockquote>
<p><img src="http://reactivex.io/documentation/operators/images/schedulers.png" alt></p>
<ul>
<li><code>subscribeOn()</code>：影响的是最开始的被观察者所在的线程。当使用多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用；</li>
<li><code>observeOn()</code>：影响的是跟在后面的操作（指定观察者运行的线程）。所以如果想要多次改变线程，可以多次使用 observeOn；</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"create: "</span> + Thread.currentThread().getName());</span><br><span class="line">      emitter.onNext(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"String -&gt; Integer: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .flatMap(<span class="keyword">new</span> Function&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"Integer-&gt;Observable: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Log.e(TAG, <span class="string">"Observable&lt;String&gt; call: "</span> + Thread.currentThread().getName());</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer; i++) &#123;</span><br><span class="line">            emitter.onNext(i + <span class="string">""</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="keyword">new</span> Function&lt;String, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"String-&gt;Long: "</span> + Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> Long.parseLong(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"onNext: "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="observeOn-的线程切换原理"><a href="#observeOn-的线程切换原理" class="headerlink" title="observeOn() 的线程切换原理"></a>observeOn() 的线程切换原理</h4><p>从<code>observeOn</code>切入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> observeOn(scheduler, delayError, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observeOn()</code> 执行后是得到 <code>ObservableObserveOn</code> 对象，那么当 <code>ObservableObserveOn</code> 绑定监听者的时候要运行 <code>subscribe()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略代码专用...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">            ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line">						<span class="comment">// 这里调用了抽象方法`subscribeActual`</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">            <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">            RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">            NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">            npe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObservableObserveOn</code>实现了<code>subscribeActual</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    </span><br><span class="line">    ...省略代码专用...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 在当前线程调度，但不是立即执行，放入到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">						<span class="comment">// 为上游Observable</span></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以知道<code>ObservableObserveOn</code> 是被 <code>ObserveOnObserver</code> 监听的，所以收到通知也是由 <code>ObserveOnObserver</code> 作出响应，接下来我们假设当 <code>Rxjava</code> 发送 <code>onNext</code> 通知时会调用 <code>ObserveOnObserver</code> 的 <code>onNext()</code> 方法 ( PS:当然如果是 onComplete()、onError() 等也是一样的逻辑 )，然后来看一看 <code>ObserveOnObserver</code> 的 <code>onNext()</code> 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6576896619930983584L</span>;</span><br><span class="line">  	<span class="comment">// 下游的Observer</span></span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line">  	<span class="comment">// 调度工作者</span></span><br><span class="line">    <span class="keyword">final</span> Scheduler.Worker worker;</span><br><span class="line">  	<span class="comment">// 是否延迟错误，默认false</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">  	<span class="comment">// 队列大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">		<span class="comment">// 存储上游Observable下发的数据队列</span></span><br><span class="line">    SimpleQueue&lt;T&gt; queue;</span><br><span class="line">		<span class="comment">// 存储下游的Observer的Disposable</span></span><br><span class="line">    Disposable s;</span><br><span class="line">		<span class="comment">// 错误信息</span></span><br><span class="line">    Throwable error;</span><br><span class="line">  	<span class="comment">// 校验是否完毕</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> done;</span><br><span class="line">		<span class="comment">// 是否被取消</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">		<span class="comment">// 执行模式，同步或者异步</span></span><br><span class="line">    <span class="keyword">int</span> sourceMode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> outputFused;</span><br><span class="line">  </span><br><span class="line">  	...省略代码专用...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">          QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class="line">					<span class="comment">// 判断执行模式并调用onSubscribe传递给下游Observer</span></span><br><span class="line">          <span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">            sourceMode = m;</span><br><span class="line">            queue = qd;</span><br><span class="line">            <span class="comment">// 后面的onXX方法都不会被调用</span></span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 同步模式下，直接调用schedule</span></span><br><span class="line">            schedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">            sourceMode = m;</span><br><span class="line">            queue = qd;</span><br><span class="line">            actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 异步模式下，等待schedule</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">				<span class="comment">// 判断执行模式并调用onSubscribe传递给下游Observer</span></span><br><span class="line">        actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 数据源是同步模式或者执行过 error / complete 会是true</span></span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 如果数据源不是异步类型</span></span><br><span class="line">      <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 上游Observable下发的数据压入queue</span></span><br><span class="line">        queue.offer(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开始调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// 已经完成再执行会抛异常</span></span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录错误信息</span></span><br><span class="line">      error = t;</span><br><span class="line">      <span class="comment">// 标记已完成</span></span><br><span class="line">      done = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 开始调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      done = <span class="keyword">true</span>;</span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...省略代码专用...</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>眼光转向<code>schedule()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 原子性</span></span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>worker</code>的<code>schedule()</code>方法，将自己传递进去。来看声明，<code>schedule</code>方法接收<code>Runnable</code>对象为参数，而<code>ObserveOnObserver</code>实现了<code>Runnable</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	  * Schedules a Runnable for execution without any time delay.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation delegates to &#123;<span class="doctag">@link</span> #schedule(Runnable, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> run</span></span><br><span class="line"><span class="comment">    *            Runnable to schedule</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Disposable to be able to unsubscribe the action (cancel it if not executed)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> schedule(run, <span class="number">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules an Runnable for execution at some point in the future specified by a time delay</span></span><br><span class="line"><span class="comment">     * relative to the current time.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note to implementors: non-positive &#123;<span class="doctag">@code</span> delayTime&#125; should be regarded as non-delayed schedule, i.e.,</span></span><br><span class="line"><span class="comment">     * as if the &#123;<span class="doctag">@link</span> #schedule(Runnable)&#125; was called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> run</span></span><br><span class="line"><span class="comment">     *            the Runnable to schedule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay</span></span><br><span class="line"><span class="comment">     *            time to "wait" before executing the action; non-positive values indicate an non-delayed</span></span><br><span class="line"><span class="comment">     *            schedule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     *            the time unit of &#123;<span class="doctag">@code</span> delayTime&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Disposable to be able to unsubscribe the action (cancel it if not executed)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span></span>;</span><br><span class="line">  </span><br><span class="line">  	...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了重载方法，是个抽象方法。示例使用的是<code>Schedulers.io()</code>，追根溯源最终到了<code>IoScheduler</code>，直接找到<code>schedule</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pool = pool;</span><br><span class="line">      <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line">      <span class="keyword">this</span>.threadWorker = pool.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (once.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        tasks.dispose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// releasing the pool should be the last action</span></span><br><span class="line">        pool.release(threadWorker);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> once.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tasks.isDisposed()) &#123;</span><br><span class="line">        <span class="comment">// don't schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>scheduleActual</code>，在看下实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	...省略代码专用...</span><br><span class="line">      </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wraps the given runnable into a ScheduledRunnable and schedules it</span></span><br><span class="line"><span class="comment">     * on the underlying ScheduledExecutorService.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the schedule has been rejected, the ScheduledRunnable.wasScheduled will return</span></span><br><span class="line"><span class="comment">     * false.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> run the runnable instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime the time to delay the execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the optional tracker parent to add the created ScheduledRunnable instance to before it gets scheduled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the ScheduledRunnable instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!parent.add(sr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 判断延迟时间，然后使用线程池运行 Runnable</span></span><br><span class="line">            <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            sr.setFuture(f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.remove(sr);</span><br><span class="line">            &#125;</span><br><span class="line">            RxJavaPlugins.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兜圈回到<code>ObservableObserveOn</code>的<code>run</code>方法，然后调用<code>onNext</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">      drainFused();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看下<code>checkTerminated</code>方法，做了什么操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkTerminated</span><span class="params">(<span class="keyword">boolean</span> d, <span class="keyword">boolean</span> empty, Observer&lt;? <span class="keyword">super</span> T&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">      <span class="comment">// 订阅已经取消，则取消队列</span></span><br><span class="line">      queue.clear();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个d就是传进来的done</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">      <span class="comment">// done == true可能的情况onNext刚被调度完，onError或者onComplete被调用</span></span><br><span class="line">      Throwable e = error;</span><br><span class="line">      <span class="keyword">if</span> (delayError) &#123;</span><br><span class="line">        <span class="comment">// delayError == true时等到队列为空才调用</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            a.onError(e);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a.onComplete();</span><br><span class="line">          &#125;</span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          queue.clear();</span><br><span class="line">          a.onError(e);</span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            a.onComplete();</span><br><span class="line">            worker.dispose();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不终结</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看下<code>drainNormal</code>做了哪些事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line">    <span class="comment">// 死循环，注意出口操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 上面方法被终止，不进行下面操作</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 再次死循环</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> d = done;</span><br><span class="line">        T v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 分发数据出队列</span></span><br><span class="line">          v = q.poll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="comment">// 有异常时终止退出</span></span><br><span class="line">          Exceptions.throwIfFatal(ex);</span><br><span class="line">          s.dispose();</span><br><span class="line">          q.clear();</span><br><span class="line">          a.onError(ex);</span><br><span class="line">          <span class="comment">// 停止woker（线程）</span></span><br><span class="line">          worker.dispose();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没数据跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据下发给下游Observer，onNext, onComplete和onError主要放在了checkTerminated里面回调</span></span><br><span class="line">        a.onNext(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保证此时有一个worker.schedule(this);正在执行</span></span><br><span class="line">      missed = addAndGet(-missed);</span><br><span class="line">      <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="subscribeOn-的线程切换原理"><a href="#subscribeOn-的线程切换原理" class="headerlink" title="subscribeOn() 的线程切换原理"></a>subscribeOn() 的线程切换原理</h4><p>同样，这里从<code>subscribeOn</code>作为切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>subscribeOn</code>得到装饰者模式对象<code>ObservableSubscribeOn</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line"></span><br><span class="line">        s.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...省略代码专用...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说一说RxAndroid"><a href="#说一说RxAndroid" class="headerlink" title="说一说RxAndroid"></a>说一说RxAndroid</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Android-specific Schedulers. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> MainHolder.DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A &#123;<span class="doctag">@link</span> Scheduler&#125; which executes actions on the Android main thread. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A &#123;<span class="doctag">@link</span> Scheduler&#125; which executes actions on &#123;<span class="doctag">@code</span> looper&#125;. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">from</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"looper == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(looper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AndroidSchedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"No instances."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AndroidSchedulers.mainThread()</code>返回的是<code>HandlerScheduler</code>，传递了一个<code>Handler</code>拿到主线程的<code>Looper</code>的对象</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/13/python-tools/" class="prev">PREV</a><a href="/2016/04/11/RxJava操作符/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>