<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android热修复探究—QQ空间方案 · J!nl!n's Blog</title><meta name="description" content="Android热修复探究—QQ空间方案 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android热修复探究—QQ空间方案</h1><div class="post-info">Apr 2, 2016</div><div class="post-content"><p>　　<strong> 概述：</strong>传统的app开发模式下，线上出现bug，必须通过发布新版本，用户手动更新后才能修复线上bug。那么是否存在一种方案可以在不发版的前提下修复线上bug？有！而且不只一种。今天首先来看下腾讯的QQ空间补丁方案<br><a id="more"></a><br>传统的app开发模式下，线上出现bug，必须通过发布新版本，用户手动更新后才能修复线上bug。随着app的业务越来越复杂，代码量爆发式增长，出现bug的机率也随之上升。如果单纯靠发版修复线上bug，其较长的新版覆盖期无疑会对业务造成巨大的伤害，更不要说大型app开发通常涉及多个团队协作，发版排期必须多方协调。<br>那么是否存在一种方案可以在不发版的前提下修复线上bug？有！而且不只一种，业界各家大厂都针对这一问题拿出了自家的解决方案，较为著名的有腾讯的Tinker和阿里的Andfix以及QQ空间补丁。网上对上述方案有很多介绍性文章，不过大多不全面，中间略过很多细节。笔者在学习的过程中也遇到很多麻烦。所以笔者将通过接下来几篇博客对上述两种方案进行介绍，力求不放过每一个细节。首先来看下QQ空间补丁方案。</p>
<h1 id="Dex分包机制"><a href="#Dex分包机制" class="headerlink" title="Dex分包机制"></a>Dex分包机制</h1><p>大家都知道，我们开发的代码在被编译成class文件后会被打包成一个dex文件。但是dex文件有一个限制，由于方法id是一个short类型，所以导致了一个dex文件最多只能存放65536个方法。随着现今App的开发日益复杂，导致方法数早已超过了这个上限。为了解决这个问题，Google提出了multidex方案，即一个apk文件可以包含多个dex文件。<br>不过值得注意的是，除了第一个dex文件以外，其他的dex文件都是以资源的形式被加载的，换句话说就是在Application.onCreate()方法中被注入到系统的ClassLoader中的。这也就为热修复提供了一种可能：将修复后的代码达成补丁包，然后发送到客户端，客户端在启动的时候到指定路径下加载对应dex文件即可。<br>根据Android虚拟机的类加载机制，同一个类只会被加载一次，所以要让修复后的类替换原有的类就必须让补丁包的类被优先加载。接下来看下Android虚拟机的类加载机制。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>Android的类加载机制和jvm加载机制类似，都是通过ClassLoader来完成，只是具体的类不同而已。<br>Android系统通过PathClassLoader来加载系统类和主dex中的类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Provides a simple &#123;@link ClassLoader&#125; implementation that operates on a list</span><br><span class="line"> * of files and directories in the local file system, but does not attempt to</span><br><span class="line"> * load classes from the network. Android uses this class for its system class</span><br><span class="line"> * loader and for its application class loader(s).</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<p>而DexClassLoader则用于加载其他dex文件中的类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A class loader that loads classes from &#123;@code .jar&#125; and &#123;@code .apk&#125; files</span><br><span class="line"> * containing a &#123;@code classes.dex&#125; entry. This can be used to execute code not</span><br><span class="line"> * installed as part of an application.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span><br><span class="line"> * cache optimized classes. Use &#123;@code Context.getDir(String, int)&#125; to create</span><br><span class="line"> * such a directory: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   File dexOutputDir = context.getDir(&quot;dex&quot;, 0);</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span><br><span class="line"> * External storage does not provide access controls necessary to protect your</span><br><span class="line"> * application from code injection attacks.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<p>上述两个类都是继承自BaseDexClassLoader，查看源码得知具体的加载方法是findClass:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for common functionality between various dex-based</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ClassLoader&#125; implementations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory directory where optimized dex files</span></span><br><span class="line"><span class="comment">     * should be written; may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> libraryPath the list of directories containing native</span></span><br><span class="line"><span class="comment">     * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到加载类的工作转移到了pathList中，pathList是一个DexPathList类型，从变量名和类型名就可以看出这是一个维护Dex的容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAR_SUFFIX = <span class="string">".jar"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_SUFFIX = <span class="string">".zip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** class definition context */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of dex/resource (class path) elements.</span></span><br><span class="line"><span class="comment">     * Should be called pathElements, but the Facebook app uses reflection</span></span><br><span class="line"><span class="comment">     * to modify 'dexElements' (http://b/7726934).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the named class in one of the dex files pointed at by</span></span><br><span class="line"><span class="comment">     * this instance. This will find the one in the earliest listed</span></span><br><span class="line"><span class="comment">     * path element. If the class is found but has not yet been</span></span><br><span class="line"><span class="comment">     * defined, then this method will define it in the defining</span></span><br><span class="line"><span class="comment">     * context that this instance was constructed with.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name of class to find</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suppressed exceptions encountered whilst finding the class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the named class or &#123;<span class="doctag">@code</span> null&#125; if the class is not</span></span><br><span class="line"><span class="comment">     * found in any of the dex files</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexPathList的findClass也很简单，dexElements是维护dex文件的数组，每一个item对应一个dex文件。DexPathList遍历dexElements，从每一个dex文件中查找目标类，在找到后即返回并停止遍历。所以要想达到热修复的目的就必须让补丁dex在dexElements中的位置先于原有dex：</p>
<p><img src="/res/hotfix/c3d8d50bdf89d50bf5254387ae761ccc_b.jpg" alt="修复前"></p>
<p><img src="/res/hotfix/5af6c469a4866233d82ee7521c672ea6_b.jpg" alt="修复后"></p>
<p>基本上以上的部分就是QQ空间动态修复方案的基本思路。下面将以一个简单的例子讲述一下QQ空间补丁热修复的过程。</p>
<h4 id="创建补丁"><a href="#创建补丁" class="headerlink" title="创建补丁"></a>创建补丁</h4><p>1.创建简单类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Activity也很简单，实例化Hello并且调用方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(TAG, <span class="string">"getClassLoader():"</span> + getClassLoader());</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, String.valueOf(<span class="keyword">new</span> Hello().say()), Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.创建补丁包<br>首先修改要修复的类，我们在返回的字符串后加了三个感叹号。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.重新编译项目，在<code>app/build/intermediates/classes/debug/com/jinlin/base/hotfix/</code>目录下找到Hello.class文件,将其拷出来，准备打包。注意要放置在于Hello包名相同的路径下<code>com/jinlin/base/hotfix/</code>。然后使用命令将其打成jar包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar -cvf patch.jar com</span><br></pre></td></tr></table></figure>
<p>再将对应的jar包打成dex包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dx --dex --output=patch_dex.jar patch.jar</span><br></pre></td></tr></table></figure></p>
<p>dx是将jar包打成dex包的工具，安装在<code>$sdk_home$/build-tools/version(如23.0.1)/dx</code>。生成的patch_dex.jar就是补丁包。接下来将其放到SDCard中，之后应用从sdCard上加载该补丁包。注意：这里需要添加读取内存卡的权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push patch_dex.jar /mnt/sdcard/</span><br></pre></td></tr></table></figure></p>
<h4 id="加载补丁"><a href="#加载补丁" class="headerlink" title="加载补丁"></a>加载补丁</h4><p>加载补丁的思路如下：</p>
<p>在Application的onCreate()方法中获取应用本身的BaseDexClassLoader,然后通过反射得到对应的dexElements<br>创建一个新的DexClassLoader实例，然后加载SDCard上的补丁包，通过同样的反射方法得到对应的dexElements<br>将两个dexElements合并，再利用反射将合并后的dexElements赋值给应用本身的BaseDexClassLoader<br>接下来看下具体代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotFixApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = HotFixApplication<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取补丁，如果存在就执行注入操作</span></span><br><span class="line">        String dexPath = Environment.getExternalStorageDirectory().getAbsolutePath().concat(<span class="string">"/patch_dex.jar"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(dexPath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            inject(dexPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, dexPath + <span class="string">"不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要注入的dex的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取classes的dexElements</span></span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>);</span><br><span class="line">            Object pathList = getField(cl, <span class="string">"pathList"</span>, getClassLoader());</span><br><span class="line">            Object baseElements = getField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取patch_dex的dexElements（需要先加载dex）</span></span><br><span class="line">            String dexopt = getDir(<span class="string">"dexopt"</span>, <span class="number">0</span>).getAbsolutePath();</span><br><span class="line">            DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(path, dexopt, dexopt, getClassLoader());</span><br><span class="line">            Object obj = getField(cl, <span class="string">"pathList"</span>, dexClassLoader);</span><br><span class="line">            Object dexElements = getField(obj.getClass(), <span class="string">"dexElements"</span>, obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并两个Elements</span></span><br><span class="line">            Object combineElements = combineArray(dexElements, baseElements);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将合并后的Element数组重新赋值给app的classLoader</span></span><br><span class="line">            setField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList, combineElements);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//======== 以下是测试是否成功注入 =================</span></span><br><span class="line">            Object object = getField(pathList.getClass(), <span class="string">"dexElements"</span>, pathList);</span><br><span class="line">            <span class="keyword">int</span> length = Array.getLength(object);</span><br><span class="line">            Log.e(TAG, <span class="string">"length = "</span> + length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获取对象的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getField</span><span class="params">(Class&lt;?&gt; cl, String fieldName, Object object)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = cl.getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射设置对象的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Class&lt;?&gt; cl, String fieldName, Object object, Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = cl.getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射合并两个数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">combineArray</span><span class="params">(Object firstArr, Object secondArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstLength = Array.getLength(firstArr);</span><br><span class="line">        <span class="keyword">int</span> secondLength = Array.getLength(secondArr);</span><br><span class="line">        <span class="keyword">int</span> length = firstLength + secondLength;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; componentType = firstArr.getClass().getComponentType();</span><br><span class="line">        Object newArr = Array.newInstance(componentType, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; firstLength) &#123;</span><br><span class="line">                Array.set(newArr, i, Array.get(firstArr, i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Array.set(newArr, i, Array.get(secondArr, i - firstLength));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心代码就这么多，运行一下程序看看效果。程序依然Crash了。抛出的异常如下<br><img src="/res/hotfix/exception.png" alt="异常"></p>
<p>原因是类预校验问题引起的，具体请看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect">安卓App热补丁动态修复技术介绍</a>在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程。如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，并且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED。如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错<code>Class ref in pre-verified class resolved to unexpected implementation</code>所以MainActivity的onClick()方法中引用另一个dex的类就会出现上文中的问题。正常的分包方案会保证相关类被打入同一个dex文件，想要使得patch补丁包可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用。</p>
<h4 id="字节码注入"><a href="#字节码注入" class="headerlink" title="字节码注入"></a>字节码注入</h4><p>要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，ASM等。其实QQ空间补丁方案的关键就在于字节码的注入而不是dex的注入。相比之下ASM提供一系列字节码指令，效率更高但是要求使用者对字节码操作有一定了解。而javaassist虽然效率差一些但是使用门槛较低，我们选择使用javaassist。关于javaassist可以网上搜索一些资料了解一下,这里不做详细描述。 </p>
<h5 id="用-Javassist-进行类字节码插桩"><a href="#用-Javassist-进行类字节码插桩" class="headerlink" title="用 Javassist 进行类字节码插桩"></a>用 Javassist 进行类字节码插桩</h5><p>正常App开发过程中，编译，打包过程都是Android Studio自动完成。如无特殊需求无需人为干预，但是要实现插桩就必须在Android Studio的自动化打包流程中加入插桩的过程。</p>
<ol>
<li>Gradle,Task,Transform,Plugin<br>Android Studio采用Gradle作为构建工具，所有有必要了解一下Gradle构建的基本概念和流程。如果不熟悉可以参考一下下列文章：<br><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html?spm=5176.100239.blogcont70337.18.IgYelX">Gradle学习系列之一——Gradle快速入门</a><br><a href="http://blog.csdn.net/innost/article/details/48228651?spm=5176.100239.blogcont70337.19.IgYelX">深入理解Android之Gradle</a></li>
</ol>
<p>Gradle的构建工程实质上是通过一系列的Task完成的，所以在构建apk的过程中就存在一个打包dex的任务。Gradle 1.5以上版本提供了一个新的API：Transform，官方文档对于Transform的描述是：</p>
<blockquote>
<p>The goal of this API is to simplify injecting custom class manipulations without having to deal with tasks, and to offer more flexibility on what is manipulated. The internal code processing (jacoco, progard, multi-dex) have all moved to this new mechanism already in 1.5.0-beta1.</p>
<blockquote>
<ol>
<li>The Dex class is gone. You cannot access it anymore through the variant API (the getter is still there for now but will throw an exception)</li>
<li>Transform can only be registered globally which applies them to all the variants. We’ll improve this shortly.</li>
<li>There’s no way to control ordering of the transforms.</li>
</ol>
</blockquote>
</blockquote>
<p>Transform任务一经注册就会被插入到任务执行队列中，并且其恰好在dex打包task之前。所以要想实现插桩就必须创建一个Transform类的Task。</p>
<p>1.1 Task</p>
<p>Gradle的执行脚本就是由一系列的Task完成的。Task有一个重要的概念：input的output。每一个task需要有输入input，然后对input进行处理完成后在输出output。</p>
<p>1.2 Plugin</p>
<p>Gradle的另外一个重要概念就是Plugin。整个Gradle的构建体系都是有一个一个的plugin构成的，实际Gradle只是一个框架，提供了基本task和指定标准。而具体每一个task的执行逻辑都定义在一个个的plugin中。详细的概念可以参考：Writing Custom Plugins<br>在Android开发中我们经常使用到的plugin有：”com.android.application”，”com.android.library”,”java”等等。每一个Plugin包含了一系列的task，所以执行gradle脚本的过程也就是执行目标脚本所apply的plugin所包含的task。</p>
<p>1.3 创建一个包含Transform任务的Plugin</p>
<ol>
<li>新建一个module，选择library module，module名字必须叫BuildSrc</li>
<li>删除module下的所有文件，除了build.gradle，清空build.gradle中的内容</li>
<li>然后新建以下目录 src-main-groovy</li>
<li>修改build.gradle如下，同步</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile 'com.android.tools.build:gradle:1.5.0'</span></span><br><span class="line"><span class="function">    compile 'org.javassist:javassist:3.20.0-GA'<span class="comment">//javaassist依赖</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>像普通module一样新建package和类，不过这里的类是以groovy结尾，新建类的时候选择file，并且以.groovy作为后缀</li>
<li>自定义Plugin：<br>PreDexTransform.groovy</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hotfix.plugin</span><br><span class="line"></span><br><span class="line">import com.android.build.api.transform.*</span><br><span class="line">import com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line">import org.apache.commons.codec.digest.DigestUtils</span><br><span class="line">import org.apache.commons.io.FileUtils</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class PreDexTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    private Project mProject;</span><br><span class="line"></span><br><span class="line">    PreDexTransform(Project project) &#123;</span><br><span class="line">        mProject = project</span><br><span class="line">        def libPath = project.project(&quot;:hack&quot;).buildDir.absolutePath.concat(&quot;/intermediates/classes/debug&quot;)</span><br><span class="line">        println libPath</span><br><span class="line">        Inject.appendClassPath(libPath)</span><br><span class="line">        Inject.appendClassPath(&quot;/Users/liyazhou/Library/Android/sdk/platforms/android-24/android.jar&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;preDex&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException &#123;</span><br><span class="line">        // 遍历transfrom的inputs</span><br><span class="line">        // inputs有两种类型，一种是目录，一种是jar，需要分别遍历。</span><br><span class="line">        inputs.each &#123;TransformInput input -&gt;</span><br><span class="line">            input.directoryInputs.each &#123;DirectoryInput directoryInput -&gt;</span><br><span class="line">                //TODO 注入代码</span><br><span class="line">                Inject.injectDir(directoryInput.file.absolutePath)</span><br><span class="line"></span><br><span class="line">                def dest = outputProvider.getContentLocation(directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br><span class="line">                // 将input的目录复制到output指定目录</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.jarInputs.each &#123;JarInput jarInput -&gt;</span><br><span class="line">                //TODO 注入代码</span><br><span class="line">                String jarPath = jarInput.file.absolutePath;</span><br><span class="line">                String projectName = project.rootProject.name;</span><br><span class="line">                if(jarPath.endsWith(&quot;classes.jar&quot;)</span><br><span class="line">                        &amp;&amp; jarPath.contains(&quot;exploded-aar/&quot;+projectName)</span><br><span class="line">                        // hotpatch module是用来加载dex，无需注入代码</span><br><span class="line">                        &amp;&amp; !jarPath.contains(&quot;exploded-aar/&quot;+projectName+&quot;/hotpatch&quot;)) &#123;</span><br><span class="line">                    Inject.injectJar(jarPath)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 重命名输出文件（同目录copyFile会冲突）</span><br><span class="line">                def jarName = jarInput.name</span><br><span class="line">                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">                if(jarName.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">                    jarName = jarName.substring(0,jarName.length()-4)</span><br><span class="line">                &#125;</span><br><span class="line">                def dest = outputProvider.getContentLocation(jarName+md5Name, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Inject.groovy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hotfix.plugin</span><br><span class="line"></span><br><span class="line">import javassist.ClassPool</span><br><span class="line">import javassist.CtClass</span><br><span class="line">import javassist.NotFoundException</span><br><span class="line">import org.apache.commons.io.FileUtils</span><br><span class="line"></span><br><span class="line">public class Inject &#123;</span><br><span class="line">    private static ClassPool sPool = ClassPool.getDefault()</span><br><span class="line">    /**</span><br><span class="line">     * 添加classPath到ClassPool</span><br><span class="line">     * @param libPath</span><br><span class="line">     */</span><br><span class="line">    public static void appendClassPath(String libPath) throws NotFoundException &#123;</span><br><span class="line">        sPool.appendClassPath(libPath)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 遍历该目录下的所有class，对所有class进行代码注入。</span><br><span class="line">     * 其中以下class是不需要注入代码的：</span><br><span class="line">     * --- 1. R文件相关</span><br><span class="line">     * --- 2. 配置文件相关（BuildConfig）</span><br><span class="line">     * --- 3. Application</span><br><span class="line">     * @param path 目录的路径</span><br><span class="line">     */</span><br><span class="line">    public static void injectDir(String path) &#123;</span><br><span class="line">        sPool.appendClassPath(path)</span><br><span class="line">        File dir = new File(path)</span><br><span class="line">        if (dir.isDirectory()) &#123;</span><br><span class="line">            dir.eachFileRecurse &#123; File file -&gt;</span><br><span class="line"></span><br><span class="line">                String filePath = file.absolutePath</span><br><span class="line">                if (filePath.endsWith(&quot;.class&quot;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&apos;R$&apos;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&apos;R.class&apos;)</span><br><span class="line">                        &amp;&amp; !filePath.contains(&quot;BuildConfig.class&quot;)</span><br><span class="line">                        // 这里是application的名字，可自行配置</span><br><span class="line">                        &amp;&amp; !filePath.contains(&quot;HotFixApplication.class&quot;)) &#123;</span><br><span class="line">                    // 应用程序包名，可自行配置</span><br><span class="line">                    int index = filePath.indexOf(&quot;com/jinlin/base/hotfix&quot;)</span><br><span class="line">                    if (index != -1) &#123;</span><br><span class="line">                        int end = filePath.length() - 6 // .class = 6</span><br><span class="line">                        String className = filePath.substring(index, end).replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;)</span><br><span class="line">                        injectClass(className, path)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里需要将jar包先解压，注入代码后再重新生成jar包</span><br><span class="line">     * @path jar包的绝对路径</span><br><span class="line">     */</span><br><span class="line">    public static void injectJar(String path) &#123;</span><br><span class="line">        if (path.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">            File jarFile = new File(path)</span><br><span class="line"></span><br><span class="line">            // jar包解压后的保存路径</span><br><span class="line">            String jarZipDir = jarFile.getParent() + &quot;/&quot; + jarFile.getName().replace(&apos;.jar&apos;, &apos;&apos;)</span><br><span class="line"></span><br><span class="line">            // 解压jar包, 返回jar包中所有class的完整类名的集合（带.class后缀）</span><br><span class="line">            List classNameList = JarZipUtils.unzipJar(path, jarZipDir)</span><br><span class="line"></span><br><span class="line">            // 删除原来的jar包</span><br><span class="line">            jarFile.delete()</span><br><span class="line"></span><br><span class="line">            // 注入代码</span><br><span class="line">            sPool.appendClassPath(jarZipDir)</span><br><span class="line">            for (String className : classNameList) &#123;</span><br><span class="line">                if (className.endsWith(&quot;.class&quot;)</span><br><span class="line">                        &amp;&amp; !className.contains(&apos;R$&apos;)</span><br><span class="line">                        &amp;&amp; !className.contains(&apos;R.class&apos;)</span><br><span class="line">                        &amp;&amp; !className.contains(&quot;BuildConfig.class&quot;)) &#123;</span><br><span class="line">                    className = className.substring(0, className.length() - 6)</span><br><span class="line">                    injectClass(className, jarZipDir)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 从新打包jar</span><br><span class="line">            JarZipUtils.zipJar(jarZipDir, path)</span><br><span class="line"></span><br><span class="line">            // 删除目录</span><br><span class="line">            FileUtils.deleteDirectory(new File(jarZipDir))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void injectClass(String className, String path) &#123;</span><br><span class="line">        CtClass c = sPool.getCtClass(className)</span><br><span class="line">        if (c.isFrozen()) &#123;</span><br><span class="line">            c.defrost()</span><br><span class="line">        &#125;</span><br><span class="line">        def constructor = c.getConstructors()[0];</span><br><span class="line">        constructor.insertAfter(&quot;System.out.println(com.jinlin.base.hack.AntilazyLoad.class);&quot;)</span><br><span class="line">        c.writeFile(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JarZipUtil.groovy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.jar.JarEntry</span><br><span class="line">import java.util.jar.JarFile</span><br><span class="line">import java.util.jar.JarOutputStream</span><br><span class="line">import java.util.zip.ZipEntry</span><br><span class="line"></span><br><span class="line">public class JarZipUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将该jar包解压到指定目录</span><br><span class="line">     * @param jarPath jar包的绝对路径</span><br><span class="line">     * @param destDirPath jar包解压后的保存路径</span><br><span class="line">     * @return 返回该jar包中包含的所有class的完整类名类名集合，其中一条数据如：com.aitski.hotpatch.Xxxx.class</span><br><span class="line">     */</span><br><span class="line">    public static List unzipJar(String jarPath, String destDirPath) &#123;</span><br><span class="line"></span><br><span class="line">        List list = new ArrayList()</span><br><span class="line">        if (jarPath.endsWith(&apos;.jar&apos;)) &#123;</span><br><span class="line"></span><br><span class="line">            JarFile jarFile = new JarFile(jarPath)</span><br><span class="line">            Enumeration&lt;JarEntry&gt; jarEntrys = jarFile.entries()</span><br><span class="line">            while (jarEntrys.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry = jarEntrys.nextElement()</span><br><span class="line">                if (jarEntry.directory) &#123;</span><br><span class="line">                    continue</span><br><span class="line">                &#125;</span><br><span class="line">                String entryName = jarEntry.getName()</span><br><span class="line">                if (entryName.endsWith(&apos;.class&apos;)) &#123;</span><br><span class="line">                    String className = entryName.replace(&apos;\\&apos;, &apos;.&apos;).replace(&apos;/&apos;, &apos;.&apos;)</span><br><span class="line">                    list.add(className)</span><br><span class="line">                &#125;</span><br><span class="line">                String outFileName = destDirPath + &quot;/&quot; + entryName</span><br><span class="line">                File outFile = new File(outFileName)</span><br><span class="line">                outFile.getParentFile().mkdirs()</span><br><span class="line">                InputStream inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">                FileOutputStream fileOutputStream = new FileOutputStream(outFile)</span><br><span class="line">                fileOutputStream &lt;&lt; inputStream</span><br><span class="line">                fileOutputStream.close()</span><br><span class="line">                inputStream.close()</span><br><span class="line">            &#125;</span><br><span class="line">            jarFile.close()</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新打包jar</span><br><span class="line">     * @param packagePath 将这个目录下的所有文件打包成jar</span><br><span class="line">     * @param destPath 打包好的jar包的绝对路径</span><br><span class="line">     */</span><br><span class="line">    public static void zipJar(String packagePath, String destPath) &#123;</span><br><span class="line"></span><br><span class="line">        File file = new File(packagePath)</span><br><span class="line">        JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(destPath))</span><br><span class="line">        file.eachFileRecurse &#123; File f -&gt;</span><br><span class="line">            String entryName = f.getAbsolutePath().substring(packagePath.length() + 1)</span><br><span class="line">            outputStream.putNextEntry(new ZipEntry(entryName))</span><br><span class="line">            if (!f.directory) &#123;</span><br><span class="line">                InputStream inputStream = new FileInputStream(f)</span><br><span class="line">                outputStream &lt;&lt; inputStream</span><br><span class="line">                inputStream.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>在app module下build.gradle文件中添加新插件：apply plugin: com.hotpatch.plugin.Register</p>
</li>
<li><p>创建hack.jar<br>创建一个单独的module，命名为com.hotpatch.plugin.AntilazyLoad</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jinlin.base.hack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntilazyLoad</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上一篇博客介绍的方法打包hack.jar。然后将hack.jar复制到app module下的assets目录中。另外注意：app module不能依赖hack module。之所以要创建一个hack module，同时人为地在dex打包过程中插入对其他hack.jar中类的依赖，就是要让apk文件在安装的时候不被打上CLASS_ISPREVERIFIED标记。<br>另外由于hack.jar位于assets中，所以必须要在加载patch_dex之前加载hack.jar。另外由于加载其他路径的dex文件都是在Application.onCreate()方法中执行的，此时还没有加载hack.jar，所以这就是为什么在上一章节插桩的时候不能在Application中插桩的原因。</p>
<p>插桩的过程介绍完了，整个热修复的过程也就差不多了，读者可以参考完整的代码进行demo试用：Hotpatch Demo</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/03/Android-hotfix-2/" class="prev">PREV</a><a href="/2016/04/01/Android-hotfix-0/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>