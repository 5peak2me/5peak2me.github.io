<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 简单分析RecyclerView三大流程 · J!nl!n's Blog</title><meta name="description" content="简单分析RecyclerView三大流程 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">简单分析RecyclerView三大流程</h1><div class="post-info">May 13, 2016</div><div class="post-content"><p>　　<strong> 概述：</strong>在日常开发中，列表的使用非常的普遍，从起初的AdapterView到现在的RecyclerView都实现了展示大量数据集，而内存不会出现OOM的情况。它们各自都实现了对应的缓存机制来实现回收功能。关于RecyclerView的缓存机制，后续使用独立篇幅介绍，本篇着重从View的三大基本流程分析。<br><a id="more"></a><br>本篇所有源码基于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.android.support:recyclerview-v7:23.2.1&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果LayoutManager为空，则走默认的measure逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) &#123; <span class="comment">// 如果LayoutManager设置了setAutoMeasureEnabled为true</span></span><br><span class="line">        <span class="comment">// 第一部分：</span></span><br><span class="line">        <span class="comment">// 1) 调用LayoutManager#onMeasure，在其内部调用了RecyclerView#defaultOnMeasure，然后调用LayoutManager.chooseSize。</span></span><br><span class="line">        <span class="comment">// 2) 检查如果width和height都是精确值，那么就不用再根据内容进行计算所需要的width和height，跳过之后的步骤。如果有其中任何一个值不是精确值，则进入到下面计算所需长宽的步骤。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">if</span> (skipMeasure || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二部分：</span></span><br><span class="line">        <span class="comment">// 1) 开启布局流程计算出所有Child的边界</span></span><br><span class="line">        <span class="comment">// 2) 然后根据计算出的Child的边界计算出RecyclerView的所需width和height</span></span><br><span class="line">        <span class="comment">// 3) 检查是否需要再次测量</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span></span><br><span class="line">        <span class="comment">// consistency</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        <span class="comment">// 布局过程结束，根据Children中的边界信息计算并设置RecyclerView长宽的测量值</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">        <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">        <span class="comment">// 检查是否需要再次测量。如果RecyclerView仍然有非精确的宽和高，或者这里还有至少一个Child还有非精确的宽和高，我们就需要在此测量。</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一部分：如果RecyclerView已经设置了Size固定，则执行LayoutManager#onMeasure方法</span></span><br><span class="line">        <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二部分：</span></span><br><span class="line">        <span class="comment">// 1) 如果在测量的过程中有数据有更新，则先处理更新的数据</span></span><br><span class="line">        <span class="comment">// 2) 执行自定义测量流程，这需要自定义的LayoutManager#onMeasure方法。</span></span><br><span class="line">        <span class="comment">// custom onMeasure</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">            eatRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// consume remaining updates to provide a consistent state with the layout pass.</span></span><br><span class="line">                mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapterUpdateDuringMeasure = <span class="keyword">false</span>;</span><br><span class="line">            resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完新更新的数据，然后执行自定义测量操作。</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eatRequestLayout();</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>; <span class="comment">// clear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，进入的都是自动测量模式。系统提供的<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>、<code>StaggeredGridLayoutManager</code>基本上都在构造函数中直接或者间接设置了<code>setAutoMeasureEnabled</code>为<code>true</code>。如果我们自定义<code>LayoutManager</code>的时候，需要根据需求决定是否开启自动测量，默认是不开启的。</p>
<h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...省略部分代码</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        <span class="comment">// 1) 没有执行过布局流程的情况</span></span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() ||</span><br><span class="line">            mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        <span class="comment">// 2) 执行过布局流程，但是之后size又有变化的情况</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 执行过布局流程，可以直接使用之前数据的情况</span></span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>RecyclerView</code>的布局过程分为3步：<code>dispatchLayoutStep1</code>，<code>dispatchLayoutStep2</code>和<code>dispatchLayoutStep3</code>。在上面自动测量过程中我们为了得到Child的边界值，使用了<code>dispatchLayoutStep1</code>和<code>dispatchLayoutStep2</code>，所以在<code>dispatchLayout</code>中分了三种情况进行处理</p>
<ul>
<li>1.没有执行过布局流程的情况</li>
<li>2.执行过布局流程，但是之后size又有变化的情况</li>
<li>3.执行过布局流程，可以直接使用之前数据的情况</li>
</ul>
<p>不过，无论何种情况，最终都是完成<code>dispatchLayoutStep1</code>，<code>dispatchLayoutStep2</code>和<code>dispatchLayoutStep3</code>这三步，其中<code>dispatchLayoutStep1</code>就是pre layout，<code>dispatchLayoutStep3</code>是post layout，而<code>dispatchLayoutStep2</code>是处理真正测量&amp;布局的了。这样的情况区分只是为了避免重复计算。接下来按步分析。</p>
<h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The first step of a layout where we;</span></span><br><span class="line"><span class="comment"> * - process adapter updates</span></span><br><span class="line"><span class="comment"> * - decide which animation should run</span></span><br><span class="line"><span class="comment"> * - save information about current views</span></span><br><span class="line"><span class="comment"> * - If necessary, run predictive layout and save its information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags(); <span class="comment">// 动画相关</span></span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                            ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                            holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">            <span class="keyword">if</span> (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">                <span class="comment">// This is NOT the only place where a ViewHolder is added to old change holders</span></span><br><span class="line">                <span class="comment">// list. There is another case where:</span></span><br><span class="line">                <span class="comment">//    * A VH is currently hidden but not deleted</span></span><br><span class="line">                <span class="comment">//    * The hidden item is changed in the adapter</span></span><br><span class="line">                <span class="comment">//    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span></span><br><span class="line">                <span class="comment">// When this case is detected, RV will un-hide that view and add to the old</span></span><br><span class="line">                <span class="comment">// change holders list.</span></span><br><span class="line">                mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        saveOldPositions();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didStructureChange = mState.mStructureChanged;</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// temporarily disable flag because we are asking for previous layout</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mChildHelper.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">            <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                <span class="keyword">boolean</span> wasHidden = viewHolder</span><br><span class="line">                        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                <span class="keyword">if</span> (!wasHidden) &#123;</span><br><span class="line">                    flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                        mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                <span class="keyword">if</span> (wasHidden) &#123;</span><br><span class="line">                    recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we don't process disappearing list because they may re-appear in post layout pass.</span></span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>ItemHolderInfo</code>是<code>RecyclerView</code>的内部类<code>ItemAnimator</code>的内部类。其中封装了对应ItemView的边界信息，即ItemView的left、top、right、bottom值。对象mViewInfoStore的作用注释写的很清楚，是提供给动画使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps data about views to be used for animations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> ViewInfoStore mViewInfoStore = <span class="keyword">new</span> ViewInfoStore();</span><br></pre></td></tr></table></figure>
<p>继续来看<code>ViewInfoStore</code>的<code>addToPreLayout</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the item information to the prelayout tracking</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> holder The ViewHolder whose information is being saved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info The information to save</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPreLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.preInfo = info;</span><br><span class="line">    record.flags |= FLAG_PRE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>RecyclerView</code>将pre layout阶段的ItemView信息存放在了ViewInfoStore中的mLayoutHolderMap集合中。</p>
<h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The second layout step where we do the actual layout of the views for the final state.</span></span><br><span class="line"><span class="comment"> * This step might be run multiple times if necessary (e.g. measure).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 调用LayoutManager#onLayoutChildren方法，如果我们自定义LayoutManager则需要重写此方法，具体可以参考系统提供的三种LayoutManager</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释就可以看出这是我们做实际布局的逻辑。</p>
<h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The final step of the layout where we save the information about views for animations,</span></span><br><span class="line"><span class="comment"> * trigger animations and do any necessary cleanup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 3: Find out where things are now, and process change animations.</span></span><br><span class="line">        <span class="comment">// traverse list in reverse because we may call animateChange in the loop which may</span></span><br><span class="line">        <span class="comment">// remove the target view holder.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPostLayoutInformation(mState, holder);</span><br><span class="line">            ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class="line">            <span class="keyword">if</span> (oldChangeViewHolder != <span class="keyword">null</span> &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="comment">// run a change animation</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If an Item is CHANGED but the updated version is disappearing, it creates</span></span><br><span class="line">                <span class="comment">// a conflicting case.</span></span><br><span class="line">                <span class="comment">// Since a view that is marked as disappearing is likely to be going out of</span></span><br><span class="line">                <span class="comment">// bounds, we run a change animation. Both views will be cleaned automatically</span></span><br><span class="line">                <span class="comment">// once their animations finish.</span></span><br><span class="line">                <span class="comment">// On the other hand, if it is the same view holder instance, we run a</span></span><br><span class="line">                <span class="comment">// disappearing animation instead because we are not going to rebind the updated</span></span><br><span class="line">                <span class="comment">// VH unless it is enforced by the layout manager.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class="line">                        oldChangeViewHolder);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class="line">                <span class="keyword">if</span> (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                    <span class="comment">// run disappear animation instead of change</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class="line">                            oldChangeViewHolder);</span><br><span class="line">                    <span class="comment">// we add and remove so that any post info is merged.</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                    ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class="line">                    <span class="keyword">if</span> (preInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class="line">                                oldDisappearing, newDisappearing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">    mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class="line">    mDataSetHasChangedAfterLayout = <span class="keyword">false</span>;</span><br><span class="line">    mState.mRunSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mState.mRunPredictiveAnimations = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.mRequestedSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecycler.mChangedScrap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecycler.mChangedScrap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">        <span class="comment">// Initial prefetch has expanded cache, so reset until next prefetch.</span></span><br><span class="line">        <span class="comment">// This prevents initial prefetches from expanding the cache permanently.</span></span><br><span class="line">        mLayout.mPrefetchMaxCountObserved = <span class="number">0</span>;</span><br><span class="line">        mLayout.mPrefetchMaxObservedInInitialPrefetch = <span class="keyword">false</span>;</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayout.onLayoutCompleted(mState);</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    <span class="keyword">if</span> (didChildRangeChange(mMinMaxLayoutPositions[<span class="number">0</span>], mMinMaxLayoutPositions[<span class="number">1</span>])) &#123;</span><br><span class="line">        dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recoverFocusFromState();</span><br><span class="line">    resetFocusInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看<code>ViewInfoStore</code>的<code>addToPostLayout</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the item information to the post layout list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> holder The ViewHolder whose information is being saved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info The information to save</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;</span><br><span class="line">    record.flags |= FLAG_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与pre layout阶段相同<code>RecyclerView</code>也是将post layout阶段的ItemView信息存放在mViewInfoStore的mLayoutHolderMap集合中，并且不难看出，同一个ItemView（或者叫ViewHolder）的pre layout信息与post layout信息封装在了同一个InfoRecord中，分别叫InfoRecord.preInfo与InforRecord.postInfo，这样InfoRecord就保存着同一个ItemView在数据集变化前后的信息，我们可以根据此信息定义动画的开始和结束状态。 </p>
<h4 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onDraw</code>的代码比较简单，调用<code>super.onDraw(c)</code>执行绘制逻辑，同时获取<code>ItemDecoration</code>个数，分别调用<code>ItemDecoration</code>的<code>onDraw</code>对分割线进行了绘制。这里有个疑问就是<code>ItemDecoration</code>还有个<code>onDrawOver</code>方法是在哪里调用的呢？我们看<code>RecyclerView</code>的<code>draw</code>方法有下面这样一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看到<code>ItemDecoration</code>的<code>onDraw</code>是优先于<code>onDrawOver</code>调用的。（具体请自行了解View的绘制流程中draw方法的代码细节）</p>
<p>到此，<code>RecyclerView</code>的三大基本流程就简要分析完了。至于很多细节，诸如缓存机制、动画更新等都没有做详细的分析，后续会单独开辟博文继续剖析。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/12/Apk打包流程/" class="prev">PREV</a><a href="/2016/04/13/python-tools/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>