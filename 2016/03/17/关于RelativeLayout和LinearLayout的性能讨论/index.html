<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于RelativeLayout和LinearLayout的性能讨论 · J!nl!n's Blog</title><meta name="description" content="关于RelativeLayout和LinearLayout的性能讨论 - J!nl!n"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://daijinlin.com/atom.xml" title="J!nl!n's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/5peak2me" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于RelativeLayout和LinearLayout的性能讨论</h1><div class="post-info">Mar 17, 2016</div><div class="post-content"><p>　　<strong> 概述：</strong>我们知道RelativeLayout和LinearLayout是Android中常用的布局，日常使用的再频繁不过。但是如果不正确使用会极大的影响性能，因此，正确的使用它们是提升程序性能的关键性工作。<br><a id="more"></a></p>
<h5 id="关于影响性能的重要因素"><a href="#关于影响性能的重要因素" class="headerlink" title="关于影响性能的重要因素"></a>关于影响性能的重要因素</h5><p>我们知道一个View要经历measure/layout/draw三大流程，这里不做详细叙述具体的可以查阅相关资料或者源码来学习。这里我们通过查看源码可以发现其主要的性能差异表现在<code>onMeasure</code>的逻辑上。</p>
<h5 id="LinearLayout的onMeasure源码"><a href="#LinearLayout的onMeasure源码" class="headerlink" title="LinearLayout的onMeasure源码"></a>LinearLayout的<code>onMeasure</code>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到LinearLayout先会判断我们所设置的布局方向，分别执行不同的测量逻辑。由此，我们可以推测其<code>onLayout</code>的逻辑应该也是会判断方向，这里就不做解释了。布局方向可以通过xml或者java设置。如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:orientation="vertical"</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setOrientation(<span class="meta">@OrientationMode</span> <span class="keyword">int</span> orientation)</span><br></pre></td></tr></table></figure>
<p>我们这里只考虑竖直的方向情况，横向的原理类似，可自行查看源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measures the children when the orientation of this LinearLayout is set</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> #VERTICAL&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getOrientation()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setOrientation(int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onMeasure(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> weightedMaxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">float</span> totalWeight = <span class="number">0</span>; <span class="comment">// 初始化0</span></span><br><span class="line">    <span class="comment">// 获取子View的个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> matchWidth = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> skippedMeasure = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> baselineChildIndex = mBaselineAlignedChildIndex;        </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> consumedExcessSpace = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="comment">// 如果都没有设置weight，则还是0，下面的布尔值为false</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> useExcessSpace = lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="comment">// Optimization: don't bother measuring children who are only</span></span><br><span class="line">            <span class="comment">// laid out using excess space. These views will get measured</span></span><br><span class="line">            <span class="comment">// later if we have space to distribute.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                <span class="comment">// The heightMode is either UNSPECIFIED or AT_MOST, and</span></span><br><span class="line">                <span class="comment">// this child is only laid out using excess space. Measure</span></span><br><span class="line">                <span class="comment">// using WRAP_CONTENT so that we can find out the view's</span></span><br><span class="line">                <span class="comment">// optimal height. We'll restore the original height of 0</span></span><br><span class="line">                <span class="comment">// after measurement.</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">            <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">            <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">            <span class="comment">// if needed).</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第一次测量</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>, </span><br><span class="line">                    heightMeasureSpec, usedHeight); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                <span class="comment">// Restore the original height and record how much space</span></span><br><span class="line">                <span class="comment">// we've allocated to excess-only children so that we can</span></span><br><span class="line">                <span class="comment">// match the behavior of EXACTLY measurement.</span></span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * If applicable, compute the additional offset to the child's baseline</span></span><br><span class="line"><span class="comment">         * we'll need later when asked &#123;<span class="doctag">@link</span> #getBaseline&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"A child of LinearLayout with index "</span></span><br><span class="line">                    + <span class="string">"less than mBaselineAlignedChildIndex has weight &gt; 0, which "</span></span><br><span class="line">                    + <span class="string">"won't work.  Either remove the weight, or don't set "</span></span><br><span class="line">                    + <span class="string">"mBaselineAlignedChildIndex."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> matchWidthLocally = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="keyword">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTotalLength &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></span><br><span class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="keyword">int</span> remainingExcess = heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure || remainingExcess != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> remainingWeightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> childWeight = lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// This child needs to be laid out from scratch using</span></span><br><span class="line">                    <span class="comment">// only its share of excess space.</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This child had some intrinsic height to which we</span></span><br><span class="line">                    <span class="comment">// need to add its share of excess space.</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">                <span class="comment">// 第二次测量</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> childExtra = lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line">    </span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，Linearlayout会先对所有的子View进行计算totalWeight（所有子View的weight属性之和），然后判断子View的weight属性是否为最大，如为最大则将剩余的空间分配给它。如果不使用weight的话，则不会进行第二次measure的操作。</p>
<h5 id="来看下RelativeLayout的onMeasure源码"><a href="#来看下RelativeLayout的onMeasure源码" class="headerlink" title="来看下RelativeLayout的onMeasure源码"></a>来看下RelativeLayout的<code>onMeasure</code>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDirtyHierarchy) &#123;</span><br><span class="line">        mDirtyHierarchy = <span class="keyword">false</span>;</span><br><span class="line">        sortChildren();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> myWidth = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> myHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record our dimensions if they are known;</span></span><br><span class="line">    <span class="keyword">if</span> (widthMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">        myWidth = widthSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heightMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">        myHeight = heightSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        width = myWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        height = myHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    View ignore = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> gravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> horizontalGravity = gravity != Gravity.START &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line">    gravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> verticalGravity = gravity != Gravity.TOP &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> top = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> bottom = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> offsetHorizontalAxis = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> offsetVerticalAxis = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((horizontalGravity || verticalGravity) &amp;&amp; mIgnoreGravity != View.NO_ID) &#123;</span><br><span class="line">        ignore = findViewById(mIgnoreGravity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentWidth = widthMode != MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentHeight = heightMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to know our size for doing the correct computation of children positioning in RTL</span></span><br><span class="line">    <span class="comment">// mode but there is no practical way to get it instead of running the code below.</span></span><br><span class="line">    <span class="comment">// So, instead of running the code twice, we just set the width to a "default display width"</span></span><br><span class="line">    <span class="comment">// before the computation and then, as a last pass, we will update their real position with</span></span><br><span class="line">    <span class="comment">// an offset equals to "DEFAULT_WIDTH - width".</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">    <span class="keyword">if</span> (isLayoutRtl() &amp;&amp; myWidth == -<span class="number">1</span>) &#123;</span><br><span class="line">        myWidth = DEFAULT_WIDTH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取横向的子View</span></span><br><span class="line">    View[] views = mSortedHorizontalChildren;</span><br><span class="line">    <span class="keyword">int</span> count = views.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = views[i];</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">            applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">            <span class="comment">// 横向测量子View</span></span><br><span class="line">            measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">                offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取纵向的子View</span></span><br><span class="line">    views = mSortedVerticalChildren;</span><br><span class="line">    count = views.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = views[i];</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">            <span class="comment">// 纵向测量子View</span></span><br><span class="line">            measureChild(child, params, myWidth, myHeight);</span><br><span class="line">            <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">                offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                        width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        width = Math.max(width, myWidth - params.mLeft - params.leftMargin);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                        width = Math.max(width, params.mRight);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                    height = Math.max(height, params.mBottom);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">                left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">                top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">                right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">                bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the top-start-most laid out view as the baseline. RTL offsets are</span></span><br><span class="line">    <span class="comment">// applied later, so we can use the left-most edge as the starting edge.</span></span><br><span class="line">    View baselineView = <span class="keyword">null</span>;</span><br><span class="line">    LayoutParams baselineParams = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = views[i];</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams childParams = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (baselineView == <span class="keyword">null</span> || baselineParams == <span class="keyword">null</span></span><br><span class="line">                    || compareLayoutPosition(childParams, baselineParams) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                baselineView = child;</span><br><span class="line">                baselineParams = childParams;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mBaselineView = baselineView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="comment">// Width already has left padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the right of each child view</span></span><br><span class="line">        width += mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            width = Math.max(width, mLayoutParams.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerHorizontal(child, params, width);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                        params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                        params.mRight = params.mLeft + childWidth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="comment">// Height already has top padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the bottom of each child view</span></span><br><span class="line">        height += mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            height = Math.max(height, mLayoutParams.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerVertical(child, params, height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                        params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                        params.mBottom = params.mTop + childHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalGravity || verticalGravity) &#123;</span><br><span class="line">        <span class="keyword">final</span> Rect selfBounds = mSelfBounds;</span><br><span class="line">        selfBounds.set(mPaddingLeft, mPaddingTop, width - mPaddingRight,</span><br><span class="line">                height - mPaddingBottom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Rect contentBounds = mContentBounds;</span><br><span class="line">        Gravity.apply(mGravity, right - left, bottom - top, selfBounds, contentBounds,</span><br><span class="line">                layoutDirection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> horizontalOffset = contentBounds.left - left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> verticalOffset = contentBounds.top - top;</span><br><span class="line">        <span class="keyword">if</span> (horizontalOffset != <span class="number">0</span> || verticalOffset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE &amp;&amp; child != ignore) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">if</span> (horizontalGravity) &#123;</span><br><span class="line">                        params.mLeft += horizontalOffset;</span><br><span class="line">                        params.mRight += horizontalOffset;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (verticalGravity) &#123;</span><br><span class="line">                        params.mTop += verticalOffset;</span><br><span class="line">                        params.mBottom += verticalOffset;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetWidth = myWidth - width;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = views[i];</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                params.mLeft -= offsetWidth;</span><br><span class="line">                params.mRight -= offsetWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面注释的核心代码可以看出RelativeLayout作为复杂布局的根布局分别会对所有的子View进行横竖两次测量。</p>
<h5 id="正确使用结论"><a href="#正确使用结论" class="headerlink" title="正确使用结论"></a>正确使用结论</h5><p>根据以上的分析结果，那么我们知道如果使用RelativeLayout或者使用LinearLayout并且使用weight作为根布局，并且其子View的嵌套复杂层级较深的话。这里注意，尤其像列表空间诸如ListView或者RecyclerView的子Item等，就会对性能造成一定的影响。一般的我们不推荐使用RelativeLayout作为复杂布局的根布局。当然Google就为了解决这一问题新引入了约束布局（ConstraintLayout）的概念。ConstraintLayout极大的减少了层级嵌套使复杂的View变得简单。关于ConstraintLayout的介绍和使用后续会写博文具体描述。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/01/Android-hotfix-0/" class="prev">上一篇</a><a href="/2016/03/03/Android绘制文本细节整理/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://daijinlin.com">J!nl!n</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>